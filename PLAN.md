# Splinter Integration Plan

## Goal
Integrate splinter into the codegen/rule setup used for the analyser, providing a consistent API (both internally and user-facing) for all types of analysers/linters.

## Architecture Vision

### Crate Responsibilities

**`pgls_analyse`** - Generic framework for all analyzer types
- Generic traits: `RuleMeta`, `RuleGroup`, `GroupCategory`, `RegistryVisitor`
- Shared types: `RuleMetadata`, `RuleCategory`
- Configuration traits (execution-agnostic)
- Macros: `declare_rule!`, `declare_group!`, `declare_category!`

**`pgls_linter`** (renamed from `pgls_analyser`) - AST-based source code linting
- `LinterRule` trait (extends `RuleMeta`)
- `LinterRuleContext` (wraps AST nodes)
- `LinterDiagnostic` (span-based diagnostics)
- `LinterRuleRegistry` (type-erased executors)

**`pgls_splinter`** - Database-level linting
- `SplinterRule` trait (extends `RuleMeta`)
- `SplinterRuleRegistry` (metadata-based)
- `SplinterDiagnostic` (db-object-based diagnostics)
- Generated rule types from SQL files

**`pgls_configuration`**
- `analyser/linter/` - Generated from `pgls_linter`
- `analyser/splinter/` - Generated from `pgls_splinter`
- Per-rule configuration for both

## Implementation Phases

### Phase 1: Refactor pgls_analyse ‚è≥ IN PROGRESS
Extract AST-specific code into pgls_linter, keep only generic framework in pgls_analyse.

**Tasks:**
- [x] Analyze current `pgls_analyse` exports
- [x] Identify AST-specific vs generic code
- [x] Create new modules in `pgls_analyser`:
  - [x] `linter_rule.rs` - LinterRule trait, LinterDiagnostic
  - [x] `linter_context.rs` - LinterRuleContext, AnalysedFileContext
  - [x] `linter_options.rs` - LinterOptions, LinterRules
  - [x] `linter_registry.rs` - LinterRuleRegistry, LinterRegistryVisitor
- [x] Create `pgls_analyse/src/metadata.rs` - Generic traits only
- [x] Update `pgls_analyse/src/registry.rs` - Keep MetadataRegistry only
- [x] Update `pgls_analyse/src/lib.rs` - Export generic framework
- [x] Update `pgls_analyser/src/lib.rs` - Use new modules
- [x] Fix imports in filter.rs (RuleMeta instead of Rule)
- [x] Update generated files (options.rs, registry.rs)
- [x] Fix imports in all rule files
- [x] Add rustc-hash dependency
- [x] Verify compilation completes - **RESOLVED**
- [x] Separate visitor concerns from executor creation
- [x] Update codegen to generate factory function
- [x] Fix all import paths across workspace
- [x] Verify full workspace compiles
- [x] Optimize executor creation (zero-cost abstraction)
- [ ] Run tests

**Resolution:**
Separated two concerns:
1. **Visitor pattern** (generic): Collects rule keys that match the filter
   - Implementation in `LinterRuleRegistryBuilder::record_rule`
   - Only requires `R: RuleMeta` (satisfies trait)
2. **Executor mapping** (AST-specific): Maps rule keys directly to executors
   - Function `get_linter_rule_executor` in `registry.rs`
   - Generated by codegen with full type information
   - Zero-cost abstraction: no Box, no dyn, no closures

**Final Implementation:**
- `LinterRuleRegistryBuilder` stores `Vec<RuleKey>` from visitor traversal
- `record_rule` only collects keys (generic, no LinterRule bounds)
- `build()` calls `get_linter_rule_executor` for each key
- Generated match statement returns executors directly (no heap allocation)

**Performance:**
- ‚úÖ No `Box<dyn FnOnce()>` - returns values directly
- ‚úÖ No closure overhead - simple match statement
- ‚úÖ No dynamic dispatch - static dispatch only
- ‚úÖ Clean codegen - 33 rules map to executors efficiently

**Design Decisions:**
- ‚úÖ Keep `RuleDiagnostic` generic or make it linter-specific? ‚Üí **Move to pgls_linter as LinterDiagnostic** (Option A)
  - Rationale: Fundamentally different location models (spans vs db objects)
  - LinterDiagnostic: span-based
  - SplinterDiagnostic: db-object-based

**Code Classification:**

AST-specific (move to pgls_analyser):
- `Rule` trait
- `RuleContext`
- `RuleDiagnostic` ‚Üí `LinterDiagnostic`
- `AnalysedFileContext`
- `RegistryRuleParams`
- `RuleRegistry`, `RuleRegistryBuilder` (AST execution)
- `AnalyserOptions`, `AnalyserRules` (rule options storage)

Generic (keep in pgls_analyse):
- `RuleMeta` trait
- `RuleMetadata` struct
- `RuleGroup` trait
- `GroupCategory` trait
- `RegistryVisitor` trait
- `RuleCategory` enum
- `RuleSource` enum
- `RuleFilter`, `AnalysisFilter`, `RuleKey`, `GroupKey`
- `MetadataRegistry`
- Macros: `declare_rule!`, `declare_lint_rule!`, `declare_lint_group!`, `declare_category!`

---

### Phase 2: Enhance pgls_splinter ‚úÖ COMPLETED
Add rule type generation and registry similar to linter.

**Tasks:**
- [x] Create `pgls_splinter/src/rule.rs` with `SplinterRule` trait
- [x] Create `pgls_splinter/src/rules/` directory structure
- [x] Generate rule types from SQL files
- [x] Generate registry with `visit_registry()` function
- [x] Split monolithic SQL files into individual rule files with metadata
- [x] Create codegen to extract metadata from SQL comments
- [x] Generate get_sql_file_path() function for SQL file mapping
- [ ] Update diagnostics to use generated categories (deferred)
- [ ] Update runtime to build dynamic queries (deferred to Phase 3)

**Structure:**
```
pgls_splinter/src/
  rules/
    performance/
      unindexed_foreign_keys.rs   # Generated
      auth_rls_initplan.rs        # Generated
      ...                          # 7 total
      mod.rs                       # Generated group
    security/
      auth_users_exposed.rs        # Generated
      ...                          # 14 total
      mod.rs                       # Generated group
    mod.rs                         # Generated category
  rule.rs                          # Generated SplinterRule trait
  registry.rs                      # Generated visit_registry() + get_sql_file_path()

pgls_splinter/vendor/
  performance/
    *.sql                          # 7 individual SQL files with metadata
  security/
    *.sql                          # 14 individual SQL files with metadata
```

**Implementation Summary:**
- Implemented Option C (Hybrid Approach) from initial analysis
- SQL files remain source of truth with metadata comments
- Codegen extracts metadata and generates Rust structures
- `SplinterRule` trait extends `RuleMeta` with `sql_file_path()` method
- Registry provides centralized rule discovery via visitor pattern
- Category structure: `Splinter` (Lint) ‚Üí `Performance`/`Security` (groups) ‚Üí individual rules
- Successfully compiles without errors

---

### Phase 3: Integrate configuration and documentation üìã PLANNED
Complete integration of splinter into the configuration and documentation systems.

**Tasks:**
- [ ] **Configuration Generation**:
  - [ ] Create `pgls_configuration/src/analyser/splinter/` directory
  - [ ] Generate splinter configuration types (groups, rules)
  - [ ] Update `generate_configuration.rs` to visit splinter registry
  - [ ] Generate `crates/pgls_configuration/src/generated/splinter.rs`
  - [ ] Update `analyser/mod.rs` to export splinter config
  - [ ] Add splinter to RuleSelector enum

- [ ] **Documentation Enhancement** (FUTURE):
  - [ ] Add SQL query examples to splinter rule docs (similar to linter)
  - [ ] Extract SQL from vendor/*.sql files into doc comments
  - [ ] Add usage examples and remediation steps
  - [ ] Generate rule documentation via docs_codegen

- [ ] **Runtime Integration** (DEFERRED):
  - [ ] Update `run_splinter()` to use visitor pattern with AnalysisFilter
  - [ ] Build dynamic SQL queries from enabled rules only
  - [ ] Remove hardcoded SQL query execution
  - [ ] Remove hardcoded category mapping in convert.rs

- [ ] **Testing**:
  - [ ] Run `just gen-lint` successfully
  - [ ] Verify linter configuration still works
  - [ ] Verify splinter configuration generates
  - [ ] Test enabling/disabling splinter rules via config
  - [ ] Verify full workspace compiles

**Codegen Outputs After Phase 3:**
```
Linter:
  - crates/pgls_analyser/src/registry.rs (generated)
  - crates/pgls_analyser/src/options.rs (generated)
  - crates/pgls_configuration/src/analyser/linter/ (generated)
  - crates/pgls_configuration/src/generated/linter.rs (generated)

Splinter:
  - crates/pgls_splinter/src/rules/ (generated - ‚úÖ DONE)
  - crates/pgls_splinter/src/rule.rs (generated - ‚úÖ DONE)
  - crates/pgls_splinter/src/registry.rs (generated - ‚úÖ DONE)
  - crates/pgls_configuration/src/analyser/splinter/ (TODO)
  - crates/pgls_configuration/src/generated/splinter.rs (TODO)
```

**Notes:**
- Runtime integration (dynamic SQL query building) is deferred as it requires more complex changes to `run_splinter()`
- Documentation enhancement with SQL examples is marked as FUTURE work
- Focus Phase 3 on configuration integration to enable rule enable/disable via config files

---

### Phase 4: Rename pgls_analyser ‚Üí pgls_linter üìã PLANNED
Final rename to clarify purpose.

**Tasks:**
- [ ] Rename crate in Cargo.toml
- [ ] Update all imports
- [ ] Update documentation
- [ ] Update CLAUDE.md / AGENTS.md
- [ ] Verify tests pass

---

### Phase 5: Runtime & Documentation Enhancements üìã FUTURE
Advanced features for splinter integration (optional future work).

---

#### **Part A: Configuration Structure Design**

**Goal:** Create a splinter configuration structure that mirrors linter but shares common code.

**Shared Components** (from `analyser/mod.rs`):
- `RuleConfiguration<T>` - Configuration wrapper with severity levels
- `RulePlainConfiguration` - Severity enum (Warn, Error, Info, Off)
- Merge/Deserialize traits

**New Splinter-Specific Types** (to generate in Phase 3):

```rust
// analyser/splinter/mod.rs
pub struct SplinterConfiguration {
    /// Enable/disable splinter linting
    pub enabled: bool,

    /// Splinter rules configuration
    pub rules: Rules,

    /// Ignore/include patterns (shared with linter)
    pub ignore: StringSet,
    pub include: StringSet,
}

// analyser/splinter/rules.rs (GENERATED)
pub enum RuleGroup {
    Performance,
    Security,
}

pub struct Rules {
    /// Enable recommended rules
    pub recommended: Option<bool>,

    /// Enable all rules
    pub all: Option<bool>,

    /// Performance group
    pub performance: Option<Performance>,

    /// Security group
    pub security: Option<Security>,
}

// Performance group (GENERATED)
pub struct Performance {
    pub recommended: Option<bool>,
    pub all: Option<bool>,

    // Individual rules - note: using RuleConfiguration<()> since no options
    pub unindexed_foreign_keys: Option<RuleConfiguration<()>>,
    pub auth_rls_initplan: Option<RuleConfiguration<()>>,
    pub duplicate_index: Option<RuleConfiguration<()>>,
    pub multiple_permissive_policies: Option<RuleConfiguration<()>>,
    pub no_primary_key: Option<RuleConfiguration<()>>,
    pub table_bloat: Option<RuleConfiguration<()>>,
    pub unused_index: Option<RuleConfiguration<()>>,
}

impl Performance {
    const GROUP_NAME: &'static str = "performance";
    const GROUP_RULES: &'static [&'static str] = &[
        "unindexedForeignKeys",
        "authRlsInitplan",
        // ... all 7 rules
    ];

    // Methods mirroring Safety group
    pub fn has_rule(rule_name: &str) -> Option<&'static str> { /* ... */ }
    pub fn severity(rule_name: &str) -> Severity { /* ... */ }
    pub fn all_rules_as_filters() -> impl Iterator<Item = RuleFilter<'static>> { /* ... */ }
    pub fn recommended_rules_as_filters() -> impl Iterator<Item = RuleFilter<'static>> { /* ... */ }
    pub fn collect_preset_rules(&self, ...) { /* ... */ }
    pub fn get_enabled_rules(&self) -> FxHashSet<RuleFilter<'static>> { /* ... */ }
    pub fn get_disabled_rules(&self) -> FxHashSet<RuleFilter<'static>> { /* ... */ }
}

// Security group (GENERATED) - same structure, 14 rules
pub struct Security { /* ... */ }
```

**Config File Example:**
```json
{
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "safety": {
        "addSerialColumn": "error"
      }
    }
  },
  "splinter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "performance": {
        "unindexedForeignKeys": "warn",
        "noPrimaryKey": "off"
      },
      "security": {
        "all": true,
        "authUsersExposed": "error"
      }
    }
  }
}
```

**Code Sharing Strategy:**
- ‚úÖ Reuse `RuleConfiguration<T>` with `T = ()` for splinter (no rule options)
- ‚úÖ Reuse severity conversion logic
- ‚úÖ Same `as_enabled_rules()` / `as_disabled_rules()` pattern
- ‚úÖ Same methods for each group (has_rule, severity, etc.)
- ‚ö†Ô∏è RuleGroup enum is separate (linter has Safety, splinter has Performance/Security)
- ‚ö†Ô∏è RuleSelector needs updating to handle both "lint/" and "splinter/" prefixes

---

#### **Part B: Dynamic SQL Query Building**

**Tasks:**
- [ ] Modify `run_splinter()` signature:
  ```rust
  pub async fn run_splinter(
      params: SplinterParams<'_>,
      filter: &AnalysisFilter,  // NEW
  ) -> Result<Vec<SplinterDiagnostic>, sqlx::Error>
  ```

- [ ] Use visitor pattern to collect enabled rules:
  ```rust
  struct SplinterRuleCollector<'a> {
      filter: &'a AnalysisFilter<'a>,
      enabled_rules: Vec<String>, // Rule names in camelCase
  }

  impl RegistryVisitor for SplinterRuleCollector<'_> {
      fn record_rule<R: RuleMeta>(&mut self) {
          if self.filter.match_rule::<R>() {
              self.enabled_rules.push(R::METADATA.name.to_string());
          }
      }
  }
  ```

- [ ] Build dynamic SQL query:
  ```rust
  let mut collector = SplinterRuleCollector { filter, enabled_rules: Vec::new() };
  crate::registry::visit_registry(&mut collector);

  // Map rule names to SQL file paths
  let mut sql_queries = Vec::new();
  for rule_name in &collector.enabled_rules {
      if let Some(sql_path) = crate::registry::get_sql_file_path(rule_name) {
          let sql = std::fs::read_to_string(sql_path)?;
          sql_queries.push(sql);
      }
  }

  // Combine with UNION ALL (only if enabled rules exist)
  if sql_queries.is_empty() {
      return Ok(Vec::new());
  }

  let combined_sql = sql_queries.join("\nUNION ALL\n");
  let results = sqlx::query_as::<_, SplinterQueryResult>(&combined_sql)
      .fetch_all(params.conn)
      .await?;
  ```

- [ ] Remove hardcoded functions:
  - Delete `load_generic_splinter_results()`
  - Delete `load_supabase_splinter_results()`
  - Remove `check_supabase_roles()` logic (rules are filtered by config)

- [ ] Update convert.rs:
  - Use generated category from `RuleMeta::METADATA.category` instead of `rule_name_to_category()`
  - Or better: get category from diagnostic category system

---

#### **Part C: Enhanced Documentation**

**Tasks:**
- [ ] Extract SQL queries into rule doc comments:
  ```rust
  // In generate_splinter.rs codegen
  let sql_content = std::fs::read_to_string(&sql_path)?;
  let sql_query = extract_sql_query(&sql_content)?; // Remove metadata comments

  let content = quote! {
      /// #title
      ///
      /// #description
      ///
      /// ## SQL Query
      ///
      /// ```sql
      /// #sql_query
      /// ```
      ///
      /// ## Remediation
      ///
      /// #remediation
      pub #struct_name { ... }
  };
  ```

- [ ] Add example SQL snippets showing what triggers the rule
- [ ] Update docs_codegen to process splinter rules
- [ ] Generate markdown documentation for website

---

#### **Benefits Summary:**

**Performance:**
- üöÄ Only execute SQL for enabled rules (vs. running all 21 rules)
- üöÄ Skip expensive queries when rules are disabled
- üöÄ Example: User disables 18/21 rules ‚Üí only 3 SQL queries execute

**Consistency:**
- ‚úÖ Same enable/disable mechanism as linter
- ‚úÖ Same configuration file structure
- ‚úÖ Same visitor pattern for rule discovery

**Maintainability:**
- ‚úÖ No hardcoded SQL queries in Rust
- ‚úÖ SQL files remain source of truth
- ‚úÖ Adding new rules = add SQL file + run codegen
- ‚úÖ No manual category mapping needed

**Documentation:**
- ‚úÖ Rule docs show actual SQL query
- ‚úÖ Better understanding of what each rule does
- ‚úÖ Easier to debug and customize

---

#### **Migration Path:**

**Phase 3** (Configuration Integration):
1. Generate splinter configuration types
2. Wire into config system
3. Users can enable/disable via config (but all enabled rules still run)

**Phase 5** (This Phase - Runtime Optimization):
1. Update `run_splinter()` to use filter
2. Build dynamic SQL queries
3. Performance benefit: only enabled rules execute

This allows incremental rollout - config works in Phase 3, optimization comes in Phase 5.

---

## Progress Tracking

### Current Status
- [x] Requirements gathering & design
- [x] Architecture proposal (Option C - Hybrid Approach)
- [x] Phase 1: Refactor pgls_analyse - **COMPLETED**
- [x] Phase 2: Enhance pgls_splinter - **COMPLETED**
- [ ] Phase 3: Integrate configuration - **NEXT**
- [ ] Phase 4: Rename to pgls_linter
- [ ] Phase 5: Runtime & Docs (FUTURE)

### Open Questions
None currently

### Decisions Made
1. Use `LinterRule` (not `ASTRule` or `SourceCodeRule`) for clarity
2. Use `SplinterRule` for database-level rules
3. Keep codegen in xtask (not build.rs) for consistency
4. Mirror file structure between linter and splinter

---

## Testing Strategy
- [ ] Existing linter tests continue to pass
- [ ] Splinter rules generate correctly from SQL
- [ ] Configuration schema validates
- [ ] Integration test: enable/disable rules via config
- [ ] Integration test: severity overrides work

---

Last updated: 2025-12-14
