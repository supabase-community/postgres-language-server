# Splinter Integration Plan

## Goal
Integrate splinter into the codegen/rule setup used for the analyser, providing a consistent API (both internally and user-facing) for all types of analysers/linters.

## Architecture Vision

### Crate Responsibilities

**`pgls_analyse`** - Generic framework for all analyzer types
- Generic traits: `RuleMeta`, `RuleGroup`, `GroupCategory`, `RegistryVisitor`
- Shared types: `RuleMetadata`, `RuleCategory`
- Configuration traits (execution-agnostic)
- Macros: `declare_rule!`, `declare_group!`, `declare_category!`

**`pgls_linter`** (renamed from `pgls_analyser`) - AST-based source code linting
- `LinterRule` trait (extends `RuleMeta`)
- `LinterRuleContext` (wraps AST nodes)
- `LinterDiagnostic` (span-based diagnostics)
- `LinterRuleRegistry` (type-erased executors)

**`pgls_splinter`** - Database-level linting
- `SplinterRule` trait (extends `RuleMeta`)
- `SplinterRuleRegistry` (metadata-based)
- `SplinterDiagnostic` (db-object-based diagnostics)
- Generated rule types from SQL files

**`pgls_configuration`**
- `analyser/linter/` - Generated from `pgls_linter`
- `analyser/splinter/` - Generated from `pgls_splinter`
- Per-rule configuration for both

## Implementation Phases

### Phase 1: Refactor pgls_analyse ‚úÖ COMPLETED
Extract AST-specific code into pgls_linter, keep only generic framework in pgls_analyse.

**Tasks:**
- [x] Analyze current `pgls_analyse` exports
- [x] Identify AST-specific vs generic code
- [x] Create new modules in `pgls_analyser`:
  - [x] `linter_rule.rs` - LinterRule trait, LinterDiagnostic
  - [x] `linter_context.rs` - LinterRuleContext, AnalysedFileContext
  - [x] `linter_options.rs` - LinterOptions, LinterRules
  - [x] `linter_registry.rs` - LinterRuleRegistry, LinterRegistryVisitor
- [x] Create `pgls_analyse/src/metadata.rs` - Generic traits only
- [x] Update `pgls_analyse/src/registry.rs` - Keep MetadataRegistry only
- [x] Update `pgls_analyse/src/lib.rs` - Export generic framework
- [x] Update `pgls_analyser/src/lib.rs` - Use new modules
- [x] Fix imports in filter.rs (RuleMeta instead of Rule)
- [x] Update generated files (options.rs, registry.rs)
- [x] Fix imports in all rule files
- [x] Add rustc-hash dependency
- [x] Verify compilation completes
- [x] Separate visitor concerns from executor creation
- [x] Update codegen to generate factory function
- [x] Fix all import paths across workspace
- [x] Verify full workspace compiles
- [x] Optimize executor creation (zero-cost abstraction)

**Resolution:**
Separated two concerns:
1. **Visitor pattern** (generic): Collects rule keys that match the filter
   - Implementation in `LinterRuleRegistryBuilder::record_rule`
   - Only requires `R: RuleMeta` (satisfies trait)
2. **Executor mapping** (AST-specific): Maps rule keys directly to executors
   - Function `get_linter_rule_executor` in `registry.rs`
   - Generated by codegen with full type information
   - Zero-cost abstraction: no Box, no dyn, no closures

**Final Implementation:**
- `LinterRuleRegistryBuilder` stores `Vec<RuleKey>` from visitor traversal
- `record_rule` only collects keys (generic, no LinterRule bounds)
- `build()` calls `get_linter_rule_executor` for each key
- Generated match statement returns executors directly (no heap allocation)

**Performance:**
- ‚úÖ No `Box<dyn FnOnce()>` - returns values directly
- ‚úÖ No closure overhead - simple match statement
- ‚úÖ No dynamic dispatch - static dispatch only
- ‚úÖ Clean codegen - 33 rules map to executors efficiently

**Design Decisions:**
- ‚úÖ Keep `RuleDiagnostic` generic or make it linter-specific? ‚Üí **Move to pgls_linter as LinterDiagnostic** (Option A)
  - Rationale: Fundamentally different location models (spans vs db objects)
  - LinterDiagnostic: span-based
  - SplinterDiagnostic: db-object-based

**Code Classification:**

AST-specific (move to pgls_analyser):
- `Rule` trait
- `RuleContext`
- `RuleDiagnostic` ‚Üí `LinterDiagnostic`
- `AnalysedFileContext`
- `RegistryRuleParams`
- `RuleRegistry`, `RuleRegistryBuilder` (AST execution)
- `AnalyserOptions`, `AnalyserRules` (rule options storage)

Generic (keep in pgls_analyse):
- `RuleMeta` trait
- `RuleMetadata` struct
- `RuleGroup` trait
- `GroupCategory` trait
- `RegistryVisitor` trait
- `RuleCategory` enum
- `RuleSource` enum
- `RuleFilter`, `AnalysisFilter`, `RuleKey`, `GroupKey`
- `MetadataRegistry`
- Macros: `declare_rule!`, `declare_lint_rule!`, `declare_lint_group!`, `declare_category!`

---

### Phase 2: Enhance pgls_splinter ‚úÖ COMPLETED
Add rule type generation and registry similar to linter.

**Tasks:**
- [x] Create `pgls_splinter/src/rule.rs` with `SplinterRule` trait
- [x] Create `pgls_splinter/src/rules/` directory structure
- [x] Generate rule types from SQL files
- [x] Generate registry with `visit_registry()` function
- [x] Split monolithic SQL files into individual rule files with metadata
- [x] Create codegen to extract metadata from SQL comments
- [x] Generate get_sql_file_path() function for SQL file mapping
- [ ] Update diagnostics to use generated categories (deferred)
- [ ] Update runtime to build dynamic queries (deferred to Phase 3)

**Structure:**
```
pgls_splinter/src/
  rules/
    performance/
      unindexed_foreign_keys.rs   # Generated
      auth_rls_initplan.rs        # Generated
      ...                          # 7 total
      mod.rs                       # Generated group
    security/
      auth_users_exposed.rs        # Generated
      ...                          # 14 total
      mod.rs                       # Generated group
    mod.rs                         # Generated category
  rule.rs                          # Generated SplinterRule trait
  registry.rs                      # Generated visit_registry() + get_sql_file_path()

pgls_splinter/vendor/
  performance/
    *.sql                          # 7 individual SQL files with metadata
  security/
    *.sql                          # 14 individual SQL files with metadata
```

**Implementation Summary:**
- Implemented Option C (Hybrid Approach) from initial analysis
- SQL files remain source of truth with metadata comments
- Codegen extracts metadata and generates Rust structures
- `SplinterRule` trait extends `RuleMeta` with `sql_file_path()` method
- Registry provides centralized rule discovery via visitor pattern
- Category structure: `Splinter` (Lint) ‚Üí `Performance`/`Security` (groups) ‚Üí individual rules
- Successfully compiles without errors

---

### Phase 3: Configuration Integration ‚úÖ COMPLETED
Integrate splinter into the configuration system.

**Tasks:**
- [x] **Configuration Generation**:
  - [x] Create `pgls_configuration/src/analyser/splinter/` directory
  - [x] Generate splinter configuration types (Performance/Security groups, Rules struct)
  - [x] Update `generate_configuration.rs` to visit splinter registry
  - [x] Add `SplinterRulesVisitor` for rule collection
  - [x] Generate `crates/pgls_configuration/src/analyser/splinter/rules.rs` with:
    - [x] `RuleGroup` enum (Performance, Security)
    - [x] `Rules` struct with recommended/all/group fields
    - [x] `Performance` struct with 7 rules (using `RuleConfiguration<()>`)
    - [x] `Security` struct with 14 rules (using `RuleConfiguration<()>`)
    - [x] All helper methods (has_rule, severity, get_enabled_rules, etc.)
  - [x] Generate `crates/pgls_configuration/src/generated/splinter.rs` with `push_to_analyser_splinter()`
  - [x] Update `analyser/mod.rs` to export splinter config
  - [x] Fix imports: use `pgls_analyser::RuleOptions` instead of `pgls_analyse::options::RuleOptions`
  - [x] Fix type references: use `LinterRules` instead of `AnalyserRules`
  - [x] Run `just gen-lint` successfully
  - [x] Verify full workspace compiles

- [ ] **Documentation Enhancement** (PHASE 5):
  - [ ] Add SQL query examples to splinter rule docs
  - [ ] Extract SQL from vendor/*.sql files into doc comments
  - [ ] Add usage examples and remediation steps
  - [ ] Generate rule documentation via docs_codegen

- [x] **Runtime Integration** (PHASE 5 - COMPLETED):
  - [x] Update `run_splinter()` to use visitor pattern with AnalysisFilter
  - [x] Build dynamic SQL queries from enabled rules only
  - [x] Remove hardcoded SQL query execution (removed load_generic/load_supabase functions)
  - [ ] Remove hardcoded category mapping in convert.rs (DEFERRED - requires codegen improvements)
  - [ ] Add splinter to RuleSelector enum (DEFERRED - requires design decisions for multi-analyzer support)

**Codegen Outputs After Phase 3:**
```
Linter:
  - crates/pgls_analyser/src/registry.rs (generated - ‚úÖ DONE)
  - crates/pgls_analyser/src/options.rs (generated - ‚úÖ DONE)
  - crates/pgls_configuration/src/analyser/linter/rules.rs (generated - ‚úÖ DONE)
  - crates/pgls_configuration/src/generated/linter.rs (generated - ‚úÖ DONE)

Splinter:
  - crates/pgls_splinter/src/rules/ (generated - ‚úÖ DONE)
  - crates/pgls_splinter/src/rule.rs (generated - ‚úÖ DONE)
  - crates/pgls_splinter/src/registry.rs (generated - ‚úÖ DONE)
  - crates/pgls_configuration/src/analyser/splinter/mod.rs (created - ‚úÖ DONE)
  - crates/pgls_configuration/src/analyser/splinter/rules.rs (generated - ‚úÖ DONE)
  - crates/pgls_configuration/src/generated/splinter.rs (generated - ‚úÖ DONE)
```

**Implementation Details:**
- Configuration structure mirrors linter configuration for consistency
- Splinter rules use `RuleConfiguration<()>` since they have no rule-specific options
- All 21 rules (7 performance + 14 security) are properly configured with severities from SQL metadata
- Category name in `get_severity_from_code()` correctly uses "splinter" prefix
- No recommended rules by default (RECOMMENDED_RULES_AS_FILTERS is empty)

**Config File Example:**
```json
{
  "splinter": {
    "enabled": true,
    "rules": {
      "all": true,
      "performance": {
        "unindexedForeignKeys": "warn",
        "noPrimaryKey": "off"
      },
      "security": {
        "authUsersExposed": "error"
      }
    }
  }
}
```

**Notes:**
- ‚úÖ Configuration generation is complete and tested
- ‚úÖ Runtime integration (dynamic SQL query building) completed in Phase 5
- üìã Documentation enhancement with SQL examples planned for Phase 5 (Part C)
- üìã RuleSelector integration deferred (requires design for multi-analyzer support)
- üìã Category mapping in convert.rs still hardcoded (can be improved with codegen)

---

### Phase 4: Rename pgls_analyser ‚Üí pgls_linter üìã PLANNED
Final rename to clarify purpose.

**Tasks:**
- [ ] Rename crate in Cargo.toml
- [ ] Update all imports
- [ ] Update documentation
- [ ] Update CLAUDE.md / AGENTS.md
- [ ] Verify tests pass

---

### Phase 5: Runtime & Documentation Enhancements ‚úÖ COMPLETED
Advanced features for splinter integration.

**Part B: Dynamic SQL Query Building** ‚úÖ
**Part C: Enhanced Documentation** ‚úÖ
**Deferred Items: All Completed** ‚úÖ

**Implementation Summary (Part B):**

The runtime integration has been completed with the following changes:

1. **Updated `run_splinter()` signature** (`crates/pgls_splinter/src/lib.rs`):
   - Now accepts `filter: &AnalysisFilter<'_>` parameter
   - Uses visitor pattern to collect enabled rules based on filter
   - Returns early if no rules are enabled (performance optimization)

2. **Implemented `SplinterRuleCollector` visitor**:
   - Properly implements all RegistryVisitor methods (record_category, record_group, record_rule)
   - Filters at each level (category, group, rule) for efficiency
   - Collects rule names (camelCase) for enabled rules only

3. **Dynamic SQL query building**:
   - Reads individual SQL files from `vendor/` directory based on enabled rules
   - Uses `crate::registry::get_sql_file_path()` to map rule names to SQL file paths
   - Combines multiple SQL queries with `UNION ALL`
   - Only executes SQL for enabled rules (major performance improvement)

4. **Removed hardcoded functions**:
   - Deleted `load_generic_splinter_results()`
   - Deleted `load_supabase_splinter_results()`
   - Removed Supabase role checking logic (rules are now filtered by configuration)

5. **Updated test call sites**:
   - All tests now pass `AnalysisFilter::default()` to enable all rules
   - Maintains backward compatibility for test behavior

6. **Added manual `FromRow` implementation**:
   - `SplinterQueryResult` now implements `FromRow` manually (was using compile-time macro)
   - Enables dynamic SQL execution while maintaining type safety

**Performance Benefits:**
- üöÄ Only enabled rules execute SQL queries
- üöÄ Can disable expensive rules individually via configuration
- üöÄ Example: Disabling 18/21 rules means only 3 SQL queries execute instead of all 21

**Deferred Items (Now Completed):**
- ‚úÖ Category mapping in `convert.rs` - **COMPLETED**
  - Generated `get_rule_category()` function in `registry.rs` via codegen
  - Replaced 120-line match statement with single function call
  - Maps snake_case SQL result names to static Category references
- ‚úÖ RuleSelector enum multi-analyzer support - **COMPLETED**
  - Added splinter-specific variants: `SplinterGroup`, `SplinterRule`
  - Implemented prefix-based parsing (`lint/`, `splinter/`)
  - Maintains backward compatibility (tries linter first)
- ‚úÖ Supabase role checking - **COMPLETED**
  - Added `requires_supabase` metadata to SQL files
  - Generated `rule_requires_supabase()` function
  - Implemented in-memory role checking via `SchemaCache`
  - Automatically filters Supabase rules when roles don't exist
  - Zero configuration needed from users
- ‚úÖ Documentation enhancement (Part C) - **COMPLETED**

---

#### **Part A: Configuration Structure Design**

**Goal:** Create a splinter configuration structure that mirrors linter but shares common code.

**Shared Components** (from `analyser/mod.rs`):
- `RuleConfiguration<T>` - Configuration wrapper with severity levels
- `RulePlainConfiguration` - Severity enum (Warn, Error, Info, Off)
- Merge/Deserialize traits

**New Splinter-Specific Types** (to generate in Phase 3):

```rust
// analyser/splinter/mod.rs
pub struct SplinterConfiguration {
    /// Enable/disable splinter linting
    pub enabled: bool,

    /// Splinter rules configuration
    pub rules: Rules,

    /// Ignore/include patterns (shared with linter)
    pub ignore: StringSet,
    pub include: StringSet,
}

// analyser/splinter/rules.rs (GENERATED)
pub enum RuleGroup {
    Performance,
    Security,
}

pub struct Rules {
    /// Enable recommended rules
    pub recommended: Option<bool>,

    /// Enable all rules
    pub all: Option<bool>,

    /// Performance group
    pub performance: Option<Performance>,

    /// Security group
    pub security: Option<Security>,
}

// Performance group (GENERATED)
pub struct Performance {
    pub recommended: Option<bool>,
    pub all: Option<bool>,

    // Individual rules - note: using RuleConfiguration<()> since no options
    pub unindexed_foreign_keys: Option<RuleConfiguration<()>>,
    pub auth_rls_initplan: Option<RuleConfiguration<()>>,
    pub duplicate_index: Option<RuleConfiguration<()>>,
    pub multiple_permissive_policies: Option<RuleConfiguration<()>>,
    pub no_primary_key: Option<RuleConfiguration<()>>,
    pub table_bloat: Option<RuleConfiguration<()>>,
    pub unused_index: Option<RuleConfiguration<()>>,
}

impl Performance {
    const GROUP_NAME: &'static str = "performance";
    const GROUP_RULES: &'static [&'static str] = &[
        "unindexedForeignKeys",
        "authRlsInitplan",
        // ... all 7 rules
    ];

    // Methods mirroring Safety group
    pub fn has_rule(rule_name: &str) -> Option<&'static str> { /* ... */ }
    pub fn severity(rule_name: &str) -> Severity { /* ... */ }
    pub fn all_rules_as_filters() -> impl Iterator<Item = RuleFilter<'static>> { /* ... */ }
    pub fn recommended_rules_as_filters() -> impl Iterator<Item = RuleFilter<'static>> { /* ... */ }
    pub fn collect_preset_rules(&self, ...) { /* ... */ }
    pub fn get_enabled_rules(&self) -> FxHashSet<RuleFilter<'static>> { /* ... */ }
    pub fn get_disabled_rules(&self) -> FxHashSet<RuleFilter<'static>> { /* ... */ }
}

// Security group (GENERATED) - same structure, 14 rules
pub struct Security { /* ... */ }
```

**Config File Example:**
```json
{
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "safety": {
        "addSerialColumn": "error"
      }
    }
  },
  "splinter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "performance": {
        "unindexedForeignKeys": "warn",
        "noPrimaryKey": "off"
      },
      "security": {
        "all": true,
        "authUsersExposed": "error"
      }
    }
  }
}
```

**Code Sharing Strategy:**
- ‚úÖ Reuse `RuleConfiguration<T>` with `T = ()` for splinter (no rule options)
- ‚úÖ Reuse severity conversion logic
- ‚úÖ Same `as_enabled_rules()` / `as_disabled_rules()` pattern
- ‚úÖ Same methods for each group (has_rule, severity, etc.)
- ‚ö†Ô∏è RuleGroup enum is separate (linter has Safety, splinter has Performance/Security)
- ‚ö†Ô∏è RuleSelector needs updating to handle both "lint/" and "splinter/" prefixes

---

#### **Part B: Dynamic SQL Query Building**

**Tasks:**
- [ ] Modify `run_splinter()` signature:
  ```rust
  pub async fn run_splinter(
      params: SplinterParams<'_>,
      filter: &AnalysisFilter,  // NEW
  ) -> Result<Vec<SplinterDiagnostic>, sqlx::Error>
  ```

- [ ] Use visitor pattern to collect enabled rules:
  ```rust
  struct SplinterRuleCollector<'a> {
      filter: &'a AnalysisFilter<'a>,
      enabled_rules: Vec<String>, // Rule names in camelCase
  }

  impl RegistryVisitor for SplinterRuleCollector<'_> {
      fn record_rule<R: RuleMeta>(&mut self) {
          if self.filter.match_rule::<R>() {
              self.enabled_rules.push(R::METADATA.name.to_string());
          }
      }
  }
  ```

- [ ] Build dynamic SQL query:
  ```rust
  let mut collector = SplinterRuleCollector { filter, enabled_rules: Vec::new() };
  crate::registry::visit_registry(&mut collector);

  // Map rule names to SQL file paths
  let mut sql_queries = Vec::new();
  for rule_name in &collector.enabled_rules {
      if let Some(sql_path) = crate::registry::get_sql_file_path(rule_name) {
          let sql = std::fs::read_to_string(sql_path)?;
          sql_queries.push(sql);
      }
  }

  // Combine with UNION ALL (only if enabled rules exist)
  if sql_queries.is_empty() {
      return Ok(Vec::new());
  }

  let combined_sql = sql_queries.join("\nUNION ALL\n");
  let results = sqlx::query_as::<_, SplinterQueryResult>(&combined_sql)
      .fetch_all(params.conn)
      .await?;
  ```

- [ ] Remove hardcoded functions:
  - Delete `load_generic_splinter_results()`
  - Delete `load_supabase_splinter_results()`
  - Remove `check_supabase_roles()` logic (rules are filtered by config)

- [ ] Update convert.rs:
  - Use generated category from `RuleMeta::METADATA.category` instead of `rule_name_to_category()`
  - Or better: get category from diagnostic category system

---

#### **Part C: Enhanced Documentation** ‚úÖ

**Status:** COMPLETED

**Tasks:**
- [x] Extract SQL queries into rule doc comments
- [x] Add configuration examples to documentation
- [x] Include Supabase requirement warnings
- [x] Link to remediation documentation
- [x] Generate comprehensive doc strings via codegen

**Implementation:**

The codegen (`xtask/codegen/src/generate_splinter.rs`) now generates rich documentation for all splinter rules:

1. **Added `sql_query` field to `SqlRuleMetadata`:**
   - Extracts SQL content after metadata comment headers
   - Preserves formatting for readability
   - Strips metadata lines (`-- meta:` prefix)

2. **Generated comprehensive doc strings** including:
   - **Title and description** from SQL metadata
   - **Supabase requirement note** (conditional):
     ```
     **Note:** This rule requires Supabase roles (`anon`, `authenticated`, `service_role`).
     It will be automatically skipped if these roles don't exist in your database.
     ```
   - **Full SQL query** in code fence with `/// ` prefix on each line
   - **Configuration JSON example** showing how to enable/disable:
     ```json
     {
       "splinter": {
         "rules": {
           "security": {
             "authUsersExposed": "warn"
           }
         }
       }
     }
     ```
   - **Remediation link** to Supabase docs or custom guidance

3. **Generated documentation visible via `cargo doc`:**
   - All 21 rules now have comprehensive documentation
   - Developers can view SQL queries directly in IDE
   - Easy to understand what each rule checks

**Example Generated Documentation:**
```rust
#[doc = "/// # Unindexed foreign keys\n///\n/// Identifies foreign key constraints without a covering index, which can impact database performance.\n///\n/// ## SQL Query\n///\n/// ```sql\n/// with foreign_keys as (\n///     select\n///         cl.relnamespace::regnamespace::text as schema_name,\n/// ... [full SQL query]\n/// ```\n///\n/// ## Configuration\n///\n/// Enable or disable this rule in your configuration:\n///\n/// ```json\n/// {\n///   \"splinter\": {\n///     \"rules\": {\n///       \"performance\": {\n///         \"unindexedForeignKeys\": \"warn\"\n///       }\n///     }\n///   }\n/// }\n/// ```\n///\n/// ## Remediation\n///\n/// See: <https://supabase.com/docs/guides/database/database-linter?lint=0001_unindexed_foreign_keys>"]
pub UnindexedForeignKeys { ... }
```

**Files Updated:**
- `xtask/codegen/src/generate_splinter.rs` - Enhanced documentation generation
- All 21 rule files in `crates/pgls_splinter/src/rules/` - Regenerated with rich docs

---

#### **Benefits Summary:**

**Performance:**
- üöÄ Only execute SQL for enabled rules (vs. running all 21 rules)
- üöÄ Skip expensive queries when rules are disabled
- üöÄ Example: User disables 18/21 rules ‚Üí only 3 SQL queries execute

**Consistency:**
- ‚úÖ Same enable/disable mechanism as linter
- ‚úÖ Same configuration file structure
- ‚úÖ Same visitor pattern for rule discovery

**Maintainability:**
- ‚úÖ No hardcoded SQL queries in Rust
- ‚úÖ SQL files remain source of truth
- ‚úÖ Adding new rules = add SQL file + run codegen
- ‚úÖ No manual category mapping needed

**Documentation:**
- ‚úÖ Rule docs show actual SQL query
- ‚úÖ Better understanding of what each rule does
- ‚úÖ Easier to debug and customize

---

#### **Migration Path:**

**Phase 3** (Configuration Integration):
1. Generate splinter configuration types
2. Wire into config system
3. Users can enable/disable via config (but all enabled rules still run)

**Phase 5** (This Phase - Runtime Optimization):
1. Update `run_splinter()` to use filter
2. Build dynamic SQL queries
3. Performance benefit: only enabled rules execute

This allows incremental rollout - config works in Phase 3, optimization comes in Phase 5.

---

## Progress Tracking

### Current Status
- [x] Requirements gathering & design
- [x] Architecture proposal (Option C - Hybrid Approach)
- [x] Phase 1: Refactor pgls_analyse - **COMPLETED**
- [x] Phase 2: Enhance pgls_splinter - **COMPLETED**
- [x] Phase 3: Configuration Integration - **COMPLETED**
- [x] Phase 5 Part B: Runtime Integration - **COMPLETED**
- [x] Phase 5 Part C: Documentation Enhancement - **COMPLETED**
- [x] Phase 5 Deferred Items: Category mapping, RuleSelector, Supabase roles - **COMPLETED**
- [ ] Phase 4: Rename to pgls_linter - **PLANNED**

### Summary
**‚úÖ Integration Complete (Phases 1-5):**
- Generic framework (`pgls_analyse`) successfully extracted
- Splinter rules generated from SQL files with metadata
- Configuration system mirrors linter structure
- All 21 splinter rules (7 performance + 14 security) properly configured
- Dynamic SQL query building with configuration-based filtering
- Hardcoded category mapping replaced with generated functions
- RuleSelector supports both linter and splinter prefixes
- Automatic Supabase role detection via schema cache
- Comprehensive documentation generated with SQL queries and examples
- Full workspace compiles successfully

**üìã Remaining Work:**
- Phase 4: Crate rename `pgls_analyser` ‚Üí `pgls_linter` (planned)

### Open Questions
None currently

### Decisions Made
1. Use `LinterRule` (not `ASTRule` or `SourceCodeRule`) for clarity
2. Use `SplinterRule` for database-level rules
3. Keep codegen in xtask (not build.rs) for consistency
4. Mirror file structure between linter and splinter

---

## Testing Strategy
- [x] Full workspace compiles successfully
- [x] Splinter rules generate correctly from SQL
- [x] Configuration generation runs without errors
- [ ] Existing linter tests continue to pass (not verified)
- [ ] Configuration schema validates (not verified)
- [ ] Integration test: enable/disable rules via config (requires runtime integration)
- [ ] Integration test: severity overrides work (requires runtime integration)

**Status:** Basic compilation testing complete. Full integration testing deferred to when runtime integration is implemented.

---

Last updated: 2025-12-15

## Phase 5 Part B Implementation Notes

**Date Completed:** 2025-12-15

**Changes Made:**

1. **File: `crates/pgls_splinter/src/lib.rs`**
   - Added `SplinterRuleCollector` struct implementing `RegistryVisitor`
   - Updated `run_splinter()` to accept `AnalysisFilter` parameter
   - Implemented dynamic SQL query building from enabled rules
   - Removed dependency on hardcoded `load_generic/load_supabase` functions

2. **File: `crates/pgls_splinter/src/query.rs`**
   - Added manual `FromRow` implementation for `SplinterQueryResult`
   - Removed `load_generic_splinter_results()` function
   - Removed `load_supabase_splinter_results()` function
   - Added note explaining the removal

3. **File: `crates/pgls_splinter/tests/diagnostics.rs`**
   - Updated all test call sites to pass `AnalysisFilter::default()`
   - Added import for `pgls_analyse::AnalysisFilter`

**Testing:**
- Full workspace compiles successfully: ‚úÖ
- `cargo check -p pgls_splinter` passes with only generated code warnings: ‚úÖ
- No functional regressions expected (behavior is equivalent but more efficient)

**Migration Notes for Users:**
- Any code calling `run_splinter()` must now pass an `AnalysisFilter`
- For "run all rules" behavior, use `AnalysisFilter::default()`
- Tests updated to demonstrate correct usage

---

## Phase 5 Deferred Items - Implementation Notes

**Date Completed:** 2025-12-15

### 1. Category Mapping Removal

**Problem:** `convert.rs` contained a 120-line hardcoded `rule_name_to_category()` function mapping rule names to categories.

**Solution:**
- Extended codegen to generate `get_rule_category()` function in `registry.rs`
- Maps snake_case SQL result names (e.g., "unindexed_foreign_keys") to static Category references
- Automatically stays in sync with SQL file metadata

**Files Changed:**
- `xtask/codegen/src/generate_splinter.rs` - Added category lookup generation
- `crates/pgls_splinter/src/registry.rs` - Generated function (auto-generated)
- `crates/pgls_splinter/src/convert.rs` - Replaced match statement with single function call

**Example:**
```rust
// Before: 120 lines of match statements
fn rule_name_to_category(name: &str, group: &str) -> &'static Category {
    match (group, name) {
        ("performance", "unindexed_foreign_keys") => category!("splinter/performance/unindexedForeignKeys"),
        // ... 60+ more lines
    }
}

// After: Single function call
let category = crate::registry::get_rule_category(&result.name)
    .expect("Rule name should map to a valid category");
```

---

### 2. RuleSelector Multi-Analyzer Support

**Problem:** `RuleSelector` enum only supported linter rules (groups: Safety).

**Solution:**
- Split enum variants into analyzer-specific types:
  - `LinterGroup` / `LinterRule` for linter rules
  - `SplinterGroup` / `SplinterRule` for splinter rules
- Added prefix-based parsing (`lint/`, `splinter/`)
- Maintained backward compatibility (unprefixed selectors try linter first)

**Files Changed:**
- `crates/pgls_configuration/src/analyser/mod.rs` - Updated RuleSelector enum and parsing

**Example Configuration:**
```json
{
  "linter": {
    "ignore": ["lint/safety/banDropTable"]  // Linter rule with prefix
  },
  "overrides": [
    {
      "ignore": [
        "splinter/security/authUsersExposed",  // Splinter rule with prefix
        "multipleAlterTable"                    // Linter rule (backward compatible)
      ]
    }
  ]
}
```

---

### 3. Supabase Role Checking

**Problem:** Supabase-specific rules (9 out of 21) should automatically be skipped on non-Supabase databases without requiring configuration changes.

**Solution:**
- Added `-- meta: requires_supabase = true` to 9 SQL files
- Generated `rule_requires_supabase()` function in `registry.rs`
- Updated `SplinterParams` to accept optional `SchemaCache`
- Implemented in-memory role checking (looks for `anon`, `authenticated`, `service_role` roles)
- Filters rules before building SQL query (performance optimization)

**Files Changed:**
- 9 SQL files in `crates/pgls_splinter/vendor/` - Added metadata
- `xtask/codegen/src/generate_splinter.rs` - Extract and generate metadata
- `crates/pgls_splinter/src/lib.rs` - Added role checking logic
- `crates/pgls_splinter/Cargo.toml` - Added `pgls_schema_cache` dependency

**Example:**
```rust
// Check if Supabase roles exist
let has_supabase_roles = params.schema_cache.map_or(false, |cache| {
    let required_roles = ["anon", "authenticated", "service_role"];
    required_roles.iter().all(|role_name| {
        cache.roles.iter().any(|role| role.name.as_str() == *role_name)
    })
});

// Skip Supabase-specific rules if roles don't exist
for rule_name in &collector.enabled_rules {
    if !has_supabase_roles && crate::registry::rule_requires_supabase(rule_name) {
        continue;  // Automatically skipped - zero config needed!
    }
    // ... load and execute SQL
}
```

**Supabase-Specific Rules:**
1. `authRlsInitplan` (performance)
2. `authUsersExposed` (security)
3. `fkeyToAuthUnique` (security)
4. `foreignTableInApi` (security)
5. `insecureQueueExposedInApi` (security)
6. `materializedViewInApi` (security)
7. `rlsDisabledInPublic` (security)
8. `rlsReferencesUserMetadata` (security)
9. `securityDefinerView` (security)

---

## Phase 5 Part C - Implementation Notes

**Date Completed:** 2025-12-15

### Documentation Enhancement

**Goal:** Generate comprehensive documentation for all splinter rules, including SQL queries, configuration examples, and remediation links.

**Implementation:**

1. **Extended `SqlRuleMetadata` struct:**
   - Added `sql_query: String` field
   - Added `requires_supabase: bool` field
   - Extracts SQL content after metadata comment headers
   - Preserves formatting and removes metadata lines

2. **Generated comprehensive doc strings:**
   - Built using `format!` macro with multiple sections
   - Includes title, description, Supabase warning, SQL query, configuration example, and remediation link
   - Each line prefixed with `/// ` for Rust doc comments
   - SQL query wrapped in triple-backtick code fence

3. **Documentation Sections:**
   - **Title and Description**: From SQL metadata
   - **Supabase Note** (conditional): Warns about role requirements
   - **SQL Query**: Full query in code fence with syntax highlighting
   - **Configuration**: JSON example showing how to enable/disable
   - **Remediation**: Link to documentation or custom guidance

**Files Changed:**
- `xtask/codegen/src/generate_splinter.rs` - Added doc string generation
- All 21 rule files in `crates/pgls_splinter/src/rules/` - Regenerated with rich docs

**Example Output:**
```rust
/// # Unindexed foreign keys
///
/// Identifies foreign key constraints without a covering index, which can impact database performance.
///
/// ## SQL Query
///
/// ```sql
/// with foreign_keys as (
///     select
///         cl.relnamespace::regnamespace::text as schema_name,
///         cl.relname as table_name,
///         ...
/// )
/// select * from foreign_keys where ...
/// ```
///
/// ## Configuration
///
/// Enable or disable this rule in your configuration:
///
/// ```json
/// {
///   "splinter": {
///     "rules": {
///       "performance": {
///         "unindexedForeignKeys": "warn"
///       }
///     }
///   }
/// }
/// ```
///
/// ## Remediation
///
/// See: <https://supabase.com/docs/guides/database/database-linter?lint=0001_unindexed_foreign_keys>
pub struct UnindexedForeignKeys { ... }
```

**Benefits:**
- ‚úÖ Developers can view SQL queries directly in IDE via hover/goto-definition
- ‚úÖ `cargo doc` generates comprehensive documentation
- ‚úÖ Easy to understand what each rule checks without reading SQL files
- ‚úÖ Configuration examples reduce setup friction
- ‚úÖ Remediation links provide actionable next steps

---

**Overall Phase 5 Status:** ‚úÖ FULLY COMPLETED

All planned work and deferred items have been successfully implemented:
- Dynamic SQL query building with configuration filtering
- Hardcoded category mapping replaced with generated functions
- Multi-analyzer RuleSelector support
- Automatic Supabase role detection
- Comprehensive documentation generation

Full workspace compiles successfully with no errors.
