---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/namespace.sql
---
select set_config('search_path', ' ', false);

create schema "test_ns_schema_1";

create unique index "abc_a_idx" on abc using btree (a);

create view abc_view
as select a + 1 as a, b + 1 as b from abc;

create table abc (
  a serial,
  b int unique
);

set search_path to public;

begin;

set search_path to public, test_ns_schema_1;

create schema "test_ns_schema_2";

create view abc_view
as select c from abc;

commit;

show "search_path";

begin;

set search_path to public, test_ns_schema_1;

create schema "test_ns_schema_2";

create view abc_view
as select a from abc;

show "search_path";

commit;

show "search_path";

drop schema test_ns_schema_2 cascade;

select
  COUNT(*)
from
  pg_class
where
  relnamespace =
  (
    select
      oid
    from
      pg_namespace
    where
      nspname = 'test_ns_schema_1'
  );

insert into test_ns_schema_1.abc default values;

insert into test_ns_schema_1.abc default values;

insert into test_ns_schema_1.abc default values;

select * from test_ns_schema_1.abc;

select * from test_ns_schema_1.abc_view;

alter schema test_ns_schema_1 rename to test_ns_schema_renamed;

select
  COUNT(*)
from
  pg_class
where
  relnamespace =
  (
    select
      oid
    from
      pg_namespace
    where
      nspname = 'test_ns_schema_1'
  );

create schema "test_ns_schema_renamed";

create schema if not exists "test_ns_schema_renamed";

create schema if not exists "test_ns_schema_renamed";

create table abc (
  a serial,
  b int unique
);

drop schema test_ns_schema_renamed cascade;

select
  COUNT(*)
from
  pg_class
where
  relnamespace =
  (
    select
      oid
    from
      pg_namespace
    where
      nspname = 'test_ns_schema_renamed'
  );

create schema "test_maint_search_path";

set search_path to test_maint_search_path;

create function fn(int)
returns int
language plpgsql
immutable
as $function$
BEGIN
    RAISE NOTICE 'current search_path: %', current_setting('search_path');
    RETURN $1;
  END;
$function$;

create table test_maint (i int);

insert into test_maint values (1), (2);

create materialized view test_maint_mv as select fn(i) from test_maint;

create index "test_maint_idx" on test_maint_search_path.test_maint using btree ((fn(i)));

reindex table test_maint_search_path.test_maint;

analyze test_maint_search_path.test_maint;

vacuum (FULL) test_maint_search_path.test_maint;

cluster test_maint_search_path.test_maint using test_maint_idx;

refresh materialized view test_maint_search_path.test_maint_mv;

reset search_path;

drop schema test_maint_search_path cascade;
