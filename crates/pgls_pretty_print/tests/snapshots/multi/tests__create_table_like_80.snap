---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/create_table_like.sql
snapshot_kind: text
---
create table inhx (xx TEXT default 'text');

create table ctla (aa TEXT);

create table ctlb (bb TEXT)
inherits (ctla);

create table foo (like nonexistent);

create table inhe (
  ee TEXT,
  like inhx
)
inherits (ctlb);

insert into inhe values ('ee-col1', 'ee-col2', default, 'ee-col4');

select * from inhe;

select * from inhx;

select * from ctlb;

select * from ctla;

create table inhf (
  like inhx,
  like inhx
);

create table inhf (like inhx including CONSTRAINTS including DEFAULTS);

insert into inhf default values;

select * from inhf;

alter table inhx
  add constraint "foo" check (xx = 'text');

alter table inhx
  add primary key (xx);

create table inhg (like inhx);

insert into inhg values ('foo');

drop TABLE "inhg";

create table inhg (
  x TEXT,
  like inhx including CONSTRAINTS,
  y TEXT
);

insert into inhg values ('x', 'text', 'y');

insert into inhg values ('x', 'text', 'y');

insert into inhg values ('x', 'foo', 'y');

select * from inhg;

drop TABLE "inhg";

create table test_like_id_1 (
  a BIGINT generated always as identity,
  b TEXT
);

insert into test_like_id_1 (b) values ('b1');

select * from test_like_id_1;

create table test_like_id_2 (like test_like_id_1);

insert into test_like_id_2 (b) values ('b2');

select * from test_like_id_2;

create table test_like_id_3 (like test_like_id_1 including IDENTITY);

insert into test_like_id_3 (b) values ('b3');

select * from test_like_id_3;

drop TABLE "test_like_id_1", "test_like_id_2", "test_like_id_3";

insert into test_like_gen_1 (a) values (1);

select * from test_like_gen_1;

create table test_like_gen_2 (like test_like_gen_1);

insert into test_like_gen_2 (a) values (1);

select * from test_like_gen_2;

create table test_like_gen_3 (like test_like_gen_1 including GENERATED);

insert into test_like_gen_3 (a) values (1);

select * from test_like_gen_3;

drop TABLE "test_like_gen_1", "test_like_gen_2", "test_like_gen_3";

create table test_like_4 (
  b INT default 42,
  c INT generated always as (a * 2) stored,
  a INT check (a > 0)
);

create table test_like_4a (like test_like_4);

create table test_like_4b (like test_like_4 including DEFAULTS);

create table test_like_4c (like test_like_4 including GENERATED);

create table test_like_4d (
  like test_like_4
  including DEFAULTS
  including GENERATED
);

insert into test_like_4a (a) values (11);

select a, b, c from test_like_4a;

insert into test_like_4b (a) values (11);

select a, b, c from test_like_4b;

insert into test_like_4c (a) values (11);

select a, b, c from test_like_4c;

insert into test_like_4d (a) values (11);

select a, b, c from test_like_4d;

create table test_like_5 (
  x point,
  y point,
  z point
);

create table test_like_5x (
  p INT check (p > 0),
  q INT generated always as (p * 2) stored
);

create table test_like_5c (like test_like_4 including all)
inherits (test_like_5,
test_like_5x);

create table test_like_6 (
  a INT,
  c TEXT,
  b TEXT
);

create STATISTICS ext_stat on (a || b) from test_like_6;

alter table test_like_6
  drop column c;

create table test_like_6c (like test_like_6 including all);

drop TABLE
  "test_like_4",
  "test_like_4a",
  "test_like_4b",
  "test_like_4c",
  "test_like_4d";

drop TABLE "test_like_5", "test_like_5x", "test_like_5c";

drop TABLE "test_like_6", "test_like_6c";

create table inhg (
  x TEXT,
  like inhx including INDEXES,
  y TEXT
);

insert into inhg values (5, 10);

insert into inhg values (20, 10);

drop TABLE "inhg";

create table inhg (
  x TEXT,
  like inhx including INDEXES,
  primary key (x)
);

create table inhz (
  xx TEXT default 'text',
  yy INT unique
);

create unique index "inhz_xx_idx"
on inhz
using btree
(
  xx
)
where
  xx <> 'test';

create table inhg (
  x TEXT unique,
  like inhz including INDEXES
);

insert into inhg (xx, yy, x) values ('test', 5, 10);

insert into inhg (xx, yy, x) values ('test', 10, 15);

insert into inhg (xx, yy, x) values ('foo', 10, 15);

drop TABLE "inhg";

drop TABLE "inhz";

create table inhz (
  x TEXT references inhz,
  like inhx including INDEXES
);

drop TABLE "inhz";

alter table ctlt1
  add constraint "cc" check (length(b) > 100) not valid;

create index "ctlt1_b_key" on ctlt1 using btree (b);

create index "ctlt1_fnidx" on ctlt1 using btree ((a || b));

create STATISTICS ctlt1_a_b_stat on "a", "b" from ctlt1;

create STATISTICS ctlt1_expr_stat on (a || b) from ctlt1;

comment on statistics ctlt1_a_b_stat is 'ab stats';

comment on statistics ctlt1_expr_stat is 'ab expr stats';

comment on column ctlt1.a is 'A';

comment on column ctlt1.b is 'B';

comment on constraint ctlt1_a_check on ctlt1 is 't1_a_check';

comment on index ctlt1_pkey is 'index pkey';

comment on index ctlt1_b_key is 'index b_key';

alter table ctlt1
  alter column a set STORAGE main;

create table ctlt2 (c TEXT not null);

alter table ctlt2
  alter column c set STORAGE external;

comment on column ctlt2.c is 'C';

comment on constraint ctlt2_c_not_null on ctlt2 is 't2_c_not_null';

create table ctlt3 (
  a TEXT check (length(a) < 5),
  c TEXT check (length(c) < 7)
);

alter table ctlt3
  alter column c set STORAGE external;

alter table ctlt3
  alter column a set STORAGE main;

create index "ctlt3_fnidx" on ctlt3 using btree ((a || c));

comment on column ctlt3.a is 'A3';

comment on column ctlt3.c is 'C';

comment on constraint ctlt3_a_check on ctlt3 is 't3_a_check';

create table ctlt4 (
  a TEXT,
  c TEXT
);

alter table ctlt4
  alter column c set STORAGE external;

create table ctlt12_storage (
  like ctlt1 including STORAGE,
  like ctlt2 including STORAGE
);

create table ctlt12_comments (
  like ctlt1 including COMMENTS,
  like ctlt2 including COMMENTS
);

select
  conname,
  description
from
  pg_description,
  pg_constraint as c
where
  classoid =
  cast('pg_constraint' as REGCLASS) and
  objoid = c.oid and
  c.conrelid =
  cast('ctlt12_comments' as REGCLASS);

create table ctlt1_inh (like ctlt1 including COMMENTS including CONSTRAINTS)
inherits (ctlt1);

select
  description
from
  pg_description,
  pg_constraint as c
where
  classoid =
  cast('pg_constraint' as REGCLASS) and
  objoid = c.oid and
  c.conrelid =
  cast('ctlt1_inh' as REGCLASS);

create table ctlt13_inh ()
inherits (ctlt1,
ctlt3);

create table ctlt13_like (
  like ctlt3
  including COMMENTS
  including CONSTRAINTS
  including INDEXES
  including STORAGE
)
inherits (ctlt1);

select
  description
from
  pg_description,
  pg_constraint as c
where
  classoid =
  cast('pg_constraint' as REGCLASS) and
  objoid = c.oid and
  c.conrelid =
  cast('ctlt13_like' as REGCLASS);

create table ctlt_all (like ctlt1 including all);

select
  c.relname,
  objsubid,
  description
from
  pg_description,
  pg_index as i,
  pg_class as c
where
  classoid = cast('pg_class' as REGCLASS) and
  objoid = i.indexrelid and
  c.oid = i.indexrelid and
  i.indrelid =
  cast('ctlt_all' as REGCLASS)
order by c.relname,
  objsubid;

select
  s.stxname,
  objsubid,
  description
from
  pg_description,
  pg_statistic_ext as s
where
  classoid =
  cast('pg_statistic_ext' as REGCLASS) and
  objoid = s.oid and
  s.stxrelid =
  cast('ctlt_all' as REGCLASS)
order by s.stxname,
  objsubid;

create table inh_error1 ()
inherits (ctlt1,
ctlt4);

create table inh_error2 (like ctlt4 including STORAGE)
inherits (ctlt1);

create table pg_attrdef (like ctlt1 including all);

drop TABLE "public"."pg_attrdef";

begin;

create schema "ctl_schema";

set local search_path to ctl_schema, public;

create table ctlt1 (like ctlt1 including all);

rollback;

drop TABLE
  "ctlt1",
  "ctlt2",
  "ctlt3",
  "ctlt4",
  "ctlt12_storage",
  "ctlt12_comments",
  "ctlt1_inh",
  "ctlt13_inh",
  "ctlt13_like",
  "ctlt_all",
  "ctla",
  "ctlb" cascade;

comment on constraint noinh_con_copy_b_not_null
on noinh_con_copy is 'not null b';

comment on constraint noinh_con_copy_c_not_null
on noinh_con_copy is 'not null c no inherit';

create table noinh_con_copy1 (
  like noinh_con_copy
  including COMMENTS
  including CONSTRAINTS
);

select
  conname,
  description
from
  pg_description,
  pg_constraint as c
where
  classoid =
  cast('pg_constraint' as REGCLASS) and
  objoid = c.oid and
  c.conrelid =
  cast('noinh_con_copy1' as REGCLASS)
order by conname collate "C";

create table noinh_con_copy1_parted (like noinh_con_copy including all)
partition by LIST(a);

drop TABLE "noinh_con_copy", "noinh_con_copy1";

create table ctlt4 (
  a INT,
  b TEXT
);

create sequence ctlseq1;

create table ctlt10 (like ctlseq1);

create view ctlv1
as select * from ctlt4;

create table ctlt11 (like ctlv1);

create table ctlt11a (like ctlv1 including all);

create type ctlty1 as (a INT, b TEXT);

create table ctlt12 (like ctlty1);

drop SEQUENCE "ctlseq1";

drop TYPE ctlty1;

drop VIEW "ctlv1";

drop TABLE if exists "ctlt4", "ctlt10", "ctlt11", "ctlt11a", "ctlt12";

create FOREIGN DATA WRAPPER ctl_dummy;

create server ctl_s0 foreign data wrapper ctl_dummy;

create table ctl_table (
  a INT primary key,
  b VARCHAR compression pglz,
  c INT generated always as (a * 2) stored,
  d BIGINT generated always as identity,
  e INT default 1
);

create index "ctl_table_a_key" on ctl_table using btree (a);

comment on column ctl_table.b is 'Column b';

create STATISTICS ctl_table_stat on "a", "b" from ctl_table;

alter table ctl_table
  add constraint "foo" check (b = 'text');

alter table ctl_table
  alter column b set STORAGE main;

create foreign table ctl_foreign_table1 ( like ctl_table ) SERVER ctl_s0;

select
  attname,
  attcompression
from
  pg_attribute
where
  attrelid =
  cast('ctl_foreign_table1' as REGCLASS) and
  attnum > 0
order by attnum;

create foreign table ctl_foreign_table2 (
  like ctl_table including all
) SERVER ctl_s0;

select
  attname,
  attcompression
from
  pg_attribute
where
  attrelid =
  cast('ctl_foreign_table2' as REGCLASS) and
  attnum > 0
order by attnum;

drop TABLE "ctl_table";

drop FOREIGN TABLE "ctl_foreign_table1";

drop FOREIGN TABLE "ctl_foreign_table2";

drop FOREIGN DATA WRAPPER ctl_dummy cascade;
