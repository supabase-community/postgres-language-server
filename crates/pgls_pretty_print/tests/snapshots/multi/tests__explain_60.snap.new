---
source: crates/pgls_pretty_print/tests/tests.rs
assertion_line: 160
input_file: crates/pgls_pretty_print/tests/data/multi/explain_60.sql
---
CREATE FUNCTION explain_filter(
  TEXT
)
RETURNS SETOF TEXT
LANGUAGE "plpgsql"
AS '
declare
    ln text;
begin
    for ln in execute $1
    loop
        -- Replace any numeric word with just ''N''
        ln := regexp_replace(ln, ''-?\m\d+\M'', ''N'', ''g'');
        -- In sort output, the above won''t match units-suffixed numbers
        ln := regexp_replace(ln, ''\m\d+kB'', ''NkB'', ''g'');
        -- Ignore text-mode buffers output because it varies depending
        -- on the system state
        CONTINUE WHEN (ln ~ '' +Buffers: .*'');
        -- Ignore text-mode "Planning:" line because whether it''s output
        -- varies depending on the system state
        CONTINUE WHEN (ln = ''Planning:'');
        return next ln;
    end loop;
end;
';

CREATE FUNCTION explain_filter_to_json(
  TEXT
)
RETURNS JSONB
LANGUAGE "plpgsql"
AS '
declare
    data text := '''';
    ln text;
begin
    for ln in execute $1
    loop
        -- Replace any numeric word with just ''0''
        ln := regexp_replace(ln, ''\m\d+\M'', ''0'', ''g'');
        data := data || ln;
    end loop;
    return data::jsonb;
end;
';

SET jit = off;

SET track_io_timing = off;

SELECT explain_filter('explain select * from int8_tbl i8');

SELECT
  explain_filter('explain (analyze, buffers off) select * from int8_tbl i8');

SELECT
  explain_filter('explain (analyze, buffers off, verbose) select * from int8_tbl i8');

SELECT
  explain_filter('explain (analyze, buffers, format text) select * from int8_tbl i8');

SELECT
  explain_filter('explain (analyze, buffers, format xml) select * from int8_tbl i8');

SELECT
  explain_filter('explain (analyze, serialize, buffers, format yaml) select * from int8_tbl i8');

SELECT
  explain_filter('explain (buffers, format text) select * from int8_tbl i8');

SELECT
  explain_filter('explain (buffers, format json) select * from int8_tbl i8');

SELECT
  explain_filter('explain verbose select sum(unique1) over w, sum(unique2) over (w order by hundred), sum(tenthous) over (w order by hundred) from tenk1 window w as (partition by ten)');

SELECT
  explain_filter('explain verbose select sum(unique1) over w1, sum(unique2) over (w1 order by hundred), sum(tenthous) over (w1 order by hundred rows 10 preceding) from tenk1 window w1 as (partition by ten)');

SET track_io_timing = on;

SELECT
  explain_filter('explain (analyze, buffers, format json) select * from int8_tbl i8');

SET track_io_timing = off;

BEGIN;

SET LOCAL plan_cache_mode = force_generic_plan;

SELECT
  TRUE AS "OK"
FROM
  explain_filter('explain (settings) select * from int8_tbl i8') AS ln
WHERE
  ln ~ '^ *Settings: .*plan_cache_mode = ''force_generic_plan''';

SELECT
  explain_filter_to_json('explain (settings, format json) select * from int8_tbl i8') #> '{0,Settings,plan_cache_mode}';

ROLLBACK;

SELECT
  explain_filter('explain (generic_plan) select unique1 from tenk1 where thousand = $1');

SELECT
  explain_filter('explain (analyze, generic_plan) select unique1 from tenk1 where thousand = $1');

SELECT
  explain_filter('explain (memory) select * from int8_tbl i8');

SELECT
  explain_filter('explain (memory, analyze, buffers off) select * from int8_tbl i8');

SELECT
  explain_filter('explain (memory, summary, format yaml) select * from int8_tbl i8');

SELECT
  explain_filter('explain (memory, analyze, format json) select * from int8_tbl i8');

PREPARE int8_query AS SELECT * FROM int8_tbl AS i8;;

SELECT
  explain_filter('explain (memory) execute int8_query');

CREATE TABLE gen_part (
  key1 INT NOT NULL,
  key2 INT NOT NULL
)
PARTITION
BY LIST
(key1);

CREATE TABLE gen_part_1
PARTITION OF gen_part
FOR VALUES IN (1)
PARTITION
BY RANGE
(key2);

CREATE TABLE gen_part_1_1
PARTITION OF gen_part_1
FOR VALUES FROM (1) TO (2);

CREATE TABLE gen_part_1_2
PARTITION OF gen_part_1
FOR VALUES FROM (2) TO (3);

CREATE TABLE gen_part_2
PARTITION OF gen_part
FOR VALUES IN (2);

SELECT
  explain_filter('explain (generic_plan) select key1, key2 from gen_part where key1 = 1 and key2 = $1');

DROP TABLE "gen_part";

BEGIN;

SET parallel_setup_cost = 0;

SET parallel_tuple_cost = 0;

SET min_parallel_table_scan_size = 0;

SET max_parallel_workers_per_gather = 4;

SELECT
  jsonb_pretty(explain_filter_to_json('explain (analyze, verbose, buffers, format json)
                         select * from tenk1 order by tenthous') #- '{0,Plan,Plans,0,Plans,0,Workers}' #- '{0,Plan,Plans,0,Workers}' #- '{0,Plan,Plans,0,Sort Method}' #- '{0,Plan,Plans,0,Sort Space Type}');

ROLLBACK;

CREATE TEMPORARY TABLE t1 ( f1 DOUBLE PRECISION );

CREATE FUNCTION pg_temp.mysin(
  DOUBLE PRECISION
)
RETURNS DOUBLE PRECISION
LANGUAGE "plpgsql"
AS 'begin return sin($1); end';

SELECT
  explain_filter('explain (verbose) select * from t1 where pg_temp.mysin(f1) < 0.5');

SET compute_query_id = on;

SELECT
  explain_filter('explain (verbose) select * from int8_tbl i8');

SELECT
  explain_filter('explain (verbose) declare test_cur cursor for select * from int8_tbl');

SELECT
  explain_filter('explain (verbose) create table test_ctas as select 1');

SELECT
  explain_filter('explain (analyze,buffers off,serialize) select * from int8_tbl i8');

SELECT
  explain_filter('explain (analyze,serialize text,buffers,timing off) select * from int8_tbl i8');

SELECT
  explain_filter('explain (analyze,serialize binary,buffers,timing) select * from int8_tbl i8');

SELECT
  explain_filter('explain (analyze,buffers off,serialize) create temp table explain_temp as select * from int8_tbl i8');

SELECT
  explain_filter('explain (analyze,buffers off,costs off) select sum(n) over() from generate_series(1,10) a(n)');

SET work_mem = 64;

SELECT
  explain_filter('explain (analyze,buffers off,costs off) select sum(n) over() from generate_series(1,2500) a(n)');

SELECT
  explain_filter('explain (analyze,buffers off,costs off) select sum(n) over(partition by m) from (SELECT n < 3 as m, n from generate_series(1,2500) a(n))');

RESET work_mem;
