---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/triggers.sql
snapshot_kind: text
---
create function trigger_return_old()
returns trigger
as 'regresslib'
language "c";

create table trigtest (
  f1 INT,
  f2 TEXT
);

create TRIGGER trigger_return_old
  before insert or delete or update
  on trigtest
  for EACH ROW
  EXECUTE FUNCTION trigger_return_old();

insert into trigtest values (1, 'foo');

select * from trigtest;

update trigtest set f2 = f2 || 'bar';

select * from trigtest;

delete from trigtest;

select * from trigtest;

create function f1_times_10()
returns trigger
as ' begin new.f1 := new.f1 * 10; return new; end '
language "plpgsql";

create TRIGGER trigger_alpha
  before insert or update
  on trigtest
  for EACH ROW
  EXECUTE FUNCTION f1_times_10();

insert into trigtest values (1, 'foo');

select * from trigtest;

update trigtest set f2 = f2 || 'bar';

select * from trigtest;

delete from trigtest;

select * from trigtest;

create TRIGGER trigger_zed
  before insert or update
  on trigtest
  for EACH ROW
  EXECUTE FUNCTION f1_times_10();

insert into trigtest values (1, 'foo');

select * from trigtest;

update trigtest set f2 = f2 || 'bar';

select * from trigtest;

delete from trigtest;

select * from trigtest;

drop TRIGGER "trigger_alpha" on "trigtest";

insert into trigtest values (1, 'foo');

select * from trigtest;

update trigtest set f2 = f2 || 'bar';

select * from trigtest;

delete from trigtest;

select * from trigtest;

drop TABLE "trigtest";

create table trigtest (
  a INT,
  b BOOLEAN default true not null,
  c TEXT default 'xyzzy' not null
);

create TRIGGER trigger_return_old
  before insert or delete or update
  on trigtest
  for EACH ROW
  EXECUTE FUNCTION trigger_return_old();

insert into trigtest values (1);

select * from trigtest;

alter table trigtest
  add column d INT default 42 not null;

select * from trigtest;

update trigtest set a = 2 where a = 1 returning *;

select * from trigtest;

alter table trigtest
  drop column b;

select * from trigtest;

update trigtest set a = 2 where a = 1 returning *;

select * from trigtest;

drop TABLE "trigtest";

create table log_table (tstamp TIMESTAMP default cast(timeofday() as TIMESTAMP));

create table main_table (
  a INT unique,
  b INT
);

create function trigger_func()
returns trigger
language "plpgsql"
as '
BEGIN
	RAISE NOTICE ''trigger_func(%) called: action = %, when = %, level = %'', TG_ARGV[0], TG_OP, TG_WHEN, TG_LEVEL;
	RETURN NULL;
END;';

create TRIGGER before_ins_stmt_trig
  before insert
  on main_table
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_func(before_ins_stmt);

create TRIGGER after_ins_stmt_trig
  after insert
  on main_table
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_func(after_ins_stmt);

create TRIGGER after_upd_stmt_trig
  after update
  on main_table
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_func(after_upd_stmt);

insert into main_table (a, b) values (5, 10) on conflict (a) do update set b = excluded.b;

create TRIGGER after_upd_row_trig
  after update
  on main_table
  for EACH ROW
  EXECUTE FUNCTION trigger_func(after_upd_row);

insert into main_table default values;

update main_table set a = a + 1 where b < 30;

update main_table set a = a + 2 where b > 100;

alter table main_table
  drop constraint main_table_a_key;

select * from main_table order by a, b;

comment on trigger no_such_trigger on main_table is 'wrong';

comment on trigger before_ins_stmt_trig on main_table is 'right';

comment on trigger before_ins_stmt_trig on main_table is null;

create TRIGGER modified_a
  before update of a
  on main_table
  for EACH ROW
  when (old.a <> new.a)
  EXECUTE FUNCTION trigger_func(modified_a);

create TRIGGER modified_any
  before update of a
  on main_table
  for EACH ROW
  when (old.* is distinct from new.*)
  EXECUTE FUNCTION trigger_func(modified_any);

create TRIGGER insert_a
  after insert
  on main_table
  for EACH ROW
  when (new.a = 123)
  EXECUTE FUNCTION trigger_func(insert_a);

create TRIGGER delete_a
  after delete
  on main_table
  for EACH ROW
  when (old.a = 123)
  EXECUTE FUNCTION trigger_func(delete_a);

create TRIGGER insert_when
  before insert
  on main_table
  for EACH STATEMENT
  when (true)
  EXECUTE FUNCTION trigger_func(insert_when);

create TRIGGER delete_when
  after delete
  on main_table
  for EACH STATEMENT
  when (true)
  EXECUTE FUNCTION trigger_func(delete_when);

select
  trigger_name,
  event_manipulation,
  event_object_schema,
  event_object_table,
  action_order,
  action_condition,
  action_orientation,
  action_timing,
  action_reference_old_table,
  action_reference_new_table
from
  information_schema.triggers
where
  event_object_table in ('main_table')
order by trigger_name collate "C",
  2;

insert into main_table (a) values (123), (456);

delete from main_table where a in (123, 456);

update main_table set a = 50, b = 60;

select * from main_table order by a, b;

select
  pg_get_triggerdef(oid, true)
from
  pg_trigger
where
  tgrelid = cast('main_table' as REGCLASS) and
  tgname = 'modified_a';

select
  pg_get_triggerdef(oid, false)
from
  pg_trigger
where
  tgrelid = cast('main_table' as REGCLASS) and
  tgname = 'modified_a';

select
  pg_get_triggerdef(oid, true)
from
  pg_trigger
where
  tgrelid = cast('main_table' as REGCLASS) and
  tgname = 'modified_any';

alter trigger modified_a on main_table rename to modified_modified_a;

select
  COUNT(*)
from
  pg_trigger
where
  tgrelid = cast('main_table' as REGCLASS) and
  tgname = 'modified_a';

select
  COUNT(*)
from
  pg_trigger
where
  tgrelid = cast('main_table' as REGCLASS) and
  tgname = 'modified_modified_a';

drop TRIGGER "modified_modified_a" on "main_table";

drop TRIGGER "modified_any" on "main_table";

drop TRIGGER "insert_a" on "main_table";

drop TRIGGER "delete_a" on "main_table";

drop TRIGGER "insert_when" on "main_table";

drop TRIGGER "delete_when" on "main_table";

create table table_with_oids (a INT);

insert into table_with_oids values (1);

create TRIGGER oid_unchanged_trig
  after update
  on table_with_oids
  for EACH ROW
  when (new.tableoid = old.tableoid and new.tableoid <> 0)
  EXECUTE FUNCTION trigger_func(after_upd_oid_unchanged);

update table_with_oids set a = a + 1;

drop TABLE "table_with_oids";

drop TRIGGER "after_upd_row_trig" on "main_table";

create TRIGGER before_upd_a_row_trig
  before update of a
  on main_table
  for EACH ROW
  EXECUTE FUNCTION trigger_func(before_upd_a_row);

create TRIGGER after_upd_b_row_trig
  after update of b
  on main_table
  for EACH ROW
  EXECUTE FUNCTION trigger_func(after_upd_b_row);

create TRIGGER after_upd_a_b_row_trig
  after update of a,
  b
  on main_table
  for EACH ROW
  EXECUTE FUNCTION trigger_func(after_upd_a_b_row);

create TRIGGER before_upd_a_stmt_trig
  before update of a
  on main_table
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_func(before_upd_a_stmt);

create TRIGGER after_upd_b_stmt_trig
  after update of b
  on main_table
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_func(after_upd_b_stmt);

select
  pg_get_triggerdef(oid)
from
  pg_trigger
where
  tgrelid = cast('main_table' as REGCLASS) and
  tgname = 'after_upd_a_b_row_trig';

update main_table set a = 50;

update main_table set b = 10;

create table some_t (some_col BOOLEAN not null);

create function dummy_update_func()
returns trigger
as '
BEGIN
  RAISE NOTICE ''dummy_update_func(%) called: action = %, old = %, new = %'',
    TG_ARGV[0], TG_OP, OLD, NEW;
  RETURN NEW;
END;
'
language "plpgsql";

create TRIGGER some_trig_before
  before update
  on some_t
  for EACH ROW
  EXECUTE FUNCTION dummy_update_func(before);

create TRIGGER some_trig_aftera
  after update
  on some_t
  for EACH ROW
  when (not old.some_col and new.some_col)
  EXECUTE FUNCTION dummy_update_func(aftera);

create TRIGGER some_trig_afterb
  after update
  on some_t
  for EACH ROW
  when (not new.some_col)
  EXECUTE FUNCTION dummy_update_func(afterb);

insert into some_t values (true);

update some_t set some_col = true;

update some_t set some_col = false;

update some_t set some_col = true;

drop TABLE "some_t";

create TRIGGER error_upd_a_a
  before update of a,
  a
  on main_table
  for EACH ROW
  EXECUTE FUNCTION trigger_func(error_upd_a_a);

create TRIGGER error_ins_when
  before insert or update
  on main_table
  for EACH ROW
  when (old.a <> new.a)
  EXECUTE FUNCTION trigger_func(error_ins_old);

create TRIGGER error_del_when
  before delete or update
  on main_table
  for EACH ROW
  when (old.a <> new.a)
  EXECUTE FUNCTION trigger_func(error_del_new);

create TRIGGER error_del_when
  before insert or update
  on main_table
  for EACH ROW
  when (new.tableoid <> 0)
  EXECUTE FUNCTION trigger_func(error_when_sys_column);

create TRIGGER error_stmt_when
  before update of a
  on main_table
  for EACH STATEMENT
  when (old.* is distinct from new.*)
  EXECUTE FUNCTION trigger_func(error_stmt_when);

alter table main_table
  drop column b;

begin;

drop TRIGGER "after_upd_a_b_row_trig" on "main_table";

drop TRIGGER "after_upd_b_row_trig" on "main_table";

drop TRIGGER "after_upd_b_stmt_trig" on "main_table";

alter table main_table
  drop column b;

rollback;

create table trigtest (i serial primary key);

create table trigtest2 (i INT references trigtest (i) on DELETE cascade);

create function trigtest()
returns trigger
as '
begin
	raise notice ''% % % %'', TG_TABLE_NAME, TG_OP, TG_WHEN, TG_LEVEL;
	return new;
end;'
language "plpgsql";

create TRIGGER trigtest_b_row_tg
  before insert or delete or update
  on trigtest
  for EACH ROW
  EXECUTE FUNCTION trigtest();

create TRIGGER trigtest_a_row_tg
  after insert or delete or update
  on trigtest
  for EACH ROW
  EXECUTE FUNCTION trigtest();

create TRIGGER trigtest_b_stmt_tg
  before insert or delete or update
  on trigtest
  for EACH STATEMENT
  EXECUTE FUNCTION trigtest();

create TRIGGER trigtest_a_stmt_tg
  after insert or delete or update
  on trigtest
  for EACH STATEMENT
  EXECUTE FUNCTION trigtest();

insert into trigtest default values;

alter table trigtest
  disable trigger trigtest_b_row_tg;

insert into trigtest default values;

alter table trigtest
  disable trigger user;

insert into trigtest default values;

alter table trigtest
  enable trigger trigtest_a_stmt_tg;

insert into trigtest default values;

set session_replication_role = replica;

insert into trigtest default values;

alter table trigtest
  enable ALWAYS trigger trigtest_a_stmt_tg;

insert into trigtest default values;

reset session_replication_role;

insert into trigtest2 values (1);

insert into trigtest2 values (2);

delete from trigtest where i = 2;

select * from trigtest2;

alter table trigtest
  disable trigger all;

delete from trigtest where i = 1;

select * from trigtest2;

insert into trigtest default values;

select * from trigtest;

drop TABLE "trigtest2";

drop TABLE "trigtest";

create table trigger_test (
  i INT,
  v VARCHAR
);

create or replace function trigger_data()
returns trigger
language "plpgsql"
as '

declare

	argstr text;
	relid text;

begin

	relid := TG_relid::regclass;

	-- plpgsql can''t discover its trigger data in a hash like perl and python
	-- can, or by a sort of reflection like tcl can,
	-- so we have to hard code the names.
	raise NOTICE ''TG_NAME: %'', TG_name;
	raise NOTICE ''TG_WHEN: %'', TG_when;
	raise NOTICE ''TG_LEVEL: %'', TG_level;
	raise NOTICE ''TG_OP: %'', TG_op;
	raise NOTICE ''TG_RELID::regclass: %'', relid;
	raise NOTICE ''TG_RELNAME: %'', TG_relname;
	raise NOTICE ''TG_TABLE_NAME: %'', TG_table_name;
	raise NOTICE ''TG_TABLE_SCHEMA: %'', TG_table_schema;
	raise NOTICE ''TG_NARGS: %'', TG_nargs;

	argstr := ''['';
	for i in 0 .. TG_nargs - 1 loop
		if i > 0 then
			argstr := argstr || '', '';
		end if;
		argstr := argstr || TG_argv[i];
	end loop;
	argstr := argstr || '']'';
	raise NOTICE ''TG_ARGV: %'', argstr;

	if TG_OP != ''INSERT'' then
		raise NOTICE ''OLD: %'', OLD;
	end if;

	if TG_OP != ''DELETE'' then
		raise NOTICE ''NEW: %'', NEW;
	end if;

	if TG_OP = ''DELETE'' then
		return OLD;
	else
		return NEW;
	end if;

end;
';

create TRIGGER show_trigger_data_trig
  before insert or delete or update
  on trigger_test
  for EACH ROW
  EXECUTE FUNCTION trigger_data("23",
  skidoo);

insert into trigger_test values (1, 'insert');

update trigger_test set v = 'update' where i = 1;

delete from trigger_test;

drop TRIGGER "show_trigger_data_trig" on "trigger_test";

drop FUNCTION trigger_data();

drop TABLE "trigger_test";

create table trigger_test (
  f1 INT,
  f2 TEXT,
  f3 TEXT
);

create function mytrigger()
returns trigger
language "plpgsql"
as '
begin
	if row(old.*) = row(new.*) then
		raise notice ''row % not changed'', new.f1;
	else
		raise notice ''row % changed'', new.f1;
	end if;
	return new;
end';

create TRIGGER t before update on trigger_test for EACH ROW EXECUTE FUNCTION mytrigger();

insert into trigger_test values (1, 'foo', 'bar');

insert into trigger_test values (2, 'baz', 'quux');

update trigger_test set f3 = 'bar';

update trigger_test set f3 = null;

update trigger_test set f3 = null;

create or replace function mytrigger()
returns trigger
language "plpgsql"
as '
begin
	if row(old.*) is distinct from row(new.*) then
		raise notice ''row % changed'', new.f1;
	else
		raise notice ''row % not changed'', new.f1;
	end if;
	return new;
end';

update trigger_test set f3 = 'bar';

update trigger_test set f3 = null;

update trigger_test set f3 = null;

drop TABLE "trigger_test";

drop FUNCTION mytrigger();

create function serializable_update_trig()
returns trigger
language "plpgsql"
as '
declare
	rec record;
begin
	new.description = ''updated in trigger'';
	return new;
end;
';

create table serializable_update_tab (
  id INT,
  filler TEXT,
  description TEXT
);

create TRIGGER serializable_update_trig
  before update
  on serializable_update_tab
  for EACH ROW
  EXECUTE FUNCTION serializable_update_trig();

insert into serializable_update_tab
select
  a,
  repeat('xyzxz', 100),
  'new'
from
  generate_series(1, 50) as a;

begin;

set TRANSACTION isolation level serializable;

update serializable_update_tab set description = 'no no', id = 1 where id = 1;

commit;

select description from serializable_update_tab where id = 1;

drop TABLE "serializable_update_tab";

create table min_updates_test (
  f1 TEXT,
  f2 INT,
  f3 INT
);

insert into min_updates_test values ('a', 1, 2), ('b', '2', null);

create TRIGGER z_min_update
  before update
  on min_updates_test
  for EACH ROW
  EXECUTE FUNCTION suppress_redundant_updates_trigger();

update min_updates_test set f1 = f1;

update min_updates_test set f2 = f2 + 1;

update min_updates_test set f3 = 2 where f3 is null;

select * from min_updates_test;

drop TABLE "min_updates_test";

create view main_view
as select a, b from main_table;

create or replace function view_trigger()
returns trigger
language "plpgsql"
as '
declare
    argstr text := '''';
begin
    for i in 0 .. TG_nargs - 1 loop
        if i > 0 then
            argstr := argstr || '', '';
        end if;
        argstr := argstr || TG_argv[i];
    end loop;

    raise notice ''% % % % (%)'', TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, argstr;

    if TG_LEVEL = ''ROW'' then
        if TG_OP = ''INSERT'' then
            raise NOTICE ''NEW: %'', NEW;
            INSERT INTO main_table VALUES (NEW.a, NEW.b);
            RETURN NEW;
        end if;

        if TG_OP = ''UPDATE'' then
            raise NOTICE ''OLD: %, NEW: %'', OLD, NEW;
            UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b;
            if NOT FOUND then RETURN NULL; end if;
            RETURN NEW;
        end if;

        if TG_OP = ''DELETE'' then
            raise NOTICE ''OLD: %'', OLD;
            DELETE FROM main_table WHERE a = OLD.a AND b = OLD.b;
            if NOT FOUND then RETURN NULL; end if;
            RETURN OLD;
        end if;
    end if;

    RETURN NULL;
end;
';

create TRIGGER invalid_trig
  before insert
  on main_view
  for EACH ROW
  EXECUTE FUNCTION trigger_func(before_ins_row);

create TRIGGER invalid_trig
  before update
  on main_view
  for EACH ROW
  EXECUTE FUNCTION trigger_func(before_upd_row);

create TRIGGER invalid_trig
  before delete
  on main_view
  for EACH ROW
  EXECUTE FUNCTION trigger_func(before_del_row);

create TRIGGER invalid_trig
  after insert
  on main_view
  for EACH ROW
  EXECUTE FUNCTION trigger_func(before_ins_row);

create TRIGGER invalid_trig
  after update
  on main_view
  for EACH ROW
  EXECUTE FUNCTION trigger_func(before_upd_row);

create TRIGGER invalid_trig
  after delete
  on main_view
  for EACH ROW
  EXECUTE FUNCTION trigger_func(before_del_row);

create TRIGGER invalid_trig
  before TRUNCATE
  on main_view
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_func(before_tru_row);

create TRIGGER invalid_trig
  after TRUNCATE
  on main_view
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_func(before_tru_row);

create TRIGGER invalid_trig
  instead of insert
  on main_table
  for EACH ROW
  EXECUTE FUNCTION view_trigger(instead_of_ins);

create TRIGGER invalid_trig
  instead of update
  on main_table
  for EACH ROW
  EXECUTE FUNCTION view_trigger(instead_of_upd);

create TRIGGER invalid_trig
  instead of delete
  on main_table
  for EACH ROW
  EXECUTE FUNCTION view_trigger(instead_of_del);

create TRIGGER invalid_trig
  instead of update
  on main_view
  for EACH ROW
  when (old.a <> new.a)
  EXECUTE FUNCTION view_trigger(instead_of_upd);

create TRIGGER invalid_trig
  instead of update of a
  on main_view
  for EACH ROW
  EXECUTE FUNCTION view_trigger(instead_of_upd);

create TRIGGER invalid_trig
  instead of update
  on main_view
  for EACH STATEMENT
  EXECUTE FUNCTION view_trigger(instead_of_upd);

create TRIGGER instead_of_insert_trig
  instead of insert
  on main_view
  for EACH ROW
  EXECUTE FUNCTION view_trigger(instead_of_ins);

create TRIGGER instead_of_update_trig
  instead of update
  on main_view
  for EACH ROW
  EXECUTE FUNCTION view_trigger(instead_of_upd);

create TRIGGER instead_of_delete_trig
  instead of delete
  on main_view
  for EACH ROW
  EXECUTE FUNCTION view_trigger(instead_of_del);

create TRIGGER before_ins_stmt_trig
  before insert
  on main_view
  for EACH STATEMENT
  EXECUTE FUNCTION view_trigger(before_view_ins_stmt);

create TRIGGER before_upd_stmt_trig
  before update
  on main_view
  for EACH STATEMENT
  EXECUTE FUNCTION view_trigger(before_view_upd_stmt);

create TRIGGER before_del_stmt_trig
  before delete
  on main_view
  for EACH STATEMENT
  EXECUTE FUNCTION view_trigger(before_view_del_stmt);

create TRIGGER after_ins_stmt_trig
  after insert
  on main_view
  for EACH STATEMENT
  EXECUTE FUNCTION view_trigger(after_view_ins_stmt);

create TRIGGER after_upd_stmt_trig
  after update
  on main_view
  for EACH STATEMENT
  EXECUTE FUNCTION view_trigger(after_view_upd_stmt);

create TRIGGER after_del_stmt_trig
  after delete
  on main_view
  for EACH STATEMENT
  EXECUTE FUNCTION view_trigger(after_view_del_stmt);

insert into main_view values (20, 30);

insert into main_view values (21, 31) returning a, b;

update main_view set b = 31 where a = 20;

update main_view set b = 32 where a = 21 and b = 31 returning a, b;

drop TRIGGER "before_upd_a_row_trig" on "main_table";

update main_view set b = 31 where a = 20;

update main_view set b = 32 where a = 21 and b = 31 returning a, b;

update main_view set b = 0 where false;

delete from main_view where a in (20, 21);

delete from main_view where a = 31 returning a, b;

drop TRIGGER "instead_of_insert_trig" on "main_view";

drop TRIGGER "instead_of_delete_trig" on "main_view";

drop VIEW "main_view";

create table country_table (
  country_id serial primary key,
  country_name TEXT unique not null,
  continent TEXT not null
);

insert into country_table (country_name, continent)
values
  ('Japan', 'Asia'),
  ('UK', 'Europe'),
  ('USA', 'North America')
returning *;

create table city_table (
  city_id serial primary key,
  city_name TEXT not null,
  population BIGINT,
  country_id INT references country_table
);

create view city_view
as select
  city_id,
  city_name,
  population,
  country_name,
  continent
from
  city_table as ci
  left outer join
    country_table as co
  on co.country_id = ci.country_id;

create function city_insert()
returns trigger
language "plpgsql"
as '
declare
    ctry_id int;
begin
    if NEW.country_name IS NOT NULL then
        SELECT country_id, continent INTO ctry_id, NEW.continent
            FROM country_table WHERE country_name = NEW.country_name;
        if NOT FOUND then
            raise exception ''No such country: "%"'', NEW.country_name;
        end if;
    else
        NEW.continent := NULL;
    end if;

    if NEW.city_id IS NOT NULL then
        INSERT INTO city_table
            VALUES(NEW.city_id, NEW.city_name, NEW.population, ctry_id);
    else
        INSERT INTO city_table(city_name, population, country_id)
            VALUES(NEW.city_name, NEW.population, ctry_id)
            RETURNING city_id INTO NEW.city_id;
    end if;

    RETURN NEW;
end;
';

create TRIGGER city_insert_trig
  instead of insert
  on city_view
  for EACH ROW
  EXECUTE FUNCTION city_insert();

create function city_delete()
returns trigger
language "plpgsql"
as '
begin
    DELETE FROM city_table WHERE city_id = OLD.city_id;
    if NOT FOUND then RETURN NULL; end if;
    RETURN OLD;
end;
';

create TRIGGER city_delete_trig
  instead of delete
  on city_view
  for EACH ROW
  EXECUTE FUNCTION city_delete();

create function city_update()
returns trigger
language "plpgsql"
as '
declare
    ctry_id int;
begin
    if NEW.country_name IS DISTINCT FROM OLD.country_name then
        SELECT country_id, continent INTO ctry_id, NEW.continent
            FROM country_table WHERE country_name = NEW.country_name;
        if NOT FOUND then
            raise exception ''No such country: "%"'', NEW.country_name;
        end if;

        UPDATE city_table SET city_name = NEW.city_name,
                              population = NEW.population,
                              country_id = ctry_id
            WHERE city_id = OLD.city_id;
    else
        UPDATE city_table SET city_name = NEW.city_name,
                              population = NEW.population
            WHERE city_id = OLD.city_id;
        NEW.continent := OLD.continent;
    end if;

    if NOT FOUND then RETURN NULL; end if;
    RETURN NEW;
end;
';

create TRIGGER city_update_trig
  instead of update
  on city_view
  for EACH ROW
  EXECUTE FUNCTION city_update();

insert into city_view (city_name) values ('Tokyo') returning *;

insert into city_view (city_name, population) values ('London', 7556900) returning *;

insert into city_view (city_name, country_name) values ('Washington DC', 'USA') returning *;

insert into city_view (city_id, city_name) values (123456, 'New York') returning *;

insert into city_view values (234567, 'Birmingham', 1016800, 'UK', 'EU') returning *;

update city_view set country_name = 'Japon' where city_name = 'Tokyo';

update city_view set country_name = 'Japan' where city_name = 'Takyo';

update city_view set country_name = 'Japan' where city_name = 'Tokyo' returning *;

update city_view set population = 13010279 where city_name = 'Tokyo' returning *;

update city_view set country_name = 'UK' where city_name = 'New York' returning *;

update city_view
set country_name = 'USA',
population = 8391881
where
  city_name = 'New York'
returning *;

update city_view set continent = 'EU' where continent = 'Europe' returning *;

update city_view as v1
set country_name = v2.country_name
from city_view as v2
where
  v2.city_name = 'Birmingham' and
  v1.city_name = 'London'
returning *;

delete from city_view where city_name = 'Birmingham' returning *;

create view european_city_view
as select * from city_view where continent = 'Europe';

select COUNT(*) from european_city_view;

create function no_op_trig_fn()
returns trigger
language "plpgsql"
as 'begin RETURN NULL; end';

create TRIGGER no_op_trig
  instead of insert or delete or update
  on european_city_view
  for EACH ROW
  EXECUTE FUNCTION no_op_trig_fn();

insert into european_city_view values (0, 'x', 10000, 'y', 'z');

update european_city_view set population = 10000;

delete from european_city_view;

create rule european_city_insert_rule
as on insert to european_city_view
do instead
  insert into city_view
  values
    (
      new.city_id,
      new.city_name,
      new.population,
      new.country_name,
      new.continent
    )
  returning *;;

create rule european_city_update_rule
as on update to european_city_view
do instead
  update city_view
  set city_name = new.city_name,
  population = new.population,
  country_name = new.country_name
  where
    city_id = old.city_id
  returning new.*;;

create rule european_city_delete_rule
as on delete to european_city_view
do instead
  delete from city_view
  where
    city_id = old.city_id
  returning *;;

insert into european_city_view (city_name, country_name) values ('Cambridge', 'USA') returning *;

update european_city_view set country_name = 'UK' where city_name = 'Cambridge';

delete from european_city_view where city_name = 'Cambridge';

update city_view set country_name = 'UK' where city_name = 'Cambridge' returning *;

update european_city_view set population = 122800 where city_name = 'Cambridge' returning *;

delete from european_city_view where city_name = 'Cambridge' returning *;

update city_view as v
set population = 599657
from city_table as ci,
country_table as co
where
  ci.city_name = 'Washington DC' and
  co.country_name = 'USA' and
  v.city_id = ci.city_id and
  v.country_name = co.country_name
returning co.country_id,
v.country_name,
v.city_id,
v.city_name,
v.population;

select * from city_view;

drop TABLE "city_table" cascade;

drop TABLE "country_table";

create table depth_a (id INT not null primary key);

create table depth_b (id INT not null primary key);

create table depth_c (id INT not null primary key);

create function depth_a_tf()
returns trigger
language "plpgsql"
as '
begin
  raise notice ''%: depth = %'', tg_name, pg_trigger_depth();
  insert into depth_b values (new.id);
  raise notice ''%: depth = %'', tg_name, pg_trigger_depth();
  return new;
end;
';

create TRIGGER depth_a_tr before insert on depth_a for EACH ROW EXECUTE FUNCTION depth_a_tf();

create function depth_b_tf()
returns trigger
language "plpgsql"
as '
begin
  raise notice ''%: depth = %'', tg_name, pg_trigger_depth();
  begin
    execute ''insert into depth_c values ('' || new.id::text || '')'';
  exception
    when sqlstate ''U9999'' then
      raise notice ''SQLSTATE = U9999: depth = %'', pg_trigger_depth();
  end;
  raise notice ''%: depth = %'', tg_name, pg_trigger_depth();
  if new.id = 1 then
    execute ''insert into depth_c values ('' || new.id::text || '')'';
  end if;
  return new;
end;
';

create TRIGGER depth_b_tr before insert on depth_b for EACH ROW EXECUTE FUNCTION depth_b_tf();

create function depth_c_tf()
returns trigger
language "plpgsql"
as '
begin
  raise notice ''%: depth = %'', tg_name, pg_trigger_depth();
  if new.id = 1 then
    raise exception sqlstate ''U9999'';
  end if;
  raise notice ''%: depth = %'', tg_name, pg_trigger_depth();
  return new;
end;
';

create TRIGGER depth_c_tr before insert on depth_c for EACH ROW EXECUTE FUNCTION depth_c_tf();

select pg_trigger_depth();

insert into depth_a values (1);

select pg_trigger_depth();

insert into depth_a values (2);

select pg_trigger_depth();

drop TABLE "depth_a", "depth_b", "depth_c";

drop FUNCTION depth_a_tf();

drop FUNCTION depth_b_tf();

drop FUNCTION depth_c_tf();

create temporary table parent (
  aid INT not null primary key,
  val1 TEXT,
  val2 TEXT,
  val3 TEXT,
  val4 TEXT,
  bcnt INT not null default 0
);

create temporary table child (
  bid INT not null primary key,
  aid INT not null,
  val1 TEXT
);

create function parent_upd_func()
returns trigger
language "plpgsql"
as '
begin
  if old.val1 <> new.val1 then
    new.val2 = new.val1;
    delete from child where child.aid = new.aid and child.val1 = new.val1;
  end if;
  return new;
end;
';

create TRIGGER parent_upd_trig
  before update
  on parent
  for EACH ROW
  EXECUTE FUNCTION parent_upd_func();

create function parent_del_func()
returns trigger
language "plpgsql"
as '
begin
  delete from child where aid = old.aid;
  return old;
end;
';

create TRIGGER parent_del_trig
  before delete
  on parent
  for EACH ROW
  EXECUTE FUNCTION parent_del_func();

create function child_ins_func()
returns trigger
language "plpgsql"
as '
begin
  update parent set bcnt = bcnt + 1 where aid = new.aid;
  return new;
end;
';

create TRIGGER child_ins_trig after insert on child for EACH ROW EXECUTE FUNCTION child_ins_func();

create function child_del_func()
returns trigger
language "plpgsql"
as '
begin
  update parent set bcnt = bcnt - 1 where aid = old.aid;
  return old;
end;
';

create TRIGGER child_del_trig after delete on child for EACH ROW EXECUTE FUNCTION child_del_func();

insert into parent values (1, 'a', 'a', 'a', 'a', 0);

insert into child values (10, 1, 'b');

select * from parent;

select * from child;

update parent set val1 = 'b' where aid = 1;

select * from parent;

select * from child;

delete from parent where aid = 1;

select * from parent;

select * from child;

create or replace function parent_del_func()
returns trigger
language "plpgsql"
as '
begin
  delete from child where aid = old.aid;
  if found then
    delete from parent where aid = old.aid;
    return null; -- cancel outer deletion
  end if;
  return old;
end;
';

delete from parent where aid = 1;

select * from parent;

select * from child;

drop TABLE "parent", "child";

drop FUNCTION parent_upd_func();

drop FUNCTION parent_del_func();

drop FUNCTION child_ins_func();

drop FUNCTION child_del_func();

create temporary table self_ref_trigger (
  id INT primary key,
  parent INT references self_ref_trigger,
  data TEXT,
  nchildren INT not null default 0
);

create function self_ref_trigger_ins_func()
returns trigger
language "plpgsql"
as '
begin
  if new.parent is not null then
    update self_ref_trigger set nchildren = nchildren + 1
      where id = new.parent;
  end if;
  return new;
end;
';

create TRIGGER self_ref_trigger_ins_trig
  before insert
  on self_ref_trigger
  for EACH ROW
  EXECUTE FUNCTION self_ref_trigger_ins_func();

create function self_ref_trigger_del_func()
returns trigger
language "plpgsql"
as '
begin
  if old.parent is not null then
    update self_ref_trigger set nchildren = nchildren - 1
      where id = old.parent;
  end if;
  return old;
end;
';

create TRIGGER self_ref_trigger_del_trig
  before delete
  on self_ref_trigger
  for EACH ROW
  EXECUTE FUNCTION self_ref_trigger_del_func();

insert into self_ref_trigger values (1, null, 'root');

insert into self_ref_trigger values (2, 1, 'root child A');

insert into self_ref_trigger values (3, 1, 'root child B');

insert into self_ref_trigger values (4, 2, 'grandchild 1');

insert into self_ref_trigger values (5, 3, 'grandchild 2');

update self_ref_trigger set data = 'root!' where id = 1;

select * from self_ref_trigger;

delete from self_ref_trigger;

select * from self_ref_trigger;

drop TABLE "self_ref_trigger";

drop FUNCTION self_ref_trigger_ins_func();

drop FUNCTION self_ref_trigger_del_func();

create table stmt_trig_on_empty_upd (a INT);

create table stmt_trig_on_empty_upd1 ()
inherits (stmt_trig_on_empty_upd);

create function update_stmt_notice()
returns trigger
as '
begin
	raise notice ''updating %'', TG_TABLE_NAME;
	return null;
end;
'
language "plpgsql";

create TRIGGER before_stmt_trigger
  before update
  on stmt_trig_on_empty_upd
  for EACH STATEMENT
  EXECUTE FUNCTION update_stmt_notice();

create TRIGGER before_stmt_trigger
  before update
  on stmt_trig_on_empty_upd1
  for EACH STATEMENT
  EXECUTE FUNCTION update_stmt_notice();

update stmt_trig_on_empty_upd set a = a where false returning a + 1 as aa;

update stmt_trig_on_empty_upd1 set a = a where false returning a + 1 as aa;

drop TABLE "stmt_trig_on_empty_upd" cascade;

drop FUNCTION update_stmt_notice();

create table trigger_ddl_table (
  col1 INT,
  col2 INT
);

create function trigger_ddl_func()
returns trigger
as '
begin
  alter table trigger_ddl_table add primary key (col1);
  return new;
end'
language "plpgsql";

create TRIGGER trigger_ddl_func
  before insert
  on trigger_ddl_table
  for EACH ROW
  EXECUTE FUNCTION trigger_ddl_func();

insert into trigger_ddl_table values (1, 42);

create or replace function trigger_ddl_func()
returns trigger
as '
begin
  create index on trigger_ddl_table (col2);
  return new;
end'
language "plpgsql";

insert into trigger_ddl_table values (1, 42);

drop TABLE "trigger_ddl_table";

drop FUNCTION trigger_ddl_func();

create table upsert (
  key INT primary key,
  color TEXT
);

create function upsert_before_func()
returns trigger
language "plpgsql"
as '
begin
  if (TG_OP = ''UPDATE'') then
    raise warning ''before update (old): %'', old.*::text;
    raise warning ''before update (new): %'', new.*::text;
  elsif (TG_OP = ''INSERT'') then
    raise warning ''before insert (new): %'', new.*::text;
    if new.key % 2 = 0 then
      new.key := new.key + 1;
      new.color := new.color || '' trig modified'';
      raise warning ''before insert (new, modified): %'', new.*::text;
    end if;
  end if;
  return new;
end;
';

create TRIGGER upsert_before_trig
  before insert or update
  on upsert
  for EACH ROW
  EXECUTE FUNCTION upsert_before_func();

create function upsert_after_func()
returns trigger
language "plpgsql"
as '
begin
  if (TG_OP = ''UPDATE'') then
    raise warning ''after update (old): %'', old.*::text;
    raise warning ''after update (new): %'', new.*::text;
  elsif (TG_OP = ''INSERT'') then
    raise warning ''after insert (new): %'', new.*::text;
  end if;
  return null;
end;
';

create TRIGGER upsert_after_trig
  after insert or update
  on upsert
  for EACH ROW
  EXECUTE FUNCTION upsert_after_func();

insert into upsert
values (1, 'black')
on conflict
(key)
do
update
set color = 'updated ' || upsert.color;

insert into upsert
values (2, 'red')
on conflict
(key)
do
update
set color = 'updated ' || upsert.color;

insert into upsert
values (3, 'orange')
on conflict
(key)
do
update
set color = 'updated ' || upsert.color;

insert into upsert
values (4, 'green')
on conflict
(key)
do
update
set color = 'updated ' || upsert.color;

insert into upsert
values (5, 'purple')
on conflict
(key)
do
update
set color = 'updated ' || upsert.color;

insert into upsert
values (6, 'white')
on conflict
(key)
do
update
set color = 'updated ' || upsert.color;

insert into upsert
values (7, 'pink')
on conflict
(key)
do
update
set color = 'updated ' || upsert.color;

insert into upsert
values (8, 'yellow')
on conflict
(key)
do
update
set color = 'updated ' || upsert.color;

select * from upsert;

drop TABLE "upsert";

drop FUNCTION upsert_before_func();

drop FUNCTION upsert_after_func();

create table my_table (i INT);

create view my_view
as select * from my_table;

create function my_trigger_function()
returns trigger
as ' begin end; '
language "plpgsql";

create TRIGGER my_trigger
  after update
  on my_view
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION my_trigger_function();

drop FUNCTION my_trigger_function();

drop VIEW "my_view";

drop TABLE "my_table";

create table parted_trig (a INT)
partition by LIST(a);

create function trigger_nothing()
returns trigger
language "plpgsql"
as ' begin end; ';

create TRIGGER failed
  instead of update
  on parted_trig
  for EACH ROW
  EXECUTE FUNCTION trigger_nothing();

create TRIGGER failed
  after update
  on parted_trig
  REFERENCING old table as old_table
  for EACH ROW
  EXECUTE FUNCTION trigger_nothing();

drop TABLE "parted_trig";

create table trigpart (
  a INT,
  b INT
)
partition by range(a);

create table trigpart1 partition of trigpart for values from (0) to (1000);

create TRIGGER trg1 after insert on trigpart for EACH ROW EXECUTE FUNCTION trigger_nothing();

create table trigpart2 partition of trigpart for values from (1000) to (2000);

create table trigpart3 (like trigpart);

alter table trigpart
  ATTACH partition
  trigpart3 for values from (2000) to (3000);

create table trigpart4 partition of trigpart for values from (3000) to (4000) partition by range(a);

create table trigpart41 partition of trigpart4 for values from (3000) to (3500);

create table trigpart42 (like trigpart);

alter table trigpart4
  ATTACH partition
  trigpart42 for values from (3500) to (4000);

select
  cast(tgrelid as REGCLASS),
  tgname,
  cast(tgfoid as REGPROC)
from
  pg_trigger
where
  cast(cast(tgrelid as REGCLASS) as TEXT) like 'trigpart%'
order by cast(cast(tgrelid as REGCLASS) as TEXT);

drop TRIGGER "trg1" on "trigpart1";

drop TRIGGER "trg1" on "trigpart2";

drop TRIGGER "trg1" on "trigpart3";

drop TABLE "trigpart2";

select
  cast(tgrelid as REGCLASS),
  tgname,
  cast(tgfoid as REGPROC)
from
  pg_trigger
where
  cast(cast(tgrelid as REGCLASS) as TEXT) like 'trigpart%'
order by cast(cast(tgrelid as REGCLASS) as TEXT);

drop TRIGGER "trg1" on "trigpart";

select
  cast(tgrelid as REGCLASS),
  tgname,
  cast(tgfoid as REGPROC)
from
  pg_trigger
where
  cast(cast(tgrelid as REGCLASS) as TEXT) like 'trigpart%'
order by cast(cast(tgrelid as REGCLASS) as TEXT);

create TRIGGER trg1 after insert on trigpart for EACH ROW EXECUTE FUNCTION trigger_nothing();

alter table trigpart
  DETACH partition
  trigpart3;

drop TRIGGER "trg1" on "trigpart3";

alter table trigpart
  DETACH partition
  trigpart4;

drop TRIGGER "trg1" on "trigpart41";

drop TABLE "trigpart4";

alter table trigpart
  ATTACH partition
  trigpart3 for values from (2000) to (3000);

alter table trigpart
  DETACH partition
  trigpart3;

alter table trigpart
  ATTACH partition
  trigpart3 for values from (2000) to (3000);

drop TABLE "trigpart3";

select
  cast(cast(tgrelid as REGCLASS) as TEXT),
  tgname,
  cast(tgfoid as REGPROC),
  tgenabled,
  tgisinternal
from
  pg_trigger
where
  tgname ~ '^trg1'
order by 1;

create table trigpart3 (like trigpart);

create TRIGGER trg1 after insert on trigpart3 for EACH ROW EXECUTE FUNCTION trigger_nothing();

alter table trigpart
  ATTACH partition
  trigpart3 for values from (2000) to (3000);

drop TABLE "trigpart3";

create TRIGGER samename
  after delete
  on trigpart
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_nothing();

create TRIGGER samename
  after delete
  on trigpart1
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_nothing();

drop TABLE "trigpart";

drop FUNCTION trigger_nothing();

create table parted_stmt_trig (a INT)
partition by LIST(a);

create table parted_stmt_trig1 partition of parted_stmt_trig for values in (1);

create table parted_stmt_trig2 partition of parted_stmt_trig for values in (2);

create table parted2_stmt_trig (a INT)
partition by LIST(a);

create table parted2_stmt_trig1 partition of parted2_stmt_trig for values in (1);

create table parted2_stmt_trig2 partition of parted2_stmt_trig for values in (2);

create or replace function trigger_notice()
returns trigger
as '
  begin
    raise notice ''trigger % on % % % for %'', TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL;
    if TG_LEVEL = ''ROW'' then
       return NEW;
    end if;
    return null;
  end;
  '
language "plpgsql";

create TRIGGER trig_ins_before
  before insert
  on parted_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_ins_after
  after insert
  on parted_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_upd_before
  before update
  on parted_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_upd_after
  after update
  on parted_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_del_before
  before delete
  on parted_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_del_after
  after delete
  on parted_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_ins_after_parent
  after insert
  on parted_stmt_trig
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_upd_after_parent
  after update
  on parted_stmt_trig
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_del_after_parent
  after delete
  on parted_stmt_trig
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_ins_before_child
  before insert
  on parted_stmt_trig1
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_ins_after_child
  after insert
  on parted_stmt_trig1
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_upd_before_child
  before update
  on parted_stmt_trig1
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_upd_after_child
  after update
  on parted_stmt_trig1
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_del_before_child
  before delete
  on parted_stmt_trig1
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_del_after_child
  after delete
  on parted_stmt_trig1
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_ins_before_3
  before insert
  on parted2_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_ins_after_3
  after insert
  on parted2_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_upd_before_3
  before update
  on parted2_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_upd_after_3
  after update
  on parted2_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_del_before_3
  before delete
  on parted2_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER trig_del_after_3
  after delete
  on parted2_stmt_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

with
ins (a)
as (
  insert into parted2_stmt_trig
  values (1), (2)
  returning a
)
insert into parted_stmt_trig
select a from ins
returning cast(tableoid as REGCLASS),
a;

with upd as (update parted2_stmt_trig set a = a) update parted_stmt_trig set a = a;

delete from parted_stmt_trig;

copy parted_stmt_trig (a) from stdout;

copy parted_stmt_trig1 (a) from stdout;

alter table parted_stmt_trig
  disable trigger trig_ins_after_parent;

insert into parted_stmt_trig values (1);

alter table parted_stmt_trig
  enable trigger trig_ins_after_parent;

insert into parted_stmt_trig values (1);

drop TABLE "parted_stmt_trig", "parted2_stmt_trig";

create table parted_trig (a INT)
partition by range(a);

create table parted_trig_1
partition of parted_trig
for values from (0) to (1000)
partition by range(a);

create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100);

create table parted_trig_2 partition of parted_trig for values from (1000) to (2000);

create TRIGGER zzz after insert on parted_trig for EACH ROW EXECUTE FUNCTION trigger_notice();

create TRIGGER mmm after insert on parted_trig_1_1 for EACH ROW EXECUTE FUNCTION trigger_notice();

create TRIGGER aaa after insert on parted_trig_1 for EACH ROW EXECUTE FUNCTION trigger_notice();

create TRIGGER bbb after insert on parted_trig for EACH ROW EXECUTE FUNCTION trigger_notice();

create TRIGGER qqq after insert on parted_trig_1_1 for EACH ROW EXECUTE FUNCTION trigger_notice();

insert into parted_trig values (50), (1500);

drop TABLE "parted_trig";

create table parted_trig (a INT)
partition by LIST(a);

create table parted_trig1 partition of parted_trig for values in (1);

create table parted_trig2 partition of parted_trig for values in (2);

insert into parted_trig values (1);

create or replace function trigger_notice()
returns trigger
as '
  begin
    raise notice ''trigger % on % % % for %'', TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL;
    if TG_LEVEL = ''ROW'' then
      if TG_OP = ''DELETE'' then
        return OLD;
      else
        return NEW;
      end if;
    end if;
    return null;
  end;
  '
language "plpgsql";

create TRIGGER parted_trig_before_stmt
  before insert or delete or update
  on parted_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

create TRIGGER parted_trig_before_row
  before insert or delete or update
  on parted_trig
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER parted_trig_after_row
  after insert or delete or update
  on parted_trig
  for EACH ROW
  EXECUTE FUNCTION trigger_notice();

create TRIGGER parted_trig_after_stmt
  after insert or delete or update
  on parted_trig
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_notice();

update parted_trig set a = 2 where a = 1;

drop TABLE "parted_trig";

create table parted_trig (a INT)
partition by LIST(a);

create table parted_trig1 partition of parted_trig for values in (1);

create or replace function trigger_notice()
returns trigger
as '
  declare
    arg1 text = TG_ARGV[0];
    arg2 integer = TG_ARGV[1];
  begin
    raise notice ''trigger % on % % % for % args % %'',
		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, arg1, arg2;
    return null;
  end;
  '
language "plpgsql";

create TRIGGER aaa
  after insert
  on parted_trig
  for EACH ROW
  EXECUTE FUNCTION trigger_notice(quirky,
  "1");

create table parted_trig2 partition of parted_trig for values in (2);

create table parted_trig3 (like parted_trig);

alter table parted_trig
  ATTACH partition
  parted_trig3 for values in (3);

insert into parted_trig values (1), (2), (3);

drop TABLE "parted_trig";

create function bark(TEXT)
returns BOOLEAN
language "plpgsql"
immutable
as ' begin raise notice ''% <- woof!'', $1; return true; end; ';

create or replace function trigger_notice_ab()
returns trigger
as '
  begin
    raise notice ''trigger % on % % % for %: (a,b)=(%,%)'',
		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL,
		NEW.a, NEW.b;
    if TG_LEVEL = ''ROW'' then
       return NEW;
    end if;
    return null;
  end;
  '
language "plpgsql";

create table parted_irreg_ancestor (
  fd TEXT,
  b TEXT,
  fd2 INT,
  fd3 INT,
  a INT
)
partition by range(b);

alter table parted_irreg_ancestor
  drop column fd,
  drop column fd2,
  drop column fd3;

create table parted_irreg (
  fd INT,
  a INT,
  fd2 INT,
  b TEXT
)
partition by range(b);

alter table parted_irreg
  drop column fd,
  drop column fd2;

alter table parted_irreg_ancestor
  ATTACH partition
  parted_irreg for values from ('aaaa') to ('zzzz');

create table parted1_irreg (
  b TEXT,
  fd INT,
  a INT
);

alter table parted1_irreg
  drop column fd;

alter table parted_irreg
  ATTACH partition
  parted1_irreg for values from ('aaaa') to ('bbbb');

create TRIGGER parted_trig
  after insert
  on parted_irreg
  for EACH ROW
  EXECUTE FUNCTION trigger_notice_ab();

create TRIGGER parted_trig_odd
  after insert
  on parted_irreg
  for EACH ROW
  when (bark(new.b) and new.a % 2 = 1)
  EXECUTE FUNCTION trigger_notice_ab();

insert into parted_irreg values (1, 'aardvark'), (2, 'aanimals');

insert into parted1_irreg values ('aardwolf', 2);

insert into parted_irreg_ancestor values ('aasvogel', 3);

drop TABLE "parted_irreg_ancestor";

create table parted (
  a INT,
  b INT,
  c TEXT
)
partition by LIST(a);

create table parted_1 partition of parted for values in (1) partition by LIST(b);

create table parted_1_1 partition of parted_1 for values in (1);

create function parted_trigfunc()
returns trigger
language "plpgsql"
as '
begin
  new.a = new.a + 1;
  return new;
end;
';

insert into parted values (1, 1, 'uno uno v1');

create TRIGGER t
  before insert or delete or update
  on parted
  for EACH ROW
  EXECUTE FUNCTION parted_trigfunc();

insert into parted values (1, 1, 'uno uno v2');

update parted set c = c || 'v3';

create or replace function parted_trigfunc()
returns trigger
language "plpgsql"
as '
begin
  new.b = new.b + 1;
  return new;
end;
';

insert into parted values (1, 1, 'uno uno v4');

update parted set c = c || 'v5';

create or replace function parted_trigfunc()
returns trigger
language "plpgsql"
as '
begin
  new.c = new.c || '' did ''|| TG_OP;
  return new;
end;
';

insert into parted values (1, 1, 'uno uno');

update parted set c = c || ' v6';

select cast(tableoid as REGCLASS), * from parted;

truncate parted;

create table parted_2 partition of parted for values in (2);

insert into parted values (1, 1, 'uno uno v5');

update parted set a = 2;

select cast(tableoid as REGCLASS), * from parted;

create or replace function parted_trigfunc2()
returns trigger
language "plpgsql"
as '
begin
  new.a = new.a + 1;
  return new;
end;
';

create TRIGGER t2 before update on parted for EACH ROW EXECUTE FUNCTION parted_trigfunc2();

truncate parted;

insert into parted values (1, 1, 'uno uno v6');

create table parted_3 partition of parted for values in (3);

update parted set a = a + 1;

select cast(tableoid as REGCLASS), * from parted;

update parted set a = 0;

select cast(tableoid as REGCLASS), * from parted;

drop TABLE "parted";

create table parted (
  a INT,
  b INT,
  c TEXT
)
partition by LIST((a + b));

create or replace function parted_trigfunc()
returns trigger
language "plpgsql"
as '
begin
  new.a = new.a + new.b;
  return new;
end;
';

create table parted_1 partition of parted for values in (1, 2);

create table parted_2 partition of parted for values in (3, 4);

create TRIGGER t before insert or update on parted for EACH ROW EXECUTE FUNCTION parted_trigfunc();

insert into parted values (0, 1, 'zero win');

insert into parted values (1, 1, 'one fail');

insert into parted values (1, 2, 'two fail');

select * from parted;

drop TABLE "parted";

drop FUNCTION parted_trigfunc();

create table parted_constr_ancestor (
  a INT,
  b TEXT
)
partition by range(b);

create table parted_constr (
  a INT,
  b TEXT
)
partition by range(b);

alter table parted_constr_ancestor
  ATTACH partition
  parted_constr for values from ('aaaa') to ('zzzz');

create table parted1_constr (
  a INT,
  b TEXT
);

alter table parted_constr
  ATTACH partition
  parted1_constr
  for values from ('aaaa') to ('bbbb');

create CONSTRAINT TRIGGER parted_trig
  after insert
  on parted_constr_ancestor
  DEFERRABLE
  for EACH ROW
  EXECUTE FUNCTION trigger_notice_ab();

begin;

insert into parted_constr values (1, 'aardvark');

insert into parted1_constr values (2, 'aardwolf');

insert into parted_constr_ancestor values (3, 'aasvogel');

commit;

begin;

set CONSTRAINTS parted_trig DEFERRED;

insert into parted_constr values (1, 'aardvark');

insert into parted1_constr values (2, 'aardwolf'), (3, 'aasvogel');

commit;

drop TABLE "parted_constr_ancestor";

drop FUNCTION bark(TEXT);

create table parted_trigger (
  a INT,
  b TEXT
)
partition by range(a);

create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);

create table parted_trigger_2 (
  drp INT,
  a INT,
  b TEXT
);

alter table parted_trigger_2
  drop column drp;

alter table parted_trigger
  ATTACH partition
  parted_trigger_2 for values from (1000) to (2000);

create TRIGGER parted_trigger
  after update
  on parted_trigger
  for EACH ROW
  when (new.a % 2 = 1 and length(old.b) >= 2)
  EXECUTE FUNCTION trigger_notice_ab();

create table parted_trigger_3 (
  b TEXT,
  a INT
)
partition by range((length(b)));

create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);

create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);

alter table parted_trigger
  ATTACH partition
  parted_trigger_3 for values from (2000) to (3000);

insert into parted_trigger
values
  (0, 'a'),
  (1, 'bbb'),
  (2, 'bcd'),
  (3, 'c'),
  (1000, 'c'),
  (1001, 'ddd'),
  (1002, 'efg'),
  (1003, 'f'),
  (2000, 'e'),
  (2001, 'fff'),
  (2002, 'ghi'),
  (2003, 'h');

update parted_trigger set a = a + 2;

drop TABLE "parted_trigger";

create table parted_referenced (a INT);

create table unparted_trigger (
  a INT,
  b TEXT
);

create table parted_trigger (
  a INT,
  b TEXT
)
partition by range(a);

create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);

create table parted_trigger_2 (
  drp INT,
  a INT,
  b TEXT
);

alter table parted_trigger_2
  drop column drp;

alter table parted_trigger
  ATTACH partition
  parted_trigger_2 for values from (1000) to (2000);

create CONSTRAINT TRIGGER parted_trigger
  after update
  on parted_trigger
  from parted_referenced
  for EACH ROW
  EXECUTE FUNCTION trigger_notice_ab();

create CONSTRAINT TRIGGER parted_trigger
  after update
  on unparted_trigger
  from parted_referenced
  for EACH ROW
  EXECUTE FUNCTION trigger_notice_ab();

create table parted_trigger_3 (
  b TEXT,
  a INT
)
partition by range((length(b)));

create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);

create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);

alter table parted_trigger
  ATTACH partition
  parted_trigger_3 for values from (2000) to (3000);

select
  tgname,
  conname,
  cast(t.tgrelid as REGCLASS),
  cast(t.tgconstrrelid as REGCLASS),
  cast(c.conrelid as REGCLASS),
  cast(c.confrelid as REGCLASS)
from
  pg_trigger as t
  inner join
    pg_constraint as c
  on t.tgconstraint = c.oid
where
  tgname = 'parted_trigger'
order by cast(cast(t.tgrelid as REGCLASS) as TEXT);

drop TABLE "parted_referenced", "parted_trigger", "unparted_trigger";

create table parted_trigger (
  a INT,
  b TEXT
)
partition by range(a);

create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);

create table parted_trigger_2 (
  drp INT,
  a INT,
  b TEXT
);

alter table parted_trigger_2
  drop column drp;

alter table parted_trigger
  ATTACH partition
  parted_trigger_2 for values from (1000) to (2000);

create TRIGGER parted_trigger
  after update of b
  on parted_trigger
  for EACH ROW
  EXECUTE FUNCTION trigger_notice_ab();

create table parted_trigger_3 (
  b TEXT,
  a INT
)
partition by range((length(b)));

create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (4);

create table parted_trigger_3_2 partition of parted_trigger_3 for values from (4) to (8);

alter table parted_trigger
  ATTACH partition
  parted_trigger_3 for values from (2000) to (3000);

insert into parted_trigger values (0, 'a'), (1000, 'c'), (2000, 'e'), (2001, 'eeee');

update parted_trigger set a = a + 2;

update parted_trigger set b = b || 'b';

drop TABLE "parted_trigger";

drop FUNCTION trigger_notice_ab();

create table trg_clone (a INT)
partition by range(a);

create table trg_clone1 partition of trg_clone for values from (0) to (1000);

alter table trg_clone
  add constraint "uniq" unique (a) deferrable;

create table trg_clone2 partition of trg_clone for values from (1000) to (2000);

create table trg_clone3
partition of trg_clone
for values from (2000) to (3000)
partition by range(a);

create table trg_clone_3_3 partition of trg_clone3 for values from (2000) to (2100);

select
  cast(tgrelid as REGCLASS),
  COUNT(*)
from
  pg_trigger
where
  cast(tgrelid as REGCLASS)
  in (
    'trg_clone',
    'trg_clone1',
    'trg_clone2',
    'trg_clone3',
    'trg_clone_3_3'
  )
group by cast(tgrelid as REGCLASS)
order by cast(tgrelid as REGCLASS);

drop TABLE "trg_clone";

create table parent (a INT);

create table child1 ()
inherits (parent);

create function trig_nothing()
returns trigger
language "plpgsql"
as ' begin return null; end ';

create TRIGGER tg after insert on parent for EACH ROW EXECUTE FUNCTION trig_nothing();

create TRIGGER tg after insert on child1 for EACH ROW EXECUTE FUNCTION trig_nothing();

alter table parent
  disable trigger tg;

select
  cast(tgrelid as REGCLASS),
  tgname,
  tgenabled
from
  pg_trigger
where
  tgrelid
  in (
    cast('parent' as REGCLASS),
    cast('child1' as REGCLASS)
  )
order by cast(cast(tgrelid as REGCLASS) as TEXT);

alter table only parent
  enable ALWAYS trigger tg;

select
  cast(tgrelid as REGCLASS),
  tgname,
  tgenabled
from
  pg_trigger
where
  tgrelid
  in (
    cast('parent' as REGCLASS),
    cast('child1' as REGCLASS)
  )
order by cast(cast(tgrelid as REGCLASS) as TEXT);

drop TABLE "parent", "child1";

create table parent (a INT)
partition by LIST(a);

create table child1 partition of parent for values in (1);

create TRIGGER tg after insert on parent for EACH ROW EXECUTE FUNCTION trig_nothing();

create TRIGGER tg_stmt after insert on parent for EACH STATEMENT EXECUTE FUNCTION trig_nothing();

select
  cast(tgrelid as REGCLASS),
  tgname,
  tgenabled
from
  pg_trigger
where
  tgrelid
  in (
    cast('parent' as REGCLASS),
    cast('child1' as REGCLASS)
  )
order by cast(cast(tgrelid as REGCLASS) as TEXT),
  tgname;

alter table only parent
  enable ALWAYS trigger tg;

alter table parent
  enable ALWAYS trigger tg_stmt;

select
  cast(tgrelid as REGCLASS),
  tgname,
  tgenabled
from
  pg_trigger
where
  tgrelid
  in (
    cast('parent' as REGCLASS),
    cast('child1' as REGCLASS)
  )
order by cast(cast(tgrelid as REGCLASS) as TEXT),
  tgname;

alter table parent
  enable ALWAYS trigger tg;

select
  cast(tgrelid as REGCLASS),
  tgname,
  tgenabled
from
  pg_trigger
where
  tgrelid
  in (
    cast('parent' as REGCLASS),
    cast('child1' as REGCLASS)
  )
order by cast(cast(tgrelid as REGCLASS) as TEXT),
  tgname;

alter table parent
  disable trigger user;

select
  cast(tgrelid as REGCLASS),
  tgname,
  tgenabled
from
  pg_trigger
where
  tgrelid
  in (
    cast('parent' as REGCLASS),
    cast('child1' as REGCLASS)
  )
order by cast(cast(tgrelid as REGCLASS) as TEXT),
  tgname;

drop TABLE "parent", "child1";

create table parent (
  a INT primary key,
  f INT references parent
)
partition by LIST(a);

create table child1 partition of parent for values in (1);

select
  cast(tgrelid as REGCLASS),
  rtrim(tgname, '0123456789') as tgname,
  cast(tgfoid as REGPROC),
  tgenabled
from
  pg_trigger
where
  tgrelid
  in (
    cast('parent' as REGCLASS),
    cast('child1' as REGCLASS)
  )
order by cast(cast(tgrelid as REGCLASS) as TEXT),
  tgfoid;

alter table parent
  disable trigger all;

select
  cast(tgrelid as REGCLASS),
  rtrim(tgname, '0123456789') as tgname,
  cast(tgfoid as REGPROC),
  tgenabled
from
  pg_trigger
where
  tgrelid
  in (
    cast('parent' as REGCLASS),
    cast('child1' as REGCLASS)
  )
order by cast(cast(tgrelid as REGCLASS) as TEXT),
  tgfoid;

drop TABLE "parent", "child1";

create table trgfire (i INT)
partition by range(i);

create table trgfire1 partition of trgfire for values from (1) to (10);

create or replace function tgf()
returns trigger
language "plpgsql"
as ' begin raise exception ''except''; end ';

create TRIGGER tg after insert on trgfire for EACH ROW EXECUTE FUNCTION tgf();

insert into trgfire values (1);

alter table trgfire
  disable trigger tg;

insert into trgfire values (1);

create table trgfire2 partition of trgfire for values from (10) to (20);

insert into trgfire values (11);

create table trgfire3 (like trgfire);

alter table trgfire
  ATTACH partition
  trgfire3 for values from (20) to (30);

insert into trgfire values (21);

create table trgfire4 partition of trgfire for values from (30) to (40) partition by LIST(i);

create table trgfire4_30 partition of trgfire4 for values in (30);

insert into trgfire values (30);

create table trgfire5 (like trgfire)
partition by LIST(i);

create table trgfire5_40 partition of trgfire5 for values in (40);

alter table trgfire
  ATTACH partition
  trgfire5 for values from (40) to (50);

insert into trgfire values (40);

select
  cast(tgrelid as REGCLASS),
  tgenabled
from
  pg_trigger
where
  cast(tgrelid as REGCLASS) in
  (
    select
      oid
    from
      pg_class
    where
      relname like 'trgfire%'
  )
order by cast(cast(tgrelid as REGCLASS) as TEXT);

alter table trgfire
  enable trigger tg;

insert into trgfire values (1);

insert into trgfire values (11);

insert into trgfire values (21);

insert into trgfire values (30);

insert into trgfire values (40);

drop TABLE "trgfire";

drop FUNCTION tgf();

create or replace function dump_insert()
returns trigger
language "plpgsql"
as '
  begin
    raise notice ''trigger = %, new table = %'',
                 TG_NAME,
                 (select string_agg(new_table::text, '', '' order by a) from new_table);
    return null;
  end;
';

create or replace function dump_update()
returns trigger
language "plpgsql"
as '
  begin
    raise notice ''trigger = %, old table = %, new table = %'',
                 TG_NAME,
                 (select string_agg(old_table::text, '', '' order by a) from old_table),
                 (select string_agg(new_table::text, '', '' order by a) from new_table);
    return null;
  end;
';

create or replace function dump_delete()
returns trigger
language "plpgsql"
as '
  begin
    raise notice ''trigger = %, old table = %'',
                 TG_NAME,
                 (select string_agg(old_table::text, '', '' order by a) from old_table);
    return null;
  end;
';

create table parent (
  a TEXT,
  b INT
)
partition by LIST(a);

create table child1 partition of parent for values in ('AAA');

create table child2 (
  x INT,
  a TEXT,
  b INT
);

alter table child2
  drop column x;

alter table parent
  ATTACH partition
  child2 for values in ('BBB');

create table child3 (
  b INT,
  a TEXT
);

alter table parent
  ATTACH partition
  child3 for values in ('CCC');

create TRIGGER parent_insert_trig
  after insert
  on parent
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER parent_update_trig
  after update
  on parent
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER parent_delete_trig
  after delete
  on parent
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

create TRIGGER child1_insert_trig
  after insert
  on child1
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER child1_update_trig
  after update
  on child1
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER child1_delete_trig
  after delete
  on child1
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

create TRIGGER child2_insert_trig
  after insert
  on child2
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER child2_update_trig
  after update
  on child2
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER child2_delete_trig
  after delete
  on child2
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

create TRIGGER child3_insert_trig
  after insert
  on child3
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER child3_update_trig
  after update
  on child3
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER child3_delete_trig
  after delete
  on child3
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

select
  trigger_name,
  event_manipulation,
  event_object_schema,
  event_object_table,
  action_order,
  action_condition,
  action_orientation,
  action_timing,
  action_reference_old_table,
  action_reference_new_table
from
  information_schema.triggers
where
  event_object_table
  in (
    'parent', 'child1', 'child2', 'child3'
  )
order by trigger_name collate "C",
  2;

insert into child1 values ('AAA', 42);

insert into child2 values ('BBB', 42);

insert into child3 values (42, 'CCC');

update parent set b = b + 1;

delete from parent;

insert into parent values ('AAA', 42);

insert into parent values ('BBB', 42);

insert into parent values ('CCC', 42);

delete from child1;

delete from child2;

delete from child3;

copy parent (a, b) from stdout;

alter table parent
  DETACH partition
  child1;

alter table parent
  ATTACH partition
  child1 for values in ('AAA');

drop TRIGGER "child1_insert_trig" on "child1";

drop TRIGGER "child1_update_trig" on "child1";

drop TRIGGER "child1_delete_trig" on "child1";

drop TRIGGER "child2_insert_trig" on "child2";

drop TRIGGER "child2_update_trig" on "child2";

drop TRIGGER "child2_delete_trig" on "child2";

drop TRIGGER "child3_insert_trig" on "child3";

drop TRIGGER "child3_update_trig" on "child3";

drop TRIGGER "child3_delete_trig" on "child3";

delete from parent;

copy parent (a, b) from stdout;

create or replace function intercept_insert()
returns trigger
language "plpgsql"
as '
  begin
    new.b = new.b + 1000;
    return new;
  end;
';

create TRIGGER intercept_insert_child3
  before insert
  on child3
  for EACH ROW
  EXECUTE FUNCTION intercept_insert();

insert into parent values ('AAA', 42), ('BBB', 42), ('CCC', 66);

copy parent (a, b) from stdout;

drop TABLE "child1", "child2", "child3", "parent";

drop FUNCTION intercept_insert();

create table parent (
  a TEXT,
  b INT
)
partition by LIST(a);

create table child partition of parent for values in ('AAA');

create TRIGGER child_row_trig
  after insert
  on child
  REFERENCING new table as new_table
  for EACH ROW
  EXECUTE FUNCTION dump_insert();

alter table parent
  DETACH partition
  child;

create TRIGGER child_row_trig
  after insert
  on child
  REFERENCING new table as new_table
  for EACH ROW
  EXECUTE FUNCTION dump_insert();

alter table parent
  ATTACH partition
  child for values in ('AAA');

drop TRIGGER "child_row_trig" on "child";

alter table parent
  ATTACH partition
  child for values in ('AAA');

drop TABLE "child", "parent";

create or replace function dump_update_new()
returns trigger
language "plpgsql"
as '
  begin
    raise notice ''trigger = %, new table = %'', TG_NAME,
                 (select string_agg(new_table::text, '', '' order by a) from new_table);
    return null;
  end;
';

create or replace function dump_update_old()
returns trigger
language "plpgsql"
as '
  begin
    raise notice ''trigger = %, old table = %'', TG_NAME,
                 (select string_agg(old_table::text, '', '' order by a) from old_table);
    return null;
  end;
';

create table trans_tab_parent (a TEXT)
partition by LIST(a);

create table trans_tab_child1 partition of trans_tab_parent for values in ('AAA1', 'AAA2');

create table trans_tab_child2 partition of trans_tab_parent for values in ('BBB1', 'BBB2');

create TRIGGER trans_tab_parent_update_trig
  after update
  on trans_tab_parent
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update_old();

create TRIGGER trans_tab_parent_insert_trig
  after insert
  on trans_tab_parent
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER trans_tab_parent_delete_trig
  after delete
  on trans_tab_parent
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

insert into trans_tab_parent values ('AAA1'), ('BBB1');

update trans_tab_parent set a = 'BBB2' where a = 'AAA1';

drop TRIGGER "trans_tab_parent_update_trig" on "trans_tab_parent";

create TRIGGER trans_tab_parent_update_trig
  after update
  on trans_tab_parent
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update_new();

update trans_tab_parent set a = 'AAA2' where a = 'BBB1';

delete from trans_tab_parent;

drop TABLE "trans_tab_parent", "trans_tab_child1", "trans_tab_child2";

drop FUNCTION dump_update_new, dump_update_old;

create table parent (
  a TEXT,
  b INT
);

create table child1 ()
inherits (parent);

create table child2 (
  b INT,
  a TEXT
);

alter table child2
  INHERIT parent;

create table child3 (c TEXT)
inherits (parent);

create TRIGGER parent_insert_trig
  after insert
  on parent
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER parent_update_trig
  after update
  on parent
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER parent_delete_trig
  after delete
  on parent
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

create TRIGGER child1_insert_trig
  after insert
  on child1
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER child1_update_trig
  after update
  on child1
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER child1_delete_trig
  after delete
  on child1
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

create TRIGGER child2_insert_trig
  after insert
  on child2
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER child2_update_trig
  after update
  on child2
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER child2_delete_trig
  after delete
  on child2
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

create TRIGGER child3_insert_trig
  after insert
  on child3
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER child3_update_trig
  after update
  on child3
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER child3_delete_trig
  after delete
  on child3
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

insert into child1 values ('AAA', 42);

insert into child2 values (42, 'BBB');

insert into child3 values ('CCC', 42, 'foo');

update parent set b = b + 1;

delete from parent;

insert into child1 values ('AAA', 42);

insert into child2 values (42, 'BBB');

insert into child3 values ('CCC', 42, 'foo');

delete from child1;

delete from child2;

delete from child3;

copy parent (a, b) from stdout;

create index on parent using btree (b);

copy parent (a, b) from stdout;

alter table child1
  NO INHERIT parent;

alter table child1
  INHERIT parent;

drop TRIGGER "child1_insert_trig" on "child1";

drop TRIGGER "child1_update_trig" on "child1";

drop TRIGGER "child1_delete_trig" on "child1";

drop TRIGGER "child2_insert_trig" on "child2";

drop TRIGGER "child2_update_trig" on "child2";

drop TRIGGER "child2_delete_trig" on "child2";

drop TRIGGER "child3_insert_trig" on "child3";

drop TRIGGER "child3_update_trig" on "child3";

drop TRIGGER "child3_delete_trig" on "child3";

delete from parent;

drop TABLE "child1", "child2", "child3", "parent";

create table parent (
  a TEXT,
  b INT
);

create table child ()
inherits (parent);

create TRIGGER child_row_trig
  after insert
  on child
  REFERENCING new table as new_table
  for EACH ROW
  EXECUTE FUNCTION dump_insert();

alter table child
  NO INHERIT parent;

create TRIGGER child_row_trig
  after insert
  on child
  REFERENCING new table as new_table
  for EACH ROW
  EXECUTE FUNCTION dump_insert();

alter table child
  INHERIT parent;

drop TRIGGER "child_row_trig" on "child";

alter table child
  INHERIT parent;

drop TABLE "child", "parent";

create table table1 (a INT);

create table table2 (a TEXT);

create TRIGGER table1_trig
  after insert
  on table1
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER table2_trig
  after insert
  on table2
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

with wcte as (insert into table1 values (42)) insert into table2 values ('hello world');

with wcte as (insert into table1 values (43)) insert into table1 values (44);

select * from table1;

select * from table2;

drop TABLE "table1";

drop TABLE "table2";

create table my_table (
  a INT primary key,
  b TEXT
);

create TRIGGER my_table_insert_trig
  after insert
  on my_table
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER my_table_update_trig
  after update
  on my_table
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

insert into my_table
values (1, 'AAA'), (2, 'BBB')
on conflict
(a)
do
update
set b = my_table.b || ':' || excluded.b;

insert into my_table
values
  (1, 'AAA'),
  (2, 'BBB'),
  (3, 'CCC'),
  (4, 'DDD')
on conflict
(a)
do
update
set b = my_table.b || ':' || excluded.b;

insert into my_table
values (3, 'CCC'), (4, 'DDD')
on conflict
(a)
do
update
set b = my_table.b || ':' || excluded.b;

create table iocdu_tt_parted (
  a INT primary key,
  b TEXT
)
partition by LIST(a);

create table iocdu_tt_parted1 partition of iocdu_tt_parted for values in (1);

create table iocdu_tt_parted2 partition of iocdu_tt_parted for values in (2);

create table iocdu_tt_parted3 partition of iocdu_tt_parted for values in (3);

create table iocdu_tt_parted4 partition of iocdu_tt_parted for values in (4);

create TRIGGER iocdu_tt_parted_insert_trig
  after insert
  on iocdu_tt_parted
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER iocdu_tt_parted_update_trig
  after update
  on iocdu_tt_parted
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

insert into iocdu_tt_parted
values (1, 'AAA'), (2, 'BBB')
on conflict
(a)
do
update
set b = iocdu_tt_parted.b || ':' || excluded.b;

insert into iocdu_tt_parted
values
  (1, 'AAA'),
  (2, 'BBB'),
  (3, 'CCC'),
  (4, 'DDD')
on conflict
(a)
do
update
set b = iocdu_tt_parted.b || ':' || excluded.b;

insert into iocdu_tt_parted
values (3, 'CCC'), (4, 'DDD')
on conflict
(a)
do
update
set b = iocdu_tt_parted.b || ':' || excluded.b;

drop TABLE "iocdu_tt_parted";

create TRIGGER my_table_multievent_trig
  after insert or update
  on my_table
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER my_table_col_update_trig
  after update of b
  on my_table
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

drop TABLE "my_table";

create table my_table (a INT);

create function make_bogus_matview()
returns trigger
as ' begin
  create materialized view transition_test_mv as select * from new_table;
  return new;
end '
language "plpgsql";

create TRIGGER make_bogus_matview
  after insert
  on my_table
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION make_bogus_matview();

insert into my_table values (42);

drop TABLE "my_table";

drop FUNCTION make_bogus_matview();

create table refd_table (
  a INT primary key,
  b TEXT
);

create table trig_table (
  a INT,
  b TEXT,
  foreign key
  (a)
  references refd_table
  on DELETE cascade
  on UPDATE cascade
);

create TRIGGER trig_table_before_trig
  before insert or delete or update
  on trig_table
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_func(trig_table);

create TRIGGER trig_table_insert_trig
  after insert
  on trig_table
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER trig_table_update_trig
  after update
  on trig_table
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER trig_table_delete_trig
  after delete
  on trig_table
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

insert into refd_table values (1, 'one'), (2, 'two'), (3, 'three');

insert into trig_table
values
  (1, 'one a'),
  (1, 'one b'),
  (2, 'two a'),
  (2, 'two b'),
  (3, 'three a'),
  (3, 'three b');

update refd_table set a = 11 where b = 'one';

select * from trig_table;

delete from refd_table where length(b) = 3;

select * from trig_table;

drop TABLE "refd_table", "trig_table";

create table refd_table (id INT primary key);

create table trig_table (fk INT references refd_table initially deferred);

begin;

insert into trig_table values (1);

drop TABLE "refd_table" cascade;

commit;

drop TABLE "trig_table";

create table self_ref (
  a INT primary key,
  b INT references self_ref (a) on DELETE cascade
);

create TRIGGER self_ref_before_trig
  before delete
  on self_ref
  for EACH STATEMENT
  EXECUTE FUNCTION trigger_func(self_ref);

create TRIGGER self_ref_r_trig
  after delete
  on self_ref
  REFERENCING old table as old_table
  for EACH ROW
  EXECUTE FUNCTION dump_delete();

create TRIGGER self_ref_s_trig
  after delete
  on self_ref
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

insert into self_ref values (1, null), (2, 1), (3, 2);

delete from self_ref where a = 1;

drop TRIGGER "self_ref_r_trig" on "self_ref";

insert into self_ref values (1, null), (2, 1), (3, 2), (4, 3);

delete from self_ref where a = 1;

drop TABLE "self_ref";

create table merge_target_table (
  a INT primary key,
  b TEXT
);

create TRIGGER merge_target_table_insert_trig
  after insert
  on merge_target_table
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_insert();

create TRIGGER merge_target_table_update_trig
  after update
  on merge_target_table
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_update();

create TRIGGER merge_target_table_delete_trig
  after delete
  on merge_target_table
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION dump_delete();

create table merge_source_table (
  a INT,
  b TEXT
);

insert into merge_source_table
values
  (1, 'initial1'),
  (2, 'initial2'),
  (3, 'initial3'),
  (4, 'initial4');

drop TABLE "merge_source_table", "merge_target_table";

drop FUNCTION dump_insert();

drop FUNCTION dump_update();

drop FUNCTION dump_delete();

create table my_table (id INT);

create function funca()
returns trigger
as '
begin
  raise notice ''hello from funcA'';
  return null;
end; '
language "plpgsql";

create function funcb()
returns trigger
as '
begin
  raise notice ''hello from funcB'';
  return null;
end; '
language "plpgsql";

create TRIGGER my_trig after insert on my_table for EACH ROW EXECUTE FUNCTION funca();

create TRIGGER my_trig before insert on my_table for EACH ROW EXECUTE FUNCTION funcb();

insert into my_table values (1);

create or REPLACE TRIGGER my_trig before insert on my_table for EACH ROW EXECUTE FUNCTION funcb();

insert into my_table values (2);

select * from my_table;

drop TABLE "my_table";

create table parted_trig (a INT)
partition by range(a);

create table parted_trig_1
partition of parted_trig
for values from (0) to (1000)
partition by range(a);

create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100);

create table parted_trig_2 partition of parted_trig for values from (1000) to (2000);

create table default_parted_trig partition of parted_trig default;

create or REPLACE TRIGGER my_trig after insert on parted_trig for EACH ROW EXECUTE FUNCTION funca();

insert into parted_trig (a) values (50);

create or REPLACE TRIGGER my_trig after insert on parted_trig for EACH ROW EXECUTE FUNCTION funcb();

insert into parted_trig (a) values (50);

create or REPLACE TRIGGER my_trig after insert on parted_trig for EACH ROW EXECUTE FUNCTION funca();

insert into parted_trig (a) values (50);

create or REPLACE TRIGGER my_trig
  after insert
  on parted_trig_1
  for EACH ROW
  EXECUTE FUNCTION funcb();

insert into parted_trig (a) values (50);

drop TRIGGER "my_trig" on "parted_trig";

insert into parted_trig (a) values (50);

create TRIGGER my_trig after insert on parted_trig_1 for EACH ROW EXECUTE FUNCTION funca();

insert into parted_trig (a) values (50);

create TRIGGER my_trig after insert on parted_trig for EACH ROW EXECUTE FUNCTION funcb();

insert into parted_trig (a) values (50);

create or REPLACE TRIGGER my_trig after insert on parted_trig for EACH ROW EXECUTE FUNCTION funcb();

insert into parted_trig (a) values (50);

drop TABLE "parted_trig";

drop FUNCTION funca();

drop FUNCTION funcb();

create table trigger_parted (a INT primary key)
partition by LIST(a);

create function trigger_parted_trigfunc()
returns trigger
language "plpgsql"
as ' begin end; ';

create TRIGGER aft_row
  after insert or update
  on trigger_parted
  for EACH ROW
  EXECUTE FUNCTION trigger_parted_trigfunc();

create table trigger_parted_p1 partition of trigger_parted for values in (1) partition by LIST(a);

create table trigger_parted_p1_1 partition of trigger_parted_p1 for values in (1);

create table trigger_parted_p2 partition of trigger_parted for values in (2) partition by LIST(a);

create table trigger_parted_p2_2 partition of trigger_parted_p2 for values in (2);

alter table only trigger_parted_p2
  disable trigger aft_row;

alter table trigger_parted_p2_2
  enable ALWAYS trigger aft_row;

create table convslot_test_parent (col1 TEXT primary key);

create table convslot_test_child (
  col1 TEXT primary key,
  foreign key
  (col1)
  references convslot_test_parent (col1)
  on DELETE cascade
  on UPDATE cascade
);

alter table convslot_test_child
  add column col2 TEXT not null default 'tutu';

insert into convslot_test_parent (col1) values ('1');

insert into convslot_test_child (col1) values ('1');

insert into convslot_test_parent (col1) values ('3');

insert into convslot_test_child (col1) values ('3');

create function convslot_trig1()
returns trigger
language "plpgsql"
as '
begin
raise notice ''trigger = %, old_table = %'',
          TG_NAME,
          (select string_agg(old_table::text, '', '' order by col1) from old_table);
return null;
end; ';

create function convslot_trig2()
returns trigger
language "plpgsql"
as '
begin
raise notice ''trigger = %, new table = %'',
          TG_NAME,
          (select string_agg(new_table::text, '', '' order by col1) from new_table);
return null;
end; ';

create TRIGGER but_trigger
  after update
  on convslot_test_child
  REFERENCING new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION convslot_trig2();

update convslot_test_parent set col1 = col1 || '1';

create function convslot_trig3()
returns trigger
language "plpgsql"
as '
begin
raise notice ''trigger = %, old_table = %, new table = %'',
          TG_NAME,
          (select string_agg(old_table::text, '', '' order by col1) from old_table),
          (select string_agg(new_table::text, '', '' order by col1) from new_table);
return null;
end; ';

create TRIGGER but_trigger2
  after update
  on convslot_test_child
  REFERENCING old table as old_table
  new table as new_table
  for EACH STATEMENT
  EXECUTE FUNCTION convslot_trig3();

update convslot_test_parent set col1 = col1 || '1';

create TRIGGER bdt_trigger
  after delete
  on convslot_test_child
  REFERENCING old table as old_table
  for EACH STATEMENT
  EXECUTE FUNCTION convslot_trig1();

delete from convslot_test_parent;

drop TABLE "convslot_test_child", "convslot_test_parent";

drop FUNCTION convslot_trig1();

drop FUNCTION convslot_trig2();

drop FUNCTION convslot_trig3();

create table convslot_test_parent (
  id INT primary key,
  val INT
)
partition by range(id);

create table convslot_test_part (
  val INT,
  id INT not null
);

alter table convslot_test_parent
  ATTACH partition
  convslot_test_part for values from (1) to (1000);

create function convslot_trig4()
returns trigger
as 'begin raise exception ''BOOM!''; end'
language "plpgsql";

create TRIGGER convslot_test_parent_update
  after update
  on convslot_test_parent
  REFERENCING old table as old_rows
  new table as new_rows
  for EACH STATEMENT
  EXECUTE FUNCTION convslot_trig4();

insert into convslot_test_parent (id, val) values (1, 2);

begin;

savepoint svp;

update convslot_test_parent set val = 3;

rollback to savepoint svp;

rollback;

drop TABLE "convslot_test_parent";

drop FUNCTION convslot_trig4();

create table grandparent (
  id INT,
  primary key (id)
)
partition by range(id);

create table middle partition of grandparent for values from (1) to (10) partition by range(id);

create table chi partition of middle for values from (1) to (5);

create table cho partition of middle for values from (6) to (10);

create function f()
returns trigger
as ' begin return new; end; '
language "plpgsql";

create TRIGGER a after insert on grandparent for EACH ROW EXECUTE FUNCTION f();

alter trigger a on grandparent rename to b;

select
  cast(tgrelid as REGCLASS),
  tgname,
  (
    select
      tgname
    from
      pg_trigger as tr
    where
      tr.oid = pg_trigger.tgparentid
  )
  as parent_tgname
from
  pg_trigger
where
  tgrelid in
  (
    select relid from pg_partition_tree('grandparent')
  )
order by tgname,
  cast(cast(tgrelid as REGCLASS) as TEXT) collate "C";

alter trigger b on middle rename to c;

create TRIGGER c after insert on middle for EACH ROW EXECUTE FUNCTION f();

alter trigger b on grandparent rename to c;

create TRIGGER p after insert on grandparent for EACH STATEMENT EXECUTE FUNCTION f();

create TRIGGER p after insert on middle for EACH STATEMENT EXECUTE FUNCTION f();

alter trigger p on grandparent rename to q;

select
  cast(tgrelid as REGCLASS),
  tgname,
  (
    select
      tgname
    from
      pg_trigger as tr
    where
      tr.oid = pg_trigger.tgparentid
  )
  as parent_tgname
from
  pg_trigger
where
  tgrelid in
  (
    select relid from pg_partition_tree('grandparent')
  )
order by tgname,
  cast(cast(tgrelid as REGCLASS) as TEXT) collate "C";

drop TABLE "grandparent";

create table parent (a INT);

create table child ()
inherits (parent);

create TRIGGER parenttrig after insert on parent for EACH ROW EXECUTE FUNCTION f();

create TRIGGER parenttrig after insert on child for EACH ROW EXECUTE FUNCTION f();

alter trigger parenttrig on parent rename to anothertrig;

drop TABLE "parent", "child";

drop FUNCTION f();

create role regress_caller;

create role regress_fn_owner;

create function whoami()
returns trigger
language "plpgsql"
as '
begin
  raise notice ''I am %'', current_user;
  return null;
end;
';

alter function whoami() owner to regress_fn_owner;

create table defer_trig (id INT);

grant INSERT on table defer_trig to PUBLIC;

create CONSTRAINT TRIGGER whoami
  after insert
  on defer_trig
  DEFERRABLE
  INITIALLY DEFERRED
  for EACH ROW
  EXECUTE FUNCTION whoami();

begin;

set role to regress_caller;

insert into defer_trig values (1);

reset role;

set role to regress_fn_owner;

insert into defer_trig values (2);

reset role;

commit;

alter FUNCTION whoami() security DEFINER;

begin;

set role to regress_caller;

insert into defer_trig values (3);

reset role;

commit;

alter FUNCTION whoami() security INVOKER;

create or replace function whoami()
returns trigger
language "plpgsql"
as '
begin
  raise notice ''I am %'', current_user;
  perform 1 / 0;
  return null;
end;
';

begin;

set role to regress_caller;

insert into defer_trig values (4);

reset role;

commit;

select current_user = session_user;

drop TABLE "defer_trig";

drop FUNCTION whoami();

drop role regress_fn_owner;

drop role regress_caller;
