---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/brin.sql
snapshot_kind: text
---
create table brintest (
  byteacol bytea,
  charcol char,
  namecol name,
  int8col bigint,
  int2col smallint,
  int4col int,
  textcol text,
  oidcol oid,
  tidcol tid,
  float4col real,
  float8col double precision,
  macaddrcol macaddr,
  inetcol inet,
  cidrcol cidr,
  bpcharcol char(1),
  datecol date,
  timecol time,
  timestampcol timestamp,
  timestamptzcol timestamp with time zone,
  intervalcol interval,
  timetzcol time with time zone,
  bitcol bit(10),
  varbitcol bit varying(16),
  numericcol numeric,
  uuidcol uuid,
  int4rangecol int4range,
  lsncol pg_lsn,
  boxcol box
)
with (fillfactor = 10, autovacuum_enabled = off);

insert into brintest
select
  cast(repeat(stringu1, 8) as bytea),
  cast(substr(stringu1, 1, 1) as char),
  cast(stringu1 as name),
  142857 * tenthous,
  thousand,
  twothousand,
  repeat(stringu1, 8),
  cast(unique1 as oid),
  cast(format('(%s,%s)', tenthous, twenty) as tid),
  (four + 1.0) / (hundred + 1),
  cast(odd as double precision) / (tenthous + 1),
  cast(format(
    '%s:00:%s:00:%s:00',
    to_hex(odd),
    to_hex(even),
    to_hex(hundred)
  )
  as macaddr),
  cast('10.2.3.4/24' as inet) + tenthous,
  cast('10.2.3/24' as cidr) + tenthous,
  cast(substr(stringu1, 1, 1) as char),
  cast('1995-08-15' as date) + tenthous,
  cast('01:20:30' as time) +
  thousand * cast('18.5 second' as interval),
  cast('1942-07-23 03:05:09' as timestamp) +
  tenthous * cast('36.38 hours' as interval),
  cast('1972-10-10 03:00'
  as timestamp with time zone) +
  thousand * cast('1 hour' as interval),
  justify_days(
    justify_hours(
      tenthous * cast('12 minutes' as interval)
    )
  ),
  cast('01:30:20+02' as time with time zone) +
  hundred * cast('15 seconds' as interval),
  cast(thousand as bit(10)),
  cast(cast(tenthous as bit(16)) as bit varying),
  cast(tenthous as numeric(36, 30)) * fivethous *
  even /
  (hundred + 1),
  cast(format(
    '%s%s-%s-%s-%s-%s%s%s',
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000')
  )
  as uuid),
  int4range(thousand, twothousand),
  cast(format('%s/%s%s', odd, even, tenthous)
  as pg_lsn),
  box(
    point(odd, even),
    point(thousand, twothousand)
  )
from
  tenk1
order by unique2
limit 100;

insert into brintest (inetcol, cidrcol, int4rangecol)
select
  cast('fe80::6e40:8ff:fea9:8c46' as inet) +
  tenthous,
  cast('fe80::6e40:8ff:fea9:8c46' as cidr) +
  tenthous,
  cast('empty' as int4range)
from
  tenk1
order by thousand,
  tenthous
limit 25;

create index "brinidx"
on brintest
using brin
(
  byteacol,
  charcol,
  namecol,
  int8col,
  int2col,
  int4col,
  textcol,
  oidcol,
  tidcol,
  float4col,
  float8col,
  macaddrcol,
  inetcol inet_inclusion_ops,
  inetcol inet_minmax_ops,
  cidrcol inet_inclusion_ops,
  cidrcol inet_minmax_ops,
  bpcharcol,
  datecol,
  timecol,
  timestampcol,
  timestamptzcol,
  intervalcol,
  timetzcol,
  bitcol,
  varbitcol,
  numericcol,
  uuidcol,
  int4rangecol,
  lsncol,
  boxcol
)
with (pages_per_range = 1);

create table brinopers (
  colname name,
  typ text,
  op text[],
  value text[],
  matches int[],
  check (cardinality(op) = cardinality(value)),
  check (cardinality(op) = cardinality(matches))
);

insert into brinopers
values
  (
    'byteacol',
    'bytea',
    '{>, >=, =, <=, <}',
    '{AAAAAA, AAAAAA, BNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAA, ZZZZZZ, ZZZZZZ}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'charcol',
    '"char"',
    '{>, >=, =, <=, <}',
    '{A, A, M, Z, Z}',
    '{97, 100, 6, 100, 98}'
  ),
  (
    'namecol',
    'name',
    '{>, >=, =, <=, <}',
    '{AAAAAA, AAAAAA, MAAAAA, ZZAAAA, ZZAAAA}',
    '{100, 100, 2, 100, 100}'
  ),
  (
    'int2col',
    'int2',
    '{>, >=, =, <=, <}',
    '{0, 0, 800, 999, 999}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'int2col',
    'int4',
    '{>, >=, =, <=, <}',
    '{0, 0, 800, 999, 1999}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'int2col',
    'int8',
    '{>, >=, =, <=, <}',
    '{0, 0, 800, 999, 1428427143}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'int4col',
    'int2',
    '{>, >=, =, <=, <}',
    '{0, 0, 800, 1999, 1999}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'int4col',
    'int4',
    '{>, >=, =, <=, <}',
    '{0, 0, 800, 1999, 1999}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'int4col',
    'int8',
    '{>, >=, =, <=, <}',
    '{0, 0, 800, 1999, 1428427143}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'int8col',
    'int2',
    '{>, >=}',
    '{0, 0}',
    '{100, 100}'
  ),
  (
    'int8col',
    'int4',
    '{>, >=}',
    '{0, 0}',
    '{100, 100}'
  ),
  (
    'int8col',
    'int8',
    '{>, >=, =, <=, <}',
    '{0, 0, 1257141600, 1428427143, 1428427143}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'textcol',
    'text',
    '{>, >=, =, <=, <}',
    '{ABABAB, ABABAB, BNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAA, ZZAAAA, ZZAAAA}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'oidcol',
    'oid',
    '{>, >=, =, <=, <}',
    '{0, 0, 8800, 9999, 9999}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'tidcol',
    'tid',
    '{>, >=, =, <=, <}',
    '{"(0,0)", "(0,0)", "(8800,0)", "(9999,19)", "(9999,19)"}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'float4col',
    'float4',
    '{>, >=, =, <=, <}',
    '{0.0103093, 0.0103093, 1, 1, 1}',
    '{100, 100, 4, 100, 96}'
  ),
  (
    'float4col',
    'float8',
    '{>, >=, =, <=, <}',
    '{0.0103093, 0.0103093, 1, 1, 1}',
    '{100, 100, 4, 100, 96}'
  ),
  (
    'float8col',
    'float4',
    '{>, >=, =, <=, <}',
    '{0, 0, 0, 1.98, 1.98}',
    '{99, 100, 1, 100, 100}'
  ),
  (
    'float8col',
    'float8',
    '{>, >=, =, <=, <}',
    '{0, 0, 0, 1.98, 1.98}',
    '{99, 100, 1, 100, 100}'
  ),
  (
    'macaddrcol',
    'macaddr',
    '{>, >=, =, <=, <}',
    '{00:00:01:00:00:00, 00:00:01:00:00:00, 2c:00:2d:00:16:00, ff:fe:00:00:00:00, ff:fe:00:00:00:00}',
    '{99, 100, 2, 100, 100}'
  ),
  (
    'inetcol',
    'inet',
    '{&&, =, <, <=, >, >=, >>=, >>, <<=, <<}',
    '{10/8, 10.2.14.231/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14.231/24, 10.2.14.231/25, 10.2.14.231/8, 0/0}',
    '{100, 1, 100, 100, 125, 125, 2, 2, 100, 100}'
  ),
  (
    'inetcol',
    'inet',
    '{&&, >>=, <<=, =}',
    '{fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46, fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46}',
    '{25, 1, 25, 1}'
  ),
  (
    'inetcol',
    'cidr',
    '{&&, <, <=, >, >=, >>=, >>, <<=, <<}',
    '{10/8, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14/24, 10.2.14/25, 10/8, 0/0}',
    '{100, 100, 100, 125, 125, 2, 2, 100, 100}'
  ),
  (
    'inetcol',
    'cidr',
    '{&&, >>=, <<=, =}',
    '{fe80::/32, fe80::6e40:8ff:fea9:8c46, fe80::/32, fe80::6e40:8ff:fea9:8c46}',
    '{25, 1, 25, 1}'
  ),
  (
    'cidrcol',
    'inet',
    '{&&, =, <, <=, >, >=, >>=, >>, <<=, <<}',
    '{10/8, 10.2.14/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14.231/24, 10.2.14.231/25, 10.2.14.231/8, 0/0}',
    '{100, 2, 100, 100, 125, 125, 2, 2, 100, 100}'
  ),
  (
    'cidrcol',
    'inet',
    '{&&, >>=, <<=, =}',
    '{fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46, fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46}',
    '{25, 1, 25, 1}'
  ),
  (
    'cidrcol',
    'cidr',
    '{&&, =, <, <=, >, >=, >>=, >>, <<=, <<}',
    '{10/8, 10.2.14/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14/24, 10.2.14/25, 10/8, 0/0}',
    '{100, 2, 100, 100, 125, 125, 2, 2, 100, 100}'
  ),
  (
    'cidrcol',
    'cidr',
    '{&&, >>=, <<=, =}',
    '{fe80::/32, fe80::6e40:8ff:fea9:8c46, fe80::/32, fe80::6e40:8ff:fea9:8c46}',
    '{25, 1, 25, 1}'
  ),
  (
    'bpcharcol',
    'bpchar',
    '{>, >=, =, <=, <}',
    '{A, A, W, Z, Z}',
    '{97, 100, 6, 100, 98}'
  ),
  (
    'datecol',
    'date',
    '{>, >=, =, <=, <}',
    '{1995-08-15, 1995-08-15, 2009-12-01, 2022-12-30, 2022-12-30}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'timecol',
    'time',
    '{>, >=, =, <=, <}',
    '{01:20:30, 01:20:30, 02:28:57, 06:28:31.5, 06:28:31.5}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'timestampcol',
    'timestamp',
    '{>, >=, =, <=, <}',
    '{1942-07-23 03:05:09, 1942-07-23 03:05:09, 1964-03-24 19:26:45, 1984-01-20 22:42:21, 1984-01-20 22:42:21}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'timestampcol',
    'timestamptz',
    '{>, >=, =, <=, <}',
    '{1942-07-23 03:05:09, 1942-07-23 03:05:09, 1964-03-24 19:26:45, 1984-01-20 22:42:21, 1984-01-20 22:42:21}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'timestamptzcol',
    'timestamptz',
    '{>, >=, =, <=, <}',
    '{1972-10-10 03:00:00-04, 1972-10-10 03:00:00-04, 1972-10-19 09:00:00-07, 1972-11-20 19:00:00-03, 1972-11-20 19:00:00-03}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'intervalcol',
    'interval',
    '{>, >=, =, <=, <}',
    '{00:00:00, 00:00:00, 1 mons 13 days 12:24, 2 mons 23 days 07:48:00, 1 year}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'timetzcol',
    'timetz',
    '{>, >=, =, <=, <}',
    '{01:30:20+02, 01:30:20+02, 01:35:50+02, 23:55:05+02, 23:55:05+02}',
    '{99, 100, 2, 100, 100}'
  ),
  (
    'bitcol',
    'bit(10)',
    '{>, >=, =, <=, <}',
    '{0000000010, 0000000010, 0011011110, 1111111000, 1111111000}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'varbitcol',
    'varbit(16)',
    '{>, >=, =, <=, <}',
    '{0000000000000100, 0000000000000100, 0001010001100110, 1111111111111000, 1111111111111000}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'numericcol',
    'numeric',
    '{>, >=, =, <=, <}',
    '{0.00, 0.01, 2268164.347826086956521739130434782609, 99470151.9, 99470151.9}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'uuidcol',
    'uuid',
    '{>, >=, =, <=, <}',
    '{00040004-0004-0004-0004-000400040004, 00040004-0004-0004-0004-000400040004, 52225222-5222-5222-5222-522252225222, 99989998-9998-9998-9998-999899989998, 99989998-9998-9998-9998-999899989998}',
    '{100, 100, 1, 100, 100}'
  ),
  (
    'int4rangecol',
    'int4range',
    '{<<, &<, &&, &>, >>, @>, <@, =, <, <=, >, >=}',
    '{"[10000,)","[10000,)","(,]","[3,4)","[36,44)","(1500,1501]","[3,4)","[222,1222)","[36,44)","[43,1043)","[367,4466)","[519,)"}',
    '{53, 53, 53, 53, 50, 22, 72, 1, 74, 75, 34, 21}'
  ),
  (
    'int4rangecol',
    'int4range',
    '{@>, <@, =, <=, >, >=}',
    '{empty, empty, empty, empty, empty, empty}',
    '{125, 72, 72, 72, 53, 125}'
  ),
  ('int4rangecol', 'int4', '{@>}', '{1500}', '{22}'),
  (
    'lsncol',
    'pg_lsn',
    '{>, >=, =, <=, <, IS, IS NOT}',
    '{0/1200, 0/1200, 44/455222, 198/1999799, 198/1999799, NULL, NULL}',
    '{100, 100, 1, 100, 100, 25, 100}'
  ),
  (
    'boxcol', 'point', '{@>}', '{"(500,43)"}', '{11}'
  ),
  (
    'boxcol',
    'box',
    '{<<, &<, &&, &>, >>, <<|, &<|, |&>, |>>, @>, <@, ~=}',
    '{"((1000,2000),(3000,4000))","((1,2),(3000,4000))","((1,2),(3000,4000))","((1,2),(3000,4000))","((1,2),(3,4))","((1000,2000),(3000,4000))","((1,2000),(3,4000))","((1000,2),(3000,4))","((1,2),(3,4))","((1,2),(300,400))","((1,2),(3000,4000))","((222,1222),(44,45))"}',
    '{100, 100, 100, 99, 96, 100, 100, 99, 96, 1, 99, 1}'
  );

do
$do$
DECLARE
	r record;
	r2 record;
	cond text;
	idx_ctids tid[];
	ss_ctids tid[];
	count int;
	plan_ok bool;
	plan_line text;
BEGIN
	FOR r IN SELECT colname, oper, typ, value[ordinality], matches[ordinality] FROM brinopers, unnest(op) WITH ORDINALITY AS oper LOOP

		-- prepare the condition
		IF r.value IS NULL THEN
			cond := format('%I %s %L', r.colname, r.oper, r.value);
		ELSE
			cond := format('%I %s %L::%s', r.colname, r.oper, r.value, r.typ);
		END IF;

		-- run the query using the brin index
		SET enable_seqscan = 0;
		SET enable_bitmapscan = 1;

		plan_ok := false;
		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP
			IF plan_line LIKE '%Bitmap Heap Scan on brintest%' THEN
				plan_ok := true;
			END IF;
		END LOOP;
		IF NOT plan_ok THEN
			RAISE WARNING 'did not get bitmap indexscan plan for %', r;
		END IF;

		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)
			INTO idx_ctids;

		-- run the query using a seqscan
		SET enable_seqscan = 1;
		SET enable_bitmapscan = 0;

		plan_ok := false;
		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP
			IF plan_line LIKE '%Seq Scan on brintest%' THEN
				plan_ok := true;
			END IF;
		END LOOP;
		IF NOT plan_ok THEN
			RAISE WARNING 'did not get seqscan plan for %', r;
		END IF;

		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)
			INTO ss_ctids;

		-- make sure both return the same results
		count := array_length(idx_ctids, 1);

		IF NOT (count = array_length(ss_ctids, 1) AND
				idx_ctids @> ss_ctids AND
				idx_ctids <@ ss_ctids) THEN
			-- report the results of each scan to make the differences obvious
			RAISE WARNING 'something not right in %: count %', r, count;
			SET enable_seqscan = 1;
			SET enable_bitmapscan = 0;
			FOR r2 IN EXECUTE 'SELECT ' || r.colname || ' FROM brintest WHERE ' || cond LOOP
				RAISE NOTICE 'seqscan: %', r2;
			END LOOP;

			SET enable_seqscan = 0;
			SET enable_bitmapscan = 1;
			FOR r2 IN EXECUTE 'SELECT ' || r.colname || ' FROM brintest WHERE ' || cond LOOP
				RAISE NOTICE 'bitmapscan: %', r2;
			END LOOP;
		END IF;

		-- make sure we found expected number of matches
		IF count != r.matches THEN RAISE WARNING 'unexpected number of results % for %', count, r; END IF;
	END LOOP;
END;
$do$;

reset enable_seqscan;

reset enable_bitmapscan;

insert into brintest
select
  cast(repeat(stringu1, 42) as bytea),
  cast(substr(stringu1, 1, 1) as char),
  cast(stringu1 as name),
  142857 * tenthous,
  thousand,
  twothousand,
  repeat(stringu1, 42),
  cast(unique1 as oid),
  cast(format('(%s,%s)', tenthous, twenty) as tid),
  (four + 1.0) / (hundred + 1),
  cast(odd as double precision) / (tenthous + 1),
  cast(format(
    '%s:00:%s:00:%s:00',
    to_hex(odd),
    to_hex(even),
    to_hex(hundred)
  )
  as macaddr),
  cast('10.2.3.4' as inet) + tenthous,
  cast('10.2.3/24' as cidr) + tenthous,
  cast(substr(stringu1, 1, 1) as char),
  cast('1995-08-15' as date) + tenthous,
  cast('01:20:30' as time) +
  thousand * cast('18.5 second' as interval),
  cast('1942-07-23 03:05:09' as timestamp) +
  tenthous * cast('36.38 hours' as interval),
  cast('1972-10-10 03:00'
  as timestamp with time zone) +
  thousand * cast('1 hour' as interval),
  justify_days(
    justify_hours(
      tenthous * cast('12 minutes' as interval)
    )
  ),
  cast('01:30:20' as time with time zone) +
  hundred * cast('15 seconds' as interval),
  cast(thousand as bit(10)),
  cast(cast(tenthous as bit(16)) as bit varying),
  cast(tenthous as numeric(36, 30)) * fivethous *
  even /
  (hundred + 1),
  cast(format(
    '%s%s-%s-%s-%s-%s%s%s',
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000'),
    to_char(tenthous, 'FM0000')
  )
  as uuid),
  int4range(thousand, twothousand),
  cast(format('%s/%s%s', odd, even, tenthous)
  as pg_lsn),
  box(
    point(odd, even),
    point(thousand, twothousand)
  )
from
  tenk1
order by unique2
limit 5
offset 5;

select brin_desummarize_range('brinidx', 0);

vacuum brintest;

update brintest set int8col = int8col * int4col;

update brintest set textcol = '' where textcol is not null;

select brin_summarize_new_values('brintest');

select brin_summarize_new_values('tenk1_unique1');

select brin_summarize_new_values('brinidx');

select brin_desummarize_range('brinidx', -1);

select brin_desummarize_range('brinidx', 0);

select brin_desummarize_range('brinidx', 0);

select brin_desummarize_range('brinidx', 100000000);

create table brin_summarize (value int) with (fillfactor = 10, autovacuum_enabled = 'false');

create index "brin_summarize_idx"
on brin_summarize
using brin
(
  value
)
with (pages_per_range = 2);

do
$do$
DECLARE curtid tid;
BEGIN
  LOOP
    INSERT INTO brin_summarize VALUES (1) RETURNING ctid INTO curtid;
    EXIT WHEN curtid > tid '(2, 0)';
  END LOOP;
END;
$do$;

select brin_summarize_range('brin_summarize_idx', 0);

select brin_summarize_range('brin_summarize_idx', 1);

select brin_summarize_range('brin_summarize_idx', 2);

select brin_summarize_range('brin_summarize_idx', 4294967295);

select brin_summarize_range('brin_summarize_idx', -1);

select brin_summarize_range('brin_summarize_idx', 4294967296);

create table brintest_2 (n numrange);

create index "brinidx_2" on brintest_2 using brin (n);

insert into brintest_2 values ('empty');

insert into brintest_2 values (numrange(0, 2 ^ cast(1000 as numeric)));

insert into brintest_2 values ('(-1, 0)');

select brin_desummarize_range('brinidx', 0);

select brin_summarize_range('brinidx', 0);

drop table brintest_2;

create table brin_test (
  a int,
  b int
);

insert into brin_test select x / 100, x % 100 from generate_series(1, 10000) as x (x);

create index "brin_test_a_idx"
on brin_test
using brin
(
  a
)
with (pages_per_range = 2);

create index "brin_test_b_idx"
on brin_test
using brin
(
  b
)
with (pages_per_range = 2);

vacuum (ANALYZE) brin_test;

select * from brin_test where a = 1;

select * from brin_test where b = 1;

create table brintest_3 (
  a text,
  b text,
  c text,
  d text
);

with
rand_value
as (
  select
    string_agg(fipshash(cast(i as text)), '') as val
  from
    generate_series(1, 60) as s (i)
)
insert into brintest_3
select val, val, val, val from rand_value;

create index "brin_test_toast_idx" on brintest_3 using brin (b, c);

delete from brintest_3;

create index concurrently "brin_test_temp_idx" on brintest_3 using btree (a);

drop index brin_test_temp_idx;

vacuum brintest_3;

with
rand_value
as (
  select
    string_agg(fipshash(cast(-i as text)), '') as val
  from
    generate_series(1, 60) as s (i)
)
insert into brintest_3
select val, val, val, val from rand_value;

set enable_seqscan = off;

select * from brintest_3 where b < '0';

select * from brintest_3 where b < '0';

drop table brintest_3;

reset enable_seqscan;

create table brintest_expr (n int);

create function brintest_func()
returns int
language sql
immutable return 0;;

begin;

set local min_parallel_table_scan_size = 0;

set local max_parallel_maintenance_workers = 4;

create index "brintest_expr_idx" on brintest_expr using brin ((brintest_func()));

commit;

drop table brintest_expr;

drop function brintest_func();

create unlogged table brintest_unlogged (n numrange);

create index "brinidx_unlogged" on brintest_unlogged using brin (n);

insert into brintest_unlogged values (numrange(0, 2 ^ cast(1000 as numeric)));

drop table brintest_unlogged;

create table brin_insert_optimization (a int);

insert into brin_insert_optimization values (1);

create index "brin_insert_optimization_idx" on brin_insert_optimization using brin (a);

update brin_insert_optimization set a = a;

reindex (CONCURRENTLY) index brin_insert_optimization_idx;

drop table brin_insert_optimization;
