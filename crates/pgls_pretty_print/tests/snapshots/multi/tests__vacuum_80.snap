---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/vacuum.sql
---
create table vactst (i int);

insert into vactst values (1);

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst values (0);

select COUNT(*) from vactst;

delete from vactst where i <> 0;

select * from vactst;

vacuum (FULL) vactst;

update vactst set i = i + 1;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst select * from vactst;

insert into vactst values (0);

select COUNT(*) from vactst;

delete from vactst where i <> 0;

vacuum (FULL) vactst;

delete from vactst;

select * from vactst;

vacuum (FULL, FREEZE) vactst;

vacuum (ANALYZE, FULL) vactst;

create table vaccluster (i int primary key);

alter table vaccluster
  cluster on vaccluster_pkey;

cluster vaccluster;

create function do_analyze()
returns void
language sql
volatile
as $function$
ANALYZE pg_am
$function$;

create function wrap_do_analyze(c int)
returns int
language sql
immutable
as $function$
SELECT $1 FROM public.do_analyze()
$function$;

create index on vaccluster using btree ((wrap_do_analyze(i)));

insert into vaccluster values (1), (2);

analyze vaccluster;

insert into vactst select generate_series(1, 300);

delete from vactst where i % 7 = 0;

begin;

insert into vactst select generate_series(301, 400);

delete from vactst where i % 5 <> 0;

analyze vactst;

commit;

begin;

create table past_inh_parent ();

create table past_inh_child ()
inherits (past_inh_parent);

insert into past_inh_child default values;

insert into past_inh_child default values;

analyze past_inh_parent;

select
  reltuples,
  relhassubclass
from
  pg_class
where
  oid =
  cast('past_inh_parent' as regclass);

drop table past_inh_child;

analyze past_inh_parent;

select
  reltuples,
  relhassubclass
from
  pg_class
where
  oid =
  cast('past_inh_parent' as regclass);

commit;

begin;

create table past_parted (i int)
partition by LIST(i);

create table past_part partition of past_parted for values in (1);

insert into past_parted values (1), (1);

analyze past_parted;

drop table past_part;

select
  reltuples,
  relhassubclass
from
  pg_class
where
  oid = cast('past_parted' as regclass);

analyze past_parted;

select
  reltuples,
  relhassubclass
from
  pg_class
where
  oid = cast('past_parted' as regclass);

commit;

vacuum (FULL) pg_am;

vacuum (FULL) pg_class;

vacuum (FULL) pg_database;

vacuum (FULL) vaccluster;

vacuum (FULL) vactst;

vacuum (DISABLE_PAGE_SKIPPING) vaccluster;

create table pvactst (
  i int,
  a int[],
  p point
)
with (autovacuum_enabled = off);

insert into pvactst
select
  i,
  array[1, 2, 3],
  point(i, i + 1)
from
  generate_series(1, 1000) as i;

create index "btree_pvactst" on pvactst using btree (i);

create index "hash_pvactst" on pvactst using hash (i);

create index "brin_pvactst" on pvactst using brin (i);

create index "gin_pvactst" on pvactst using gin (a);

create index "gist_pvactst" on pvactst using gist (p);

create index "spgist_pvactst" on pvactst using spgist (p);

create table pvactst2 (i int) with (autovacuum_enabled = off);

insert into pvactst2 select generate_series(1, 1000);

create index on pvactst2 using btree (i);

create index on pvactst2 using btree (i);

set min_parallel_index_scan_size = 0;

vacuum (PARALLEL 2) pvactst;

update pvactst set i = i where i < 1000;

vacuum (PARALLEL 2) pvactst;

update pvactst set i = i where i < 1000;

vacuum (PARALLEL 0) pvactst;

vacuum (PARALLEL -1) pvactst;

vacuum (PARALLEL 2, INDEX_CLEANUP "false") pvactst;

vacuum (PARALLEL 2, FULL "true") pvactst;

vacuum (PARALLEL) pvactst;

set maintenance_work_mem = 64;

vacuum (PARALLEL 2) pvactst2;

delete from pvactst2 where i < 1000;

vacuum (PARALLEL 2) pvactst2;

reset maintenance_work_mem;

create temporary table tmp (a int primary key);

create index "tmp_idx1" on tmp using btree (a);

vacuum (PARALLEL 1, FULL "false") tmp;

vacuum (PARALLEL 0, FULL "true") tmp;

reset min_parallel_index_scan_size;

drop table pvactst;

drop table pvactst2;

create table no_index_cleanup (
  i int primary key,
  t text
);

create index "no_index_cleanup_idx" on no_index_cleanup using btree (t);

alter table no_index_cleanup
  alter column t set storage external;

insert into no_index_cleanup (i, t)
values
  (
    generate_series(1, 30),
    repeat('1234567890', 269)
  );

vacuum (INDEX_CLEANUP "true", FULL "true") no_index_cleanup;

vacuum (FULL "true") no_index_cleanup;

alter table no_index_cleanup
  set (vacuum_index_cleanup = 'false');

delete from no_index_cleanup where i < 15;

vacuum no_index_cleanup;

alter table no_index_cleanup
  set (vacuum_index_cleanup = 'true');

vacuum no_index_cleanup;

alter table no_index_cleanup
  set (vacuum_index_cleanup = auto);

vacuum no_index_cleanup;

insert into no_index_cleanup (i, t)
values
  (
    generate_series(31, 60),
    repeat('1234567890', 269)
  );

delete from no_index_cleanup where i < 45;

alter table no_index_cleanup
  set (vacuum_index_cleanup = off,
  toast.vacuum_index_cleanup = yes);

vacuum no_index_cleanup;

alter table no_index_cleanup
  set (vacuum_index_cleanup = 'true',
  toast.vacuum_index_cleanup = 'false');

vacuum no_index_cleanup;

vacuum (INDEX_CLEANUP "false") vaccluster;

vacuum (INDEX_CLEANUP auto) vactst;

vacuum (INDEX_CLEANUP "false", FREEZE "true") vaccluster;

create temporary table vac_truncate_test (
  i int not null,
  j text
)
with (
  vacuum_truncate = 'true',
  autovacuum_enabled = 'false'
);

insert into vac_truncate_test values (1, null), (null, null);

vacuum (TRUNCATE "false", DISABLE_PAGE_SKIPPING) vac_truncate_test;

select pg_relation_size('vac_truncate_test') > 0;

set vacuum_truncate = 'false';

vacuum (DISABLE_PAGE_SKIPPING) vac_truncate_test;

select pg_relation_size('vac_truncate_test') = 0;

vacuum (TRUNCATE "false", FULL "true") vac_truncate_test;

alter table vac_truncate_test
  reset (vacuum_truncate);

insert into vac_truncate_test values (1, null), (null, null);

vacuum (DISABLE_PAGE_SKIPPING) vac_truncate_test;

select pg_relation_size('vac_truncate_test') > 0;

reset vacuum_truncate;

vacuum (TRUNCATE "false", DISABLE_PAGE_SKIPPING) vac_truncate_test;

select pg_relation_size('vac_truncate_test') > 0;

vacuum (DISABLE_PAGE_SKIPPING) vac_truncate_test;

select pg_relation_size('vac_truncate_test') = 0;

drop table vac_truncate_test;

create table vacparted (
  a int,
  b char(1)
)
partition by LIST(a);

create table vacparted1 partition of vacparted for values in (1);

insert into vacparted values (1, 'a');

update vacparted set b = 'b';

vacuum (ANALYZE) vacparted;

vacuum (FULL) vacparted;

vacuum (FREEZE) vacparted;

vacuum (ANALYZE) vacparted (a, b, a);

analyze vacparted (a, b, b);

create table vacparted_i (
  a int primary key,
  b varchar(100)
)
partition by HASH(a);

create table vacparted_i1
partition of vacparted_i
for values with (MODULUS 2, REMAINDER 0);

create table vacparted_i2
partition of vacparted_i
for values with (MODULUS 2, REMAINDER 1);

insert into vacparted_i select i, 'test_' || i from generate_series(1, 10) as i;

vacuum (ANALYZE) vacparted_i;

vacuum (FULL) vacparted_i;

vacuum (FREEZE) vacparted_i;

select
  relname,
  relhasindex
from
  pg_class
where
  relname like 'vacparted_i%' and
  relkind in ('p', 'r')
order by relname;

drop table vacparted_i;

vacuum vaccluster, vactst;

vacuum vacparted, does_not_exist;

vacuum (FREEZE) vacparted, vaccluster, vactst;

vacuum (FREEZE) does_not_exist, vaccluster;

vacuum (ANALYZE) vactst, vacparted (a);

vacuum (ANALYZE) vactst (does_not_exist), vacparted (b);

vacuum (FULL) vacparted, vactst;

vacuum (FULL) vactst, vacparted (a, b), vaccluster (i);

analyze vactst, vacparted;

analyze vacparted (b), vactst;

analyze vactst, does_not_exist, vacparted;

analyze vactst (i), vacparted (does_not_exist);

analyze vactst, vactst;

begin;

analyze vactst, vactst;

commit;

create table only_parted (
  a int,
  b text
)
partition by LIST(a);

create table only_parted1 partition of only_parted for values in (1);

insert into only_parted values (1, 'a');

select
  relname,
  last_analyze is not null as analyzed,
  last_vacuum is not null as vacuumed
from
  pg_stat_user_tables
where
  relid
  in (
    cast('only_parted' as regclass),
    cast('only_parted1' as regclass)
  )
order by relname;

analyze only_parted;

select
  relname,
  last_analyze is not null as analyzed,
  last_vacuum is not null as vacuumed
from
  pg_stat_user_tables
where
  relid
  in (
    cast('only_parted' as regclass),
    cast('only_parted1' as regclass)
  )
order by relname;

drop table only_parted;

create table only_inh_parent (
  a int primary key,
  b text
);

create table only_inh_child ()
inherits (only_inh_parent);

insert into only_inh_child (a, b) values (1, 'aaa'), (2, 'bbb'), (3, 'ccc');

select
  relname,
  last_analyze is not null as analyzed,
  last_vacuum is not null as vacuumed
from
  pg_stat_user_tables
where
  relid
  in (
    cast('only_inh_parent' as regclass),
    cast('only_inh_child' as regclass)
  )
order by relname;

analyze only_inh_parent;

select
  relname,
  last_analyze is not null as analyzed,
  last_vacuum is not null as vacuumed
from
  pg_stat_user_tables
where
  relid
  in (
    cast('only_inh_parent' as regclass),
    cast('only_inh_child' as regclass)
  )
order by relname;

select
  relname,
  last_analyze is not null as analyzed,
  last_vacuum is not null as vacuumed
from
  pg_stat_user_tables
where
  relid
  in (
    cast('only_inh_parent' as regclass),
    cast('only_inh_child' as regclass)
  )
order by relname;

vacuum only_inh_parent;

select
  relname,
  last_analyze is not null as analyzed,
  last_vacuum is not null as vacuumed
from
  pg_stat_user_tables
where
  relid
  in (
    cast('only_inh_parent' as regclass),
    cast('only_inh_child' as regclass)
  )
order by relname;

drop table only_inh_parent cascade;

analyze (VERBOSE) does_not_exist;

analyze (NONEXISTENTARG) does_not_exit;

set client_min_messages = ERROR;

analyze (SKIP_LOCKED, VERBOSE) does_not_exist;

analyze (VERBOSE, SKIP_LOCKED) does_not_exist;

vacuum (SKIP_LOCKED) vactst;

vacuum (SKIP_LOCKED, FULL) vactst;

analyze (SKIP_LOCKED) vactst;

reset client_min_messages;

set default_transaction_isolation = serializable;

vacuum vactst;

analyze vactst;

reset default_transaction_isolation;

begin isolation level serializable;

analyze vactst;

commit;

create table vac_option_tab (
  a int,
  t text
);

insert into vac_option_tab select a, 't' || a from generate_series(1, 10) as a;

alter table vac_option_tab
  alter column t set storage external;

create view vac_option_tab_counts
as select
  case
    when c.relname is null then 'main'
    else 'toast'
  end
  as rel,
  s.vacuum_count
from
  pg_stat_all_tables as s
  left outer join
    pg_class as c
  on s.relid = c.reltoastrelid
where
  c.relname = 'vac_option_tab' or
  s.relname = 'vac_option_tab'
order by rel;

vacuum (PROCESS_TOAST "true") vac_option_tab;

select * from vac_option_tab_counts;

vacuum (PROCESS_TOAST "false") vac_option_tab;

select * from vac_option_tab_counts;

vacuum (PROCESS_TOAST "false", FULL) vac_option_tab;

vacuum (PROCESS_MAIN "false") vac_option_tab;

select * from vac_option_tab_counts;

vacuum (PROCESS_MAIN "false", PROCESS_TOAST "false") vac_option_tab;

select * from vac_option_tab_counts;

select
  relfilenode as main_filenode
from
  pg_class
where
  relname = 'vac_option_tab';

select
  t.relfilenode as toast_filenode
from
  pg_class as c,
  pg_class as t
where
  c.reltoastrelid = t.oid and
  c.relname = 'vac_option_tab';

vacuum (PROCESS_MAIN "false", FULL) vac_option_tab;

select
  relfilenode = 'main_filenode'
  as is_same_main_filenode
from
  pg_class
where
  relname = 'vac_option_tab';

select
  t.relfilenode = 'toast_filenode'
  as is_same_toast_filenode
from
  pg_class as c,
  pg_class as t
where
  c.reltoastrelid = t.oid and
  c.relname = 'vac_option_tab';

vacuum (BUFFER_USAGE_LIMIT "512 kB") vac_option_tab;

analyze (BUFFER_USAGE_LIMIT "512 kB") vac_option_tab;

vacuum (BUFFER_USAGE_LIMIT 0) vac_option_tab;

analyze (BUFFER_USAGE_LIMIT 0) vac_option_tab;

vacuum (BUFFER_USAGE_LIMIT 16777220) vac_option_tab;

vacuum (BUFFER_USAGE_LIMIT 120) vac_option_tab;

vacuum (BUFFER_USAGE_LIMIT 10000000000) vac_option_tab;

vacuum (BUFFER_USAGE_LIMIT "512 kB", FULL) vac_option_tab;

vacuum (SKIP_DATABASE_STATS) vactst;

vacuum (ONLY_DATABASE_STATS);

vacuum (ONLY_DATABASE_STATS) vactst;

drop view vac_option_tab_counts;

drop table vac_option_tab;

drop table vaccluster;

drop table vactst;

drop table vacparted;

drop table no_index_cleanup;

create table vacowned (a int);

create table vacowned_parted (a int)
partition by LIST(a);

create table vacowned_part1 partition of vacowned_parted for values in (1);

create table vacowned_part2 partition of vacowned_parted for values in (2);

create role regress_vacuum;

set role to regress_vacuum;

vacuum vacowned;

analyze vacowned;

vacuum (ANALYZE) vacowned;

vacuum pg_catalog.pg_class;

analyze pg_catalog.pg_class;

vacuum (ANALYZE) pg_catalog.pg_class;

vacuum pg_catalog.pg_authid;

analyze pg_catalog.pg_authid;

vacuum (ANALYZE) pg_catalog.pg_authid;

vacuum vacowned_parted;

vacuum vacowned_part1;

vacuum vacowned_part2;

analyze vacowned_parted;

analyze vacowned_part1;

analyze vacowned_part2;

vacuum (ANALYZE) vacowned_parted;

vacuum (ANALYZE) vacowned_part1;

vacuum (ANALYZE) vacowned_part2;

reset role;

alter table vacowned_parted
  owner to regress_vacuum;

alter table vacowned_part1
  owner to regress_vacuum;

set role to regress_vacuum;

vacuum vacowned_parted;

vacuum vacowned_part1;

vacuum vacowned_part2;

analyze vacowned_parted;

analyze vacowned_part1;

analyze vacowned_part2;

vacuum (ANALYZE) vacowned_parted;

vacuum (ANALYZE) vacowned_part1;

vacuum (ANALYZE) vacowned_part2;

reset role;

alter table vacowned_parted
  owner to current_user;

set role to regress_vacuum;

vacuum vacowned_parted;

vacuum vacowned_part1;

vacuum vacowned_part2;

analyze vacowned_parted;

analyze vacowned_part1;

analyze vacowned_part2;

vacuum (ANALYZE) vacowned_parted;

vacuum (ANALYZE) vacowned_part1;

vacuum (ANALYZE) vacowned_part2;

reset role;

alter table vacowned_parted
  owner to regress_vacuum;

alter table vacowned_part1
  owner to current_user;

set role to regress_vacuum;

vacuum vacowned_parted;

vacuum vacowned_part1;

vacuum vacowned_part2;

analyze vacowned_parted;

analyze vacowned_part1;

analyze vacowned_part2;

vacuum (ANALYZE) vacowned_parted;

vacuum (ANALYZE) vacowned_part1;

vacuum (ANALYZE) vacowned_part2;

reset role;

drop table vacowned;

drop table vacowned_parted;

drop role regress_vacuum;

create table vac_rewrite_toast (
  id int,
  f1 text storage plain
);

insert into vac_rewrite_toast values (1, repeat('a', 7000));

alter table vac_rewrite_toast
  alter column f1 set storage external;

insert into vac_rewrite_toast values (2, repeat('a', 7000));

select
  pg_column_toast_chunk_id(f1)
  as id_2_chunk
from
  vac_rewrite_toast
where
  id = 2;

select
  id,
  pg_column_toast_chunk_id(f1) is null
  as f1_chunk_null,
  substr(f1, 5, 10) as f1_data,
  pg_column_compression(f1) as f1_comp
from
  vac_rewrite_toast
order by id;

vacuum (FULL) vac_rewrite_toast;

select
  id,
  pg_column_toast_chunk_id(f1) is null
  as f1_chunk_null,
  substr(f1, 5, 10) as f1_data,
  pg_column_compression(f1) as f1_comp
from
  vac_rewrite_toast
order by id;

select
  pg_column_toast_chunk_id(f1) =
  'id_2_chunk'
  as same_chunk
from
  vac_rewrite_toast
where
  id = 2;

drop table vac_rewrite_toast;
