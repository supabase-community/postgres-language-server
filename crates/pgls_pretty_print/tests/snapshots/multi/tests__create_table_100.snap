---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/create_table.sql
snapshot_kind: text
---
create table unknowntab (u unknown);

create type unknown_comptype as (u unknown);

create table tas_case with (fillfactor = 10) as select 1 as a;

create unlogged table unlogged1 (a INT primary key);

create temporary table unlogged2 (a INT primary key);

select
  relname,
  relkind,
  relpersistence
from
  pg_class
where
  relname ~ '^unlogged\d'
order by relname;

reindex index unlogged1_pkey;

reindex index unlogged2_pkey;

select
  relname,
  relkind,
  relpersistence
from
  pg_class
where
  relname ~ '^unlogged\d'
order by relname;

drop TABLE unlogged2;

insert into unlogged1 values (42);

create unlogged table public.unlogged2 (a INT primary key);

create unlogged table pg_temp.unlogged3 (a INT primary key);

create table pg_temp.implicitly_temp (a INT primary key);

create temporary table explicitly_temp (a INT primary key);

create temporary table pg_temp.doubly_temp (a INT primary key);

create temporary table public.temp_to_perm (a INT primary key);

drop TABLE unlogged1, public.unlogged2;

create unlogged table unlogged1 (a INT)
partition by range(a);

create table unlogged1 (a INT)
partition by range(a);

alter table unlogged1
  set LOGGED;

alter table unlogged1
  set unlogged;

drop TABLE unlogged1;

create table as_select1 as select * from pg_class where relkind = 'r';

create table as_select1 as select * from pg_class where relkind = 'r';

create table if not exists as_select1 as select * from pg_class where relkind = 'r';

drop TABLE as_select1;

prepare select1 as select 1 as a;;

create table as_select1 as execute select1;

create table as_select1 as execute select1;

select * from as_select1;

create table if not exists as_select1 as execute select1;

drop TABLE as_select1;

deallocate select1;

select
  'CREATE TABLE extra_wide_table(firstc text, ' ||
  array_to_string(
    array_agg('c' || i || ' bool'),
    ','
  ) ||
  ', lastc text);'
from
  generate_series(1, 1100) as g (i);

insert into extra_wide_table (firstc, lastc) values ('first col', 'last col');

select firstc, lastc from extra_wide_table;

create table withoid () with (oids);

create table withoid () with (oids = 'true');

create temporary table withoutoid ();

drop TABLE withoutoid;

create temporary table withoutoid () with (oids = 'false');

drop TABLE withoutoid;

create temporary table relation_filenode_check (c1 INT);

select
  relpersistence,
  pg_filenode_relation(
    reltablespace,
    pg_relation_filenode(oid)
  )
from
  pg_class
where
  relname = 'relation_filenode_check';

drop TABLE relation_filenode_check;

create table default_expr_column (id INT default id);

create table default_expr_column (id INT default bar.id);

create table default_expr_agg_column (id INT default AVG(id));

create table default_expr_non_column (a INT default AVG(non_existent));

create table default_expr_agg (a INT default AVG(1));

create table default_expr_agg (a INT default ((select 1)));

create table default_expr_agg (a INT default generate_series(1, 3));

begin;

create table remember_create_subid (c INT);

savepoint q;

drop TABLE remember_create_subid;

rollback to savepoint q;

commit;

drop TABLE remember_create_subid;

create table remember_node_subid (c INT);

begin;

alter table remember_node_subid
  alter column c type BIGINT;

savepoint q;

drop TABLE remember_node_subid;

rollback to savepoint q;

commit;

drop TABLE remember_node_subid;

create table partitioned (a INT)
inherits (some_table)
partition by LIST(a);

create table partitioned (
  a1 INT,
  a2 INT
)
partition by LIST(a1, a2);

create function retset(a INT)
returns setof INT
as $function$ SELECT 1; $function$
language sql
immutable;

create table partitioned (a INT)
partition by range((retset(a)));

drop FUNCTION retset(INT);

create table partitioned (a INT)
partition by range((AVG(a)));

create table partitioned (
  a INT,
  b INT
)
partition by range((AVG(a) over (partition by b)));

create table partitioned (a INT)
partition by LIST((a like (select 1)));

create table partitioned (a INT)
partition by range((42));

create function const_func()
returns INT
as $function$ SELECT 1; $function$
language sql
immutable;

create table partitioned (a INT)
partition by range((const_func()));

drop FUNCTION const_func();

create table partitioned (a INT)
partition by range(b);

create table partitioned (a INT)
partition by range(xmin);

create table partitioned (
  a INT,
  b INT
)
partition by range(((a, b)));

create table partitioned (
  a INT,
  b INT
)
partition by range(a, ('unknown'));

create function immut_func(a INT)
returns INT
as $function$ SELECT a + random()::int; $function$
language sql;

create table partitioned (a INT)
partition by range((immut_func(a)));

drop FUNCTION immut_func(INT);

create table partitioned (a point)
partition by LIST(a);

create table partitioned (a point)
partition by LIST(a point_ops);

create table partitioned (a point)
partition by range(a);

create table partitioned (a point)
partition by range(a point_ops);

create table partitioned (
  a INT,
  constraint "check_a" check (a > 0) no inherit
)
partition by range(a);

create function plusone(a INT)
returns INT
as $function$ SELECT a+1; $function$
language sql;

create table partitioned (
  a INT,
  b INT,
  c TEXT,
  d TEXT
)
partition by range(a oid_ops,
(plusone(b)),
c collate "default",
d collate "C");

select relkind from pg_class where relname = 'partitioned';

drop FUNCTION plusone(INT);

create table partitioned2 (
  a INT,
  b TEXT
)
partition by range((a + 1), (substr(b, 1, 5)));

create table fail ()
inherits (partitioned2);

insert into partitioned2 values (1, 'hello');

create table part2_1 partition of partitioned2 for values from (-1, 'aaaaa') to (100, 'ccccc');

drop TABLE partitioned, partitioned2;

create table partitioned (
  a INT,
  b INT
)
partition by LIST((cast(row(a, b) as partitioned)));

create table partitioned1 partition of partitioned for values in (cast('(1,2)' as partitioned));

create table partitioned2 partition of partitioned for values in (cast('(2,4)' as partitioned));

select * from partitioned where cast(row(a, b) as partitioned) = cast('(1,2)' as partitioned);

drop TABLE partitioned;

create table partitioned (
  a INT,
  b INT
)
partition by LIST((partitioned));

create table partitioned1 partition of partitioned for values in ('(1,2)');

create table partitioned2 partition of partitioned for values in ('(2,4)');

select * from partitioned where partitioned = cast('(1,2)' as partitioned);

drop TABLE partitioned;

create domain intdom1 as INT;

create table partitioned (
  a intdom1,
  b TEXT
)
partition by range(a);

alter table partitioned
  drop column a;

drop DOMAIN intdom1;

drop DOMAIN intdom1 cascade;

select * from partitioned;

create domain intdom1 as INT;

create table partitioned (
  a intdom1,
  b TEXT
)
partition by range((plusone(a)));

alter table partitioned
  drop column a;

drop DOMAIN intdom1;

drop DOMAIN intdom1 cascade;

select * from partitioned;

create table list_parted (a INT)
partition by LIST(a);

create table part_p1 partition of list_parted for values in ('1');

create table part_p2 partition of list_parted for values in (2);

create table part_p3 partition of list_parted for values in (2 + 1);

create table part_null partition of list_parted for values in (null);

create table part_bogus_expr_fail partition of list_parted for values in (somename);

create table part_bogus_expr_fail partition of list_parted for values in (somename.somename);

create table part_bogus_expr_fail partition of list_parted for values in (a);

create table part_bogus_expr_fail partition of list_parted for values in (SUM(a));

create table part_bogus_expr_fail partition of list_parted for values in (SUM(somename));

create table part_bogus_expr_fail partition of list_parted for values in (SUM(1));

create table part_bogus_expr_fail partition of list_parted for values in ((select 1));

create table part_bogus_expr_fail partition of list_parted for values in (generate_series(4, 6));

create table part_bogus_expr_fail partition of list_parted for values in ((1 + 1) collate "POSIX");

create table fail_part partition of list_parted for values from (1) to (2);

create table fail_part partition of list_parted for values with (MODULUS 10, REMAINDER 1);

create table part_default partition of list_parted default;

create table fail_default_part partition of list_parted default;

create table bools (a BOOLEAN)
partition by LIST(a);

create table bools_true partition of bools for values in (1);

drop TABLE bools;

create table moneyp (a MONEY)
partition by LIST(a);

create table moneyp_10 partition of moneyp for values in (10);

create table moneyp_11 partition of moneyp for values in ('11');

create table moneyp_12 partition of moneyp for values in (cast(to_char(12, '99') as INT));

drop TABLE moneyp;

create table bigintp (a BIGINT)
partition by LIST(a);

create table bigintp_10 partition of bigintp for values in (10);

create table bigintp_10_2 partition of bigintp for values in ('10');

drop TABLE bigintp;

create table range_parted (a DATE)
partition by range(a);

create table part_bogus_expr_fail
partition of range_parted
for values from (somename) to ('2019-01-01');

create table part_bogus_expr_fail
partition of range_parted
for values from (somename.somename) to ('2019-01-01');

create table part_bogus_expr_fail partition of range_parted for values from (a) to ('2019-01-01');

create table part_bogus_expr_fail
partition of range_parted
for values from (MAX(a)) to ('2019-01-01');

create table part_bogus_expr_fail
partition of range_parted
for values from (MAX(somename)) to ('2019-01-01');

create table part_bogus_expr_fail
partition of range_parted
for values from (MAX(cast('2019-02-01' as DATE))) to ('2019-01-01');

create table part_bogus_expr_fail
partition of range_parted
for values from ((select 1)) to ('2019-01-01');

create table part_bogus_expr_fail
partition of range_parted
for values from (generate_series(1, 3)) to ('2019-01-01');

create table fail_part partition of range_parted for values in ('a');

create table fail_part partition of range_parted for values with (MODULUS 10, REMAINDER 1);

create table fail_part partition of range_parted for values from ('a', 1) to ('z');

create table fail_part partition of range_parted for values from ('a') to ('z', 1);

create table fail_part partition of range_parted for values from (null) to (maxvalue);

create table fail_part partition of range_parted for values with (MODULUS 10, REMAINDER 1);

create table hash_parted (a INT)
partition by HASH(a);

create table hpart_1 partition of hash_parted for values with (MODULUS 10, REMAINDER 0);

create table hpart_2 partition of hash_parted for values with (MODULUS 50, REMAINDER 1);

create table hpart_3 partition of hash_parted for values with (MODULUS 200, REMAINDER 2);

create table hpart_4 partition of hash_parted for values with (MODULUS 10, REMAINDER 3);

create table fail_part partition of hash_parted for values with (MODULUS 25, REMAINDER 3);

create table fail_part partition of hash_parted for values with (MODULUS 150, REMAINDER 3);

create table fail_part partition of hash_parted for values with (MODULUS 100, REMAINDER 3);

create table fail_part partition of hash_parted for values from ('a', 1) to ('z');

create table fail_part partition of hash_parted for values in (1000);

create table fail_default_part partition of hash_parted default;

create table unparted (a INT);

create table fail_part partition of unparted for values in ('a');

create table fail_part partition of unparted for values with (MODULUS 2, REMAINDER 1);

drop TABLE unparted;

create temporary table temp_parted (a INT)
partition by LIST(a);

create table fail_part partition of temp_parted for values in ('a');

drop TABLE temp_parted;

create table list_parted2 (a VARCHAR)
partition by LIST(a);

create table part_null_z partition of list_parted2 for values in (null, 'z');

create table part_ab partition of list_parted2 for values in ('a', 'b');

create table list_parted2_def partition of list_parted2 default;

create table fail_part partition of list_parted2 for values in (null);

create table fail_part partition of list_parted2 for values in ('b', 'c');

insert into list_parted2 values ('X');

create table fail_part partition of list_parted2 for values in ('W', 'X', 'Y');

create table range_parted2 (a INT)
partition by range(a);

create table fail_part partition of range_parted2 for values from (1) to (0);

create table fail_part partition of range_parted2 for values from (1) to (1);

create table part0 partition of range_parted2 for values from (minvalue) to (1);

create table fail_part partition of range_parted2 for values from (minvalue) to (2);

create table part1 partition of range_parted2 for values from (1) to (10);

create table fail_part partition of range_parted2 for values from (-1) to (1);

create table fail_part partition of range_parted2 for values from (9) to (maxvalue);

create table part2 partition of range_parted2 for values from (20) to (30);

create table part3 partition of range_parted2 for values from (30) to (40);

create table fail_part partition of range_parted2 for values from (10) to (30);

create table fail_part partition of range_parted2 for values from (10) to (50);

create table range2_default partition of range_parted2 default;

create table fail_default_part partition of range_parted2 default;

insert into range_parted2 values (85);

create table fail_part partition of range_parted2 for values from (80) to (90);

create table part4 partition of range_parted2 for values from (90) to (100);

create table range_parted3 (
  a INT,
  b INT
)
partition by range(a, (b + 1));

create table part00 partition of range_parted3 for values from (0, minvalue) to (0, maxvalue);

create table fail_part partition of range_parted3 for values from (0, minvalue) to (0, 1);

create table part10 partition of range_parted3 for values from (1, minvalue) to (1, 1);

create table part11 partition of range_parted3 for values from (1, 1) to (1, 10);

create table part12 partition of range_parted3 for values from (1, 10) to (1, maxvalue);

create table fail_part partition of range_parted3 for values from (1, 10) to (1, 20);

create table range3_default partition of range_parted3 default;

create table fail_part partition of range_parted3 for values from (1, minvalue) to (1, maxvalue);

create table hash_parted2 (a VARCHAR)
partition by HASH(a);

create table h2part_1 partition of hash_parted2 for values with (MODULUS 4, REMAINDER 2);

create table h2part_2 partition of hash_parted2 for values with (MODULUS 8, REMAINDER 0);

create table h2part_3 partition of hash_parted2 for values with (MODULUS 8, REMAINDER 4);

create table h2part_4 partition of hash_parted2 for values with (MODULUS 8, REMAINDER 5);

create table fail_part partition of hash_parted2 for values with (MODULUS 2, REMAINDER 1);

create table fail_part partition of hash_parted2 for values with (MODULUS 0, REMAINDER 1);

create table fail_part partition of hash_parted2 for values with (MODULUS 8, REMAINDER 8);

create table parted (
  a TEXT,
  b INT not null default 0,
  constraint "check_a" check (length(a) > 0)
)
partition by LIST(a);

create table part_a partition of parted for values in ('a');

select
  attname,
  attislocal,
  attinhcount
from
  pg_attribute
where
  attrelid = cast('part_a' as REGCLASS) and
  attnum > 0
order by attnum;

create table part_b
partition of parted
(
  b not null,
  b default 1,
  b check (b >= 0),
  constraint "check_a" check (length(a) > 0)
)
for values in ('b');

create table part_b
partition of parted
(
  b not null default 1,
  constraint "check_a" check (length(a) > 0),
  constraint "check_b" check (b >= 0)
)
for values in ('b');

select
  conname,
  conislocal,
  coninhcount
from
  pg_constraint
where
  conrelid = cast('part_b' as REGCLASS)
order by coninhcount desc,
  conname;

alter table parted
  add constraint "check_b" check (b >= 0);

select
  conname,
  conislocal,
  coninhcount
from
  pg_constraint
where
  conrelid = cast('part_b' as REGCLASS)
order by coninhcount desc,
  conname;

alter table part_b
  drop constraint check_a;

alter table part_b
  drop constraint check_b;

alter table parted
  drop constraint check_a,
  drop constraint check_b;

select
  conname,
  conislocal,
  coninhcount
from
  pg_constraint
where
  conrelid = cast('part_b' as REGCLASS)
order by coninhcount desc,
  conname;

create table fail_part_col_not_found partition of parted for values in ('c') partition by range(c);

create table part_c
partition of parted
(
  b not null default 0
)
for values in ('c')
partition by range((b));

create table part_c_1_10 partition of part_c for values from (1) to (10);

create table parted_notnull_inh_test (
  a INT default 1,
  b INT not null default 0
)
partition by LIST(a);

create table parted_notnull_inh_test1
partition of parted_notnull_inh_test
(
  a not null,
  b default 1
)
for values in (1);

insert into parted_notnull_inh_test (b) values (null);

drop TABLE parted_notnull_inh_test;

create table parted_boolean_col (
  a BOOLEAN,
  b TEXT
)
partition by LIST(a);

create table parted_boolean_less partition of parted_boolean_col for values in ('foo' < 'bar');

create table parted_boolean_greater partition of parted_boolean_col for values in ('foo' > 'bar');

drop TABLE parted_boolean_col;

create table parted_collate_must_match (
  a TEXT collate "C",
  b TEXT collate "C"
)
partition by range(a);

create table parted_collate_must_match1
partition of parted_collate_must_match
(
  a collate "POSIX"
)
for values from ('a') to ('m');

create table parted_collate_must_match2
partition of parted_collate_must_match
(
  b collate "POSIX"
)
for values from ('m') to ('z');

drop TABLE parted_collate_must_match;

create table test_part_coll_posix (a TEXT)
partition by range(a collate "POSIX");

create table test_part_coll
partition of test_part_coll_posix
for values from ('a' collate "C") to ('g');

create table test_part_coll2 partition of test_part_coll_posix for values from ('g') to ('m');

create table test_part_coll_cast
partition of test_part_coll_posix
for values from (cast('m' as NAME) collate "C") to ('s');

create table test_part_coll_cast2
partition of test_part_coll_posix
for values from (cast('s' as NAME)) to ('z');

drop TABLE test_part_coll_posix;

create table range_parted4 (
  a INT,
  b INT,
  c INT
)
partition by range((abs(a)), (abs(b)), c);

create table unbounded_range_part
partition of range_parted4
for values from (minvalue,
minvalue,
minvalue) to (maxvalue,
maxvalue,
maxvalue);

drop TABLE unbounded_range_part;

create table range_parted4_1
partition of range_parted4
for values from (minvalue,
minvalue,
minvalue) to (1,
maxvalue,
maxvalue);

create table range_parted4_2
partition of range_parted4
for values from (3, 4, 5) to (6, 7, maxvalue);

create table range_parted4_3
partition of range_parted4
for values from (6,
8,
minvalue) to (9,
maxvalue,
maxvalue);

drop TABLE range_parted4;

create function my_int4_sort(INT, INT)
returns INT
language sql
as $function$ SELECT CASE WHEN $1 = $2 THEN 0 WHEN $1 > $2 THEN 1 ELSE -1 END; $function$;

create OPERATOR class test_int4_ops
  for type INT
  using btree
  as OPERATOR 1 < (INT, INT),
  OPERATOR 2 <= (INT, INT),
  OPERATOR 3 = (INT, INT),
  OPERATOR 4 >= (INT, INT),
  OPERATOR 5 > (INT, INT),
  FUNCTION 1 my_int4_sort(INT, INT);

create table partkey_t (a INT)
partition by range(a test_int4_ops);

create table partkey_t_1 partition of partkey_t for values from (0) to (1000);

insert into partkey_t values (100);

insert into partkey_t values (200);

drop TABLE parted, list_parted, range_parted, list_parted2, range_parted2, range_parted3;

drop TABLE partkey_t, hash_parted, hash_parted2;

drop OPERATOR CLASS test_int4_ops USING btree;

drop FUNCTION my_int4_sort(INT, INT);

create table parted_col_comment (
  a INT,
  b TEXT
)
partition by LIST(a);

comment on table parted_col_comment is 'Am partitioned table';

comment on column parted_col_comment.a is 'Partition key';

select obj_description(cast('parted_col_comment' as REGCLASS));

drop TABLE parted_col_comment;

create table parted_col_comment (
  a INT,
  b TEXT
)
partition by LIST(a)
with (fillfactor = 100);

create table arrlp (a INT[])
partition by LIST(a);

create table arrlp12 partition of arrlp for values in ('{1}', '{2}');

drop TABLE arrlp;

create table boolspart (a BOOLEAN)
partition by LIST(a);

create table boolspart_t partition of boolspart for values in (true);

create table boolspart_f partition of boolspart for values in (false);

drop TABLE boolspart;

create table perm_parted (a INT)
partition by LIST(a);

create temporary table temp_parted (a INT)
partition by LIST(a);

create table perm_part partition of temp_parted default;

create temporary table temp_part partition of perm_parted default;

create temporary table temp_part partition of temp_parted default;

drop TABLE perm_parted cascade;

drop TABLE temp_parted cascade;

create table tab_part_create (a INT)
partition by LIST(a);

create or replace function func_part_create()
returns trigger
language plpgsql
as $function$
  begin
    execute 'create table tab_part_create_1 partition of tab_part_create for values in (1)';
    return null;
  end $function$;

create TRIGGER trig_part_create
  before insert
  on tab_part_create
  for EACH STATEMENT
  EXECUTE FUNCTION func_part_create();

insert into tab_part_create values (1);

drop TABLE tab_part_create;

drop FUNCTION func_part_create();

create table volatile_partbound_test (partkey TIMESTAMP)
partition by range(partkey);

create table volatile_partbound_test1
partition of volatile_partbound_test
for values from (minvalue) to (current_timestamp);

create table volatile_partbound_test2
partition of volatile_partbound_test
for values from (current_timestamp) to (maxvalue);

insert into volatile_partbound_test values (current_timestamp);

select cast(tableoid as REGCLASS) from volatile_partbound_test;

drop TABLE volatile_partbound_test;

create table defcheck (
  a INT,
  b INT
)
partition by LIST(b);

create table defcheck_def (
  a INT,
  c INT,
  b INT
);

alter table defcheck_def
  drop column c;

alter table defcheck
  ATTACH partition
  defcheck_def default;

alter table defcheck_def
  add check (b <= 0 and b is not null);

create table defcheck_1 partition of defcheck for values in (1, null);

insert into defcheck_def values (0, 0);

create table defcheck_0 partition of defcheck for values in (0);

drop TABLE defcheck;

create table part_column_drop (
  useless_1 INT,
  id INT,
  useless_2 INT,
  d INT,
  b INT,
  useless_3 INT
)
partition by range(id);

alter table part_column_drop
  drop column useless_1;

alter table part_column_drop
  drop column useless_2;

alter table part_column_drop
  drop column useless_3;

create index "part_column_drop_b_pred"
on part_column_drop
using btree
(
  b
)
where
  b = 1;

create index "part_column_drop_b_expr" on part_column_drop using btree ((b = 1));

create index "part_column_drop_d_pred"
on part_column_drop
using btree
(
  d
)
where
  d = 2;

create index "part_column_drop_d_expr" on part_column_drop using btree ((d = 2));

create table part_column_drop_1_10 partition of part_column_drop for values from (1) to (10);

drop TABLE part_column_drop;
