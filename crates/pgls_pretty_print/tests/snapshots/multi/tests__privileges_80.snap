---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/privileges.sql
---
set client_min_messages = warning;

drop role if exists regress_priv_group1;

drop role if exists regress_priv_group2;

drop role if exists regress_priv_user1;

drop role if exists regress_priv_user2;

drop role if exists regress_priv_user3;

drop role if exists regress_priv_user4;

drop role if exists regress_priv_user5;

drop role if exists regress_priv_user6;

drop role if exists regress_priv_user7;

select
  lo_unlink(oid)
from
  pg_largeobject_metadata
where
  oid >= 1000 and oid < 3000
order by oid;

reset client_min_messages;

create user regress_priv_user1;

create user regress_priv_user2;

create user regress_priv_user3;

create user regress_priv_user4;

create user regress_priv_user5;

create user regress_priv_user5;

create user regress_priv_user6;

create user regress_priv_user7;

create user regress_priv_user8;

create user regress_priv_user9;

create user regress_priv_user10;

create role regress_priv_role;

grant REGRESS_PRIV_USER1 to regress_priv_user2 with ADMIN true;

grant REGRESS_PRIV_USER1
to regress_priv_user3
with ADMIN true
granted by regress_priv_user2;

grant REGRESS_PRIV_USER1
to regress_priv_user2
with ADMIN true
granted by regress_priv_user3;

revoke ADMIN option for REGRESS_PRIV_USER1 from regress_priv_user2 restrict;

revoke REGRESS_PRIV_USER1 from regress_priv_user2 restrict;

select
  cast(member as regrole),
  admin_option
from
  pg_auth_members
where
  roleid =
  cast('regress_priv_user1' as regrole);

begin;

revoke ADMIN option for REGRESS_PRIV_USER1 from regress_priv_user2 cascade;

select
  cast(member as regrole),
  admin_option
from
  pg_auth_members
where
  roleid =
  cast('regress_priv_user1' as regrole);

rollback;

revoke REGRESS_PRIV_USER1 from regress_priv_user2 cascade;

select
  cast(member as regrole),
  admin_option
from
  pg_auth_members
where
  roleid =
  cast('regress_priv_user1' as regrole);

grant REGRESS_PRIV_USER1 to regress_priv_user2 with ADMIN true;

grant REGRESS_PRIV_USER2 to regress_priv_user3;

set role to regress_priv_user3;

grant REGRESS_PRIV_USER1 to regress_priv_user4;

select
  cast(grantor as regrole)
from
  pg_auth_members
where
  roleid =
  cast('regress_priv_user1' as regrole) and
  member =
  cast('regress_priv_user4' as regrole);

reset role;

revoke REGRESS_PRIV_USER2 from regress_priv_user3 restrict;

revoke REGRESS_PRIV_USER1 from regress_priv_user2 cascade;

grant REGRESS_PRIV_USER1 to regress_priv_user2 with ADMIN true;

grant REGRESS_PRIV_USER1 to regress_priv_user3 granted by regress_priv_user2;

drop role regress_priv_user2;

reassign owned by regress_priv_user2 to regress_priv_user4;

drop role regress_priv_user2;

drop owned by regress_priv_user2;

drop role regress_priv_user2;

grant REGRESS_PRIV_USER1 to regress_priv_user3 with ADMIN true;

grant REGRESS_PRIV_USER1 to regress_priv_user4 granted by regress_priv_user3;

drop role regress_priv_user3;

drop role regress_priv_user4;

drop role regress_priv_user3;

grant REGRESS_PRIV_USER1 to regress_priv_user5 with ADMIN true;

grant REGRESS_PRIV_USER1 to regress_priv_user6 granted by regress_priv_user5;

drop role regress_priv_user5;

drop role regress_priv_user1, regress_priv_user5;

create user regress_priv_user1;

create user regress_priv_user2;

create user regress_priv_user3;

create user regress_priv_user4;

create user regress_priv_user5;

grant PG_READ_ALL_DATA to regress_priv_user6;

grant PG_WRITE_ALL_DATA to regress_priv_user7;

grant PG_READ_ALL_SETTINGS to regress_priv_user8 with ADMIN true;

grant REGRESS_PRIV_USER9 to regress_priv_user8;

set session authorization regress_priv_user8;

grant PG_READ_ALL_SETTINGS to regress_priv_user9 with ADMIN true;

set session authorization regress_priv_user9;

grant PG_READ_ALL_SETTINGS to regress_priv_user10;

set session authorization regress_priv_user8;

revoke PG_READ_ALL_SETTINGS
from regress_priv_user10
granted by regress_priv_user9
restrict;

revoke ADMIN option for PG_READ_ALL_SETTINGS from regress_priv_user9 restrict;

revoke PG_READ_ALL_SETTINGS from regress_priv_user9 restrict;

reset session_authorization;

revoke REGRESS_PRIV_USER9 from regress_priv_user8 restrict;

revoke ADMIN option for PG_READ_ALL_SETTINGS from regress_priv_user8 restrict;

set session authorization regress_priv_user8;

set role to pg_read_all_settings;

reset role;

reset session_authorization;

revoke SET option for PG_READ_ALL_SETTINGS from regress_priv_user8 restrict;

grant PG_READ_ALL_STATS to regress_priv_user8 with SET false;

set session authorization regress_priv_user8;

set role to pg_read_all_settings;

set role to pg_read_all_stats;

reset role;

reset session_authorization;

grant REGRESS_PRIV_USER9 to regress_priv_user8;

set session authorization regress_priv_user8;

set role to regress_priv_user9;

set debug_parallel_query = 0;

select
  session_user,
  current_role,
  current_user,
  current_setting('role') as role;

set debug_parallel_query = 1;

select
  session_user,
  current_role,
  current_user,
  current_setting('role') as role;

begin;

set session authorization regress_priv_user10;

set debug_parallel_query = 0;

select
  session_user,
  current_role,
  current_user,
  current_setting('role') as role;

set debug_parallel_query = 1;

select
  session_user,
  current_role,
  current_user,
  current_setting('role') as role;

rollback;

set debug_parallel_query = 0;

select
  session_user,
  current_role,
  current_user,
  current_setting('role') as role;

set debug_parallel_query = 1;

select
  session_user,
  current_role,
  current_user,
  current_setting('role') as role;

reset session_authorization;

set debug_parallel_query = 0;

select
  session_user = current_role as c_r_ok,
  session_user = current_user as c_u_ok,
  current_setting('role') as role;

set debug_parallel_query = 1;

select
  session_user = current_role as c_r_ok,
  session_user = current_user as c_u_ok,
  current_setting('role') as role;

reset debug_parallel_query;

revoke PG_READ_ALL_SETTINGS from regress_priv_user8 restrict;

drop role regress_priv_user10;

drop role regress_priv_user9;

drop role regress_priv_user8;

create group regress_priv_group1;

create group regress_priv_group2
  admin regress_priv_user1
  role regress_priv_user2;

alter group regress_priv_group1 add user regress_priv_user4;

grant REGRESS_PRIV_GROUP2 to regress_priv_user2 granted by regress_priv_user1;

set session authorization regress_priv_user3;

alter group regress_priv_group2 add user regress_priv_user2;

alter group regress_priv_group2 drop user regress_priv_user2;

set session authorization regress_priv_user1;

alter group regress_priv_group2 add user regress_priv_user2;

alter group regress_priv_group2 add user regress_priv_user2;

alter group regress_priv_group2 drop user regress_priv_user2;

alter role regress_priv_user2 password 'verysecret';

reset session_authorization;

alter group regress_priv_group2 drop user regress_priv_user2;

revoke ADMIN option for REGRESS_PRIV_GROUP2 from regress_priv_user1 restrict;

grant REGRESS_PRIV_GROUP2 to regress_priv_user4 with ADMIN true;

create function leak(int, int)
returns boolean
language internal
immutable
strict
as $function$
int4lt
$function$;

alter function leak(int, int) owner to regress_priv_user1;

grant REGRESS_PRIV_ROLE
to regress_priv_user1
with ADMIN true
granted by regress_priv_role;

grant REGRESS_PRIV_ROLE
to regress_priv_user1
with ADMIN true
granted by current_role;

revoke ADMIN option for REGRESS_PRIV_ROLE
from regress_priv_user1
granted by foo
restrict;

revoke ADMIN option for REGRESS_PRIV_ROLE
from regress_priv_user1
granted by regress_priv_user2
restrict;

revoke ADMIN option for REGRESS_PRIV_ROLE
from regress_priv_user1
granted by current_user
restrict;

revoke REGRESS_PRIV_ROLE
from regress_priv_user1
granted by current_role
restrict;

drop role regress_priv_role;

set session authorization regress_priv_user1;

select session_user, current_user;

create table atest1 (
  a int,
  b text
);

select * from atest1;

insert into atest1 values (1, 'one');

delete from atest1;

update atest1 set a = 1 where b = 'blech';

truncate atest1;

begin;

lock table atest1 in ACCESS EXCLUSIVE mode;

commit;

revoke all on table atest1 from public;

select * from atest1;

grant all on table atest1 to regress_priv_user2;

grant SELECT on table atest1 to regress_priv_user3, regress_priv_user4;

select * from atest1;

create table atest2 (
  col1 varchar(10),
  col2 boolean
);

select
  pg_get_acl(
    cast('pg_class' as regclass),
    cast(cast('atest2' as regclass) as oid),
    0
  );

grant SELECT on table atest2 to regress_priv_user2;

grant UPDATE on table atest2 to regress_priv_user3;

grant INSERT on table atest2 to regress_priv_user4 granted by current_user;

grant TRUNCATE on table atest2 to regress_priv_user5 granted by current_role;

select
  unnest(
    pg_get_acl(
      cast('pg_class' as regclass),
      cast(cast('atest2' as regclass) as oid),
      0
    )
  );

select pg_get_acl(cast('pg_class' as regclass), 0, 0);

select pg_get_acl(0, 0, 0);

grant TRUNCATE
on table atest2
to regress_priv_user4
granted by regress_priv_user5;

set session authorization regress_priv_user2;

select session_user, current_user;

select * from atest1;

select * from atest2;

insert into atest1 values (2, 'two');

insert into atest2 values ('foo', true);

insert into atest1 select 1, b from atest1;

update atest1 set a = 1 where a = 2;

update atest2 set col2 = not col2;

select * from atest1 for update;

select * from atest2 for update;

delete from atest2;

truncate atest2;

begin;

lock table atest2 in ACCESS EXCLUSIVE mode;

commit;

select * from atest1 where b in (select col1 from atest2);

select * from atest2 where col1 in (select b from atest1);

set session authorization regress_priv_user6;

select * from atest1;

select * from atest2;

insert into atest2 values ('foo', true);

set session authorization regress_priv_user7;

select * from atest1;

select * from atest2;

insert into atest2 values ('foo', true);

update atest2 set col2 = true;

delete from atest2;

update pg_catalog.pg_class set relname = '123';

delete from pg_catalog.pg_class;

update pg_toast.pg_toast_1213 set chunk_id = 1;

set session authorization regress_priv_user3;

select session_user, current_user;

select * from atest1;

select * from atest2;

insert into atest1 values (2, 'two');

insert into atest2 values ('foo', true);

insert into atest1 select 1, b from atest1;

update atest1 set a = 1 where a = 2;

update atest2 set col2 = null;

update atest2 set col2 = not col2;

update atest2 set col2 = true from atest1 where atest1.a = 5;

select * from atest1 for update;

select * from atest2 for update;

delete from atest2;

truncate atest2;

begin;

lock table atest2 in ACCESS EXCLUSIVE mode;

commit;

select * from atest1 where b in (select col1 from atest2);

select * from atest2 where col1 in (select b from atest1);

set session authorization regress_priv_user4;

select * from atest1;

set session authorization regress_priv_user1;

create table atest12
as
  select
    x as a,
    10001 - x as b
  from
    generate_series(1, 10000) as x;

create index on atest12 using btree (a);

create index on atest12 using btree ((abs(a)));

alter table atest12
  set (autovacuum_enabled = off);

set default_statistics_target = 10000;

vacuum (ANALYZE) atest12;

reset default_statistics_target;

create operator <<< (PROCEDURE = leak,
LEFTARG = int,
RIGHTARG = int,
RESTRICT = scalarltsel);

create view atest12v
as select * from atest12 where b <<< 5;

create view atest12sbv
  with (security_barrier = 'true')
as select * from atest12 where b <<< 5;

select * from atest12v as x, atest12v as y where x.a = y.b;

select * from atest12 as x, atest12 as y where x.a = y.b and abs(y.a) <<< 5;

select * from atest12sbv as x, atest12sbv as y where x.a = y.b;

set session authorization regress_priv_user2;

create function leak2(int, int)
returns boolean
language plpgsql
immutable
as $function$
begin raise notice 'leak % %', $1, $2; return $1 > $2; end
$function$;

create operator >>> (PROCEDURE = leak2,
LEFTARG = int,
RIGHTARG = int,
RESTRICT = scalargtsel);

select * from atest12 where a >>> 0;

select * from atest12v where a >>> 0;

select * from atest12sbv where a >>> 0;

set session authorization regress_priv_user1;

grant SELECT on table atest12v to public;

grant SELECT on table atest12sbv to public;

set session authorization regress_priv_user2;

select * from atest12v as x, atest12v as y where x.a = y.b;

select * from atest12sbv as x, atest12sbv as y where x.a = y.b;

select * from atest12v as x, atest12v as y where x.a = y.b and abs(y.a) <<< 5;

select
  *
from
  atest12sbv as x,
  atest12sbv as y
where
  x.a = y.b and abs(y.a) <<< 5;

set session authorization regress_priv_user1;

grant SELECT (a, b) on table atest12 to public;

set session authorization regress_priv_user2;

select * from atest12v as x, atest12v as y where x.a = y.b;

select * from atest12 as x, atest12 as y where x.a = y.b and abs(y.a) <<< 5;

drop function leak2(int, int) cascade;

set session authorization regress_priv_user3;

create table atest3 (
  one int,
  two int,
  three int
);

grant DELETE on table atest3 to regress_priv_group2;

set session authorization regress_priv_user1;

select * from atest3;

delete from atest3;

begin;

reset session_authorization;

alter role regress_priv_user1 noinherit;

set session authorization regress_priv_user1;

savepoint s1;

delete from atest3;

rollback to savepoint s1;

reset session_authorization;

grant REGRESS_PRIV_GROUP2 to regress_priv_user1 with INHERIT false;

set session authorization regress_priv_user1;

delete from atest3;

rollback to savepoint s1;

reset session_authorization;

revoke INHERIT option for REGRESS_PRIV_GROUP2 from regress_priv_user1 restrict;

set session authorization regress_priv_user1;

delete from atest3;

rollback;

set session authorization regress_priv_user3;

create view atestv1
as select * from atest1;

create view atestv2
as select * from atest2;

create view atestv3
as select * from atest3;

create view atestv0
as select 0 as x where false;

select * from atestv1;

select * from atestv2;

grant SELECT on table atestv1, atestv3 to regress_priv_user4;

grant SELECT on table atestv2 to regress_priv_user2;

set session authorization regress_priv_user4;

select * from atestv1;

select * from atestv2;

select * from atestv3;

select * from atestv0;

select
  *
from
  (
    (select
      a.q1 as x
    from
      int8_tbl as a
    offset 0)
    union all
    (select
      b.q2 as x
    from
      int8_tbl as b
    offset 0)
  )
  as ss
where
  false;

set constraint_exclusion = 'on';

select
  *
from
  (
    select
      a.q1 as x,
      random()
    from
      int8_tbl as a
    where
      q1 > 0
    union all
    select
      b.q2 as x,
      random()
    from
      int8_tbl as b
    where
      q2 > 0
  )
  as ss
where
  x < 0;

reset constraint_exclusion;

create view atestv4
as select * from atestv3;

select * from atestv4;

grant SELECT on table atestv4 to regress_priv_user2;

set session authorization regress_priv_user2;

select * from atestv3;

select * from atestv4;

select * from atest2;

select * from atestv2;

set session authorization regress_priv_user1;

create table atest5 (
  one int,
  two int unique,
  three int,
  four int unique
);

create table atest6 (
  one int,
  two int,
  blue int
);

grant SELECT (one),
INSERT (two),
UPDATE (three)
on table atest5
to regress_priv_user4;

grant all (one) on table atest5 to regress_priv_user3;

select
  unnest(
    pg_get_acl(
      cast('pg_class' as regclass),
      cast(cast('atest5' as regclass) as oid),
      1
    )
  );

select
  unnest(
    pg_get_acl(
      cast('pg_class' as regclass),
      cast(cast('atest5' as regclass) as oid),
      2
    )
  );

select
  unnest(
    pg_get_acl(
      cast('pg_class' as regclass),
      cast(cast('atest5' as regclass) as oid),
      3
    )
  );

select
  unnest(
    pg_get_acl(
      cast('pg_class' as regclass),
      cast(cast('atest5' as regclass) as oid),
      4
    )
  );

insert into atest5 values (1, 2, 3);

set session authorization regress_priv_user4;

select * from atest5;

select one from atest5;

copy atest5 (one) to stdout;

select two from atest5;

copy atest5 (two) to stdout;

select atest5 from atest5;

copy atest5 (one, two) to stdout;

select 1 from atest5;

select 1 from atest5 as a inner join atest5 as b using ("one");

select 1 from atest5 as a inner join atest5 as b using ("two");

select 1 from atest5 as a natural join atest5 as b;

select * from (atest5 as a inner join atest5 as b using ("one")) as "j";

select j.* from (atest5 as a inner join atest5 as b using ("one")) as "j";

select
  j.* is null
from
  (atest5 as a
  inner join
    atest5 as b
  using ("one")) as "j";

select
  one
from
  (atest5 as a
  inner join
    atest5 as b (one, x, y, z)
  using ("one")) as "j";

select
  j.one
from
  (atest5 as a
  inner join
    atest5 as b (one, x, y, z)
  using ("one")) as "j";

select
  two
from
  (atest5 as a
  inner join
    atest5 as b (one, x, y, z)
  using ("one")) as "j";

select
  j.two
from
  (atest5 as a
  inner join
    atest5 as b (one, x, y, z)
  using ("one")) as "j";

select
  y
from
  (atest5 as a
  inner join
    atest5 as b (one, x, y, z)
  using ("one")) as "j";

select
  j.y
from
  (atest5 as a
  inner join
    atest5 as b (one, x, y, z)
  using ("one")) as "j";

select * from atest5 as a inner join atest5 as b using ("one");

select a.* from atest5 as a inner join atest5 as b using ("one");

select a.* is null from atest5 as a inner join atest5 as b using ("one");

select two from atest5 as a inner join atest5 as b (one, x, y, z) using ("one");

select
  a.two
from
  atest5 as a
  inner join
    atest5 as b (one, x, y, z)
  using ("one");

select y from atest5 as a inner join atest5 as b (one, x, y, z) using ("one");

select b.y from atest5 as a inner join atest5 as b (one, x, y, z) using ("one");

select
  y
from
  atest5 as a
  left outer join
    atest5 as b (one, x, y, z)
  using ("one");

select
  b.y
from
  atest5 as a
  left outer join
    atest5 as b (one, x, y, z)
  using ("one");

select
  y
from
  atest5 as a
  full outer join
    atest5 as b (one, x, y, z)
  using ("one");

select
  b.y
from
  atest5 as a
  full outer join
    atest5 as b (one, x, y, z)
  using ("one");

select 1 from atest5 where two = 2;

select * from atest1, atest5;

select atest1.* from atest1, atest5;

select atest1.*, atest5.one from atest1, atest5;

select
  atest1.*,
  atest5.one
from
  atest1
  inner join
    atest5
  on atest1.a = atest5.two;

select
  atest1.*,
  atest5.one
from
  atest1
  inner join
    atest5
  on atest1.a = atest5.one;

select one, two from atest5;

set session authorization regress_priv_user1;

grant SELECT (one, two) on table atest6 to regress_priv_user4;

set session authorization regress_priv_user4;

select one, two from atest5 natural join atest6;

set session authorization regress_priv_user1;

grant SELECT (two) on table atest5 to regress_priv_user4;

set session authorization regress_priv_user4;

select one, two from atest5 natural join atest6;

insert into atest5 (two) values (3);

insert into atest5 (three) values (4);

insert into atest5 values (5, 5, 5);

update atest5 set three = 10;

update atest5 set one = 8;

update atest5 set three = 5, one = 2;

insert into atest5 (two) values (6) on conflict (two) do update set three = 10;

insert into atest5 (two)
values (6)
on conflict
(two)
do
update
set three = 10
returning atest5.three;

insert into atest5 (two)
values (6)
on conflict
(two)
do
update
set three = 10
returning atest5.one;

insert into atest5 (two)
values (6)
on conflict
(two)
do
update
set three = excluded.one;

insert into atest5 (two)
values (6)
on conflict
(two)
do
update
set three = excluded.three;

insert into atest5 (two) values (6) on conflict (two) do update set one = 8;

insert into atest5 (three)
values (4)
on conflict
(two)
do
update
set three = 10;

insert into atest5 (four) values (4);

set session authorization regress_priv_user1;

grant INSERT (four) on table atest5 to regress_priv_user4;

set session authorization regress_priv_user4;

insert into atest5 (four) values (4) on conflict (four) do update set three = 3;

insert into atest5 (four)
values (4)
on conflict
on constraint atest5_four_key
do
update
set three = 3;

insert into atest5 (four) values (4);

set session authorization regress_priv_user1;

grant SELECT (four) on table atest5 to regress_priv_user4;

set session authorization regress_priv_user4;

insert into atest5 (four) values (4) on conflict (four) do update set three = 3;

insert into atest5 (four)
values (4)
on conflict
on constraint atest5_four_key
do
update
set three = 3;

set session authorization regress_priv_user1;

revoke all (one) on table atest5 from regress_priv_user4;

grant SELECT (one, two, blue) on table atest6 to regress_priv_user4;

set session authorization regress_priv_user4;

select one from atest5;

update atest5 set one = 1;

select atest6 from atest6;

copy atest6 to stdout;

set session authorization regress_priv_user1;

create table mtarget (
  a int,
  b text
);

create table msource (
  a int,
  b text
);

insert into mtarget values (1, 'init1'), (2, 'init2');

insert into msource values (1, 'source1'), (2, 'source2'), (3, 'source3');

grant SELECT (a) on table msource to regress_priv_user4;

grant SELECT (a) on table mtarget to regress_priv_user4;

grant INSERT (a, b) on table mtarget to regress_priv_user4;

grant UPDATE (b) on table mtarget to regress_priv_user4;

set session authorization regress_priv_user4;

begin;

rollback;

set session authorization regress_priv_user1;

grant SELECT (b) on table msource to regress_priv_user4;

set session authorization regress_priv_user4;

begin;

rollback;

begin;

rollback;

set session authorization regress_priv_user1;

grant DELETE on table mtarget to regress_priv_user4;

begin;

rollback;

set session authorization regress_priv_user1;

create table t1 (
  c1 int,
  c2 int,
  c3 int check (c3 < 5),
  primary key (c1, c2)
);

grant SELECT (c1) on table t1 to regress_priv_user2;

grant INSERT (c1, c2, c3) on table t1 to regress_priv_user2;

grant UPDATE (c1, c2, c3) on table t1 to regress_priv_user2;

insert into t1 values (1, 1, 1);

insert into t1 values (1, 2, 1);

insert into t1 values (2, 1, 2);

insert into t1 values (2, 2, 2);

insert into t1 values (3, 1, 3);

set session authorization regress_priv_user2;

insert into t1 (c1, c2) values (1, 1);

update t1 set c2 = 1;

insert into t1 (c1, c2) values (null, null);

insert into t1 (c3) values (null);

insert into t1 (c1) values (5);

update t1 set c3 = 10;

set session authorization regress_priv_user1;

drop table t1;

create table errtst (
  a text,
  b text not null,
  c text,
  secret1 text,
  secret2 text
)
partition by LIST(a);

create table errtst_part_1 (
  secret2 text,
  c text,
  a text,
  b text not null,
  secret1 text
);

create table errtst_part_2 (
  secret1 text,
  secret2 text,
  a text,
  c text,
  b text not null
);

alter table errtst
  attach partition
  errtst_part_1 for values in ('aaa');

alter table errtst
  attach partition
  errtst_part_2 for values in ('aaaa');

grant SELECT (a, b, c) on table errtst to regress_priv_user2;

grant UPDATE (a, b, c) on table errtst to regress_priv_user2;

grant INSERT (a, b, c) on table errtst to regress_priv_user2;

insert into errtst_part_1 (a, b, c, secret1, secret2)
values
  (
    'aaa',
    'bbb',
    'ccc',
    'the body',
    'is in the attic'
  );

set session authorization regress_priv_user2;

insert into errtst (a, b) values ('aaa', null);

update errtst set b = null;

update errtst set a = 'aaa', b = null;

update errtst set a = 'aaaa', b = null;

update errtst set a = 'aaaa', b = null where a = 'aaa';

set session authorization regress_priv_user1;

drop table errtst;

set session authorization regress_priv_user1;

alter table atest6
  add column three int;

grant DELETE on table atest5 to regress_priv_user3;

grant SELECT (two) on table atest5 to regress_priv_user3;

revoke all (one) on table atest5 from regress_priv_user3;

grant SELECT (one) on table atest5 to regress_priv_user4;

set session authorization regress_priv_user4;

select atest6 from atest6;

select one from atest5 natural join atest6;

set session authorization regress_priv_user1;

alter table atest6
  drop column three;

set session authorization regress_priv_user4;

select atest6 from atest6;

select one from atest5 natural join atest6;

set session authorization regress_priv_user1;

alter table atest6
  drop column two;

revoke SELECT (one, blue) on table atest6 from regress_priv_user4;

set session authorization regress_priv_user4;

select * from atest6;

select 1 from atest6;

set session authorization regress_priv_user3;

delete from atest5 where one = 1;

delete from atest5 where two = 2;

set session authorization regress_priv_user1;

create table atestp1 (
  f1 int,
  f2 int
);

create table atestp2 (
  fx int,
  fy int
);

create table atestc (fz int)
inherits (atestp1,
atestp2);

grant SELECT (fx, fy, tableoid) on table atestp2 to regress_priv_user2;

grant SELECT (fx) on table atestc to regress_priv_user2;

set session authorization regress_priv_user2;

select fx from atestp2;

select fy from atestp2;

select atestp2 from atestp2;

select tableoid from atestp2;

select fy from atestc;

set session authorization regress_priv_user1;

grant SELECT (fy, tableoid) on table atestc to regress_priv_user2;

set session authorization regress_priv_user2;

select fx from atestp2;

select fy from atestp2;

select atestp2 from atestp2;

select tableoid from atestp2;

set session authorization regress_priv_user1;

revoke all on table atestc from regress_priv_user2;

grant all on table atestp1 to regress_priv_user2;

set session authorization regress_priv_user2;

select f2 from atestp1;

select f2 from atestc;

delete from atestp1;

delete from atestc;

update atestp1 set f1 = 1;

update atestc set f1 = 1;

truncate atestp1;

truncate atestc;

begin;

lock table atestp1 in ACCESS EXCLUSIVE mode;

commit;

begin;

lock table atestc in ACCESS EXCLUSIVE mode;

commit;

revoke all on language sql from public;

grant USAGE on language sql to regress_priv_user1;

grant USAGE on language c to public;

set session authorization regress_priv_user1;

grant USAGE on language sql to regress_priv_user2;

create function priv_testfunc1(int)
returns int
language sql
as $function$
select 2 * $1;
$function$;

create function priv_testfunc2(int)
returns int
language sql
as $function$
select 3 * $1;
$function$;

create aggregate priv_testagg1 (int) (sfunc = int4pl, stype = int);

create procedure priv_testproc1(int)
language sql
as $procedure$
select $1;
$procedure$;

revoke all
on function priv_testfunc1(int),
priv_testfunc2(int),
priv_testagg1(int)
from public;

grant EXECUTE
on function priv_testfunc1(int),
priv_testfunc2(int),
priv_testagg1(int)
to regress_priv_user2;

revoke all on function priv_testproc1(int) from public;

revoke all on procedure priv_testproc1(int) from public;

grant EXECUTE on procedure priv_testproc1(int) to regress_priv_user2;

grant USAGE on function priv_testfunc1(int) to regress_priv_user3;

grant USAGE on function priv_testagg1(int) to regress_priv_user3;

grant USAGE on procedure priv_testproc1(int) to regress_priv_user3;

grant all on function priv_testfunc1(int) to regress_priv_user4;

grant all on function priv_testfunc_nosuch(int) to regress_priv_user4;

grant all on function priv_testagg1(int) to regress_priv_user4;

grant all on procedure priv_testproc1(int) to regress_priv_user4;

create function priv_testfunc4(boolean)
returns text
language sql
security definer
as $function$
select col1 from atest2 where col2 = $1;
$function$;

grant EXECUTE on function priv_testfunc4(boolean) to regress_priv_user3;

set session authorization regress_priv_user2;

select priv_testfunc1(5), priv_testfunc2(5);

create function priv_testfunc3(int)
returns int
language sql
as $function$
select 2 * $1;
$function$;

select priv_testagg1(x) from (values (1), (2), (3)) as _ (x);

call priv_testproc1(6);

set session authorization regress_priv_user3;

select priv_testfunc1(5);

select priv_testagg1(x) from (values (1), (2), (3)) as _ (x);

call priv_testproc1(6);

select col1 from atest2 where col2 = true;

select priv_testfunc4(true);

set session authorization regress_priv_user4;

select priv_testfunc1(5);

select priv_testagg1(x) from (values (1), (2), (3)) as _ (x);

call priv_testproc1(6);

drop function priv_testfunc1(int);

drop aggregate priv_testagg1(int);

drop procedure priv_testproc1(int);

drop function priv_testfunc1(int);

grant all on language sql to public;

begin;

select cast(cast('{1}' as int[]) as bigint[]);

revoke all on function int8(int) from public;

select cast(cast('{1}' as int[]) as bigint[]);

set session authorization regress_priv_user4;

select cast(cast('{1}' as int[]) as bigint[]);

rollback;

create type priv_testtype1 as (a int, b text);

revoke USAGE on type priv_testtype1 from public;

grant USAGE on type priv_testtype1 to regress_priv_user2;

grant USAGE on type _priv_testtype1 to regress_priv_user2;

grant USAGE on domain priv_testtype1 to regress_priv_user2;

create domain priv_testdomain1 as int;

revoke USAGE on domain priv_testdomain1 from public;

grant USAGE on domain priv_testdomain1 to regress_priv_user2;

grant USAGE on type priv_testdomain1 to regress_priv_user2;

set session authorization regress_priv_user1;

create aggregate priv_testagg1a (
  priv_testdomain1
) (
  sfunc = int4_sum,
  stype = bigint
);

create domain priv_testdomain2a as priv_testdomain1;

create domain priv_testdomain3a as int;

create function castfunc(int)
returns priv_testdomain3a
language sql
as $function$
SELECT $1::priv_testdomain3a
$function$;

create cast (priv_testdomain1 as priv_testdomain3a) with function castfunc(int);

drop function castfunc(int) cascade;

drop domain priv_testdomain3a;

create function priv_testfunc5a(a priv_testdomain1)
returns int
language sql
as $function$
SELECT $1
$function$;

create function priv_testfunc6a(b int)
returns priv_testdomain1
language sql
as $function$
SELECT $1::priv_testdomain1
$function$;

create operator !+! (PROCEDURE = int4pl,
LEFTARG = priv_testdomain1,
RIGHTARG = priv_testdomain1);

create table test5a (
  a int,
  b priv_testdomain1
);

create table test6a of priv_testtype1;

create table test10a (
  a int[],
  b priv_testtype1[]
);

create table test9a (
  a int,
  b int
);

alter table test9a
  add column c priv_testdomain1;

alter table test9a
  alter column b type priv_testdomain1;

create type test7a as (a int, b priv_testdomain1);

create type test8a as (a int, b int);

alter type test8a
  add attribute c priv_testdomain1;

alter type test8a
  alter attribute b type priv_testdomain1;

create table test11a as select cast(1 as priv_testdomain1) as a;

revoke all on type priv_testtype1 from public;

set session authorization regress_priv_user2;

create aggregate priv_testagg1b (
  priv_testdomain1
) (
  sfunc = int4_sum,
  stype = bigint
);

create domain priv_testdomain2b as priv_testdomain1;

create domain priv_testdomain3b as int;

create function castfunc(int)
returns priv_testdomain3b
language sql
as $function$
SELECT $1::priv_testdomain3b
$function$;

create cast (priv_testdomain1 as priv_testdomain3b) with function castfunc(int);

create function priv_testfunc5b(a priv_testdomain1)
returns int
language sql
as $function$
SELECT $1
$function$;

create function priv_testfunc6b(b int)
returns priv_testdomain1
language sql
as $function$
SELECT $1::priv_testdomain1
$function$;

create operator !! (PROCEDURE = priv_testfunc5b, RIGHTARG = priv_testdomain1);

create table test5b (
  a int,
  b priv_testdomain1
);

create table test6b of priv_testtype1;

create table test10b (
  a int[],
  b priv_testtype1[]
);

create table test9b (
  a int,
  b int
);

alter table test9b
  add column c priv_testdomain1;

alter table test9b
  alter column b type priv_testdomain1;

create type test7b as (a int, b priv_testdomain1);

create type test8b as (a int, b int);

alter type test8b
  add attribute c priv_testdomain1;

alter type test8b
  alter attribute b type priv_testdomain1;

create table test11b as select cast(1 as priv_testdomain1) as a;

revoke all on type priv_testtype1 from public;

drop aggregate priv_testagg1b(priv_testdomain1);

drop domain priv_testdomain2b;

drop operator !! (none, priv_testdomain1);

drop function priv_testfunc5b(priv_testdomain1);

drop function priv_testfunc6b(int);

drop table test5b;

drop table test6b;

drop table test9b;

drop table test10b;

drop type test7b;

drop type test8b;

drop cast (priv_testdomain1 as priv_testdomain3b);

drop function castfunc(int) cascade;

drop domain priv_testdomain3b;

drop table test11b;

drop type priv_testtype1;

drop domain priv_testdomain1;

set session authorization regress_priv_user5;

truncate atest2;

truncate atest3;

select has_table_privilege(null, 'pg_authid', 'select');

select has_table_privilege('pg_shad', 'select');

select has_table_privilege('nosuchuser', 'pg_authid', 'select');

select has_table_privilege('pg_authid', 'sel');

select has_table_privilege(-999999, 'pg_authid', 'update');

select has_table_privilege(1, 'select');

select has_table_privilege(current_user, 'pg_authid', 'select');

select has_table_privilege(current_user, 'pg_authid', 'insert');

select
  has_table_privilege(
    t2.oid,
    'pg_authid',
    'update'
  )
from
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select
  has_table_privilege(
    t2.oid,
    'pg_authid',
    'delete'
  )
from
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select
  has_table_privilege(
    current_user,
    t1.oid,
    'references'
  )
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_authid'
  )
  as t1;

select
  has_table_privilege(
    t2.oid,
    t1.oid,
    'select'
  )
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_authid'
  )
  as t1,
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select
  has_table_privilege(
    t2.oid,
    t1.oid,
    'insert'
  )
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_authid'
  )
  as t1,
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select has_table_privilege('pg_authid', 'update');

select has_table_privilege('pg_authid', 'delete');

select has_table_privilege('pg_authid', 'truncate');

select
  has_table_privilege(t1.oid, 'select')
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_authid'
  )
  as t1;

select
  has_table_privilege(t1.oid, 'trigger')
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_authid'
  )
  as t1;

set session authorization regress_priv_user3;

select has_table_privilege(current_user, 'pg_class', 'select');

select has_table_privilege(current_user, 'pg_class', 'insert');

select
  has_table_privilege(
    t2.oid,
    'pg_class',
    'update'
  )
from
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select
  has_table_privilege(
    t2.oid,
    'pg_class',
    'delete'
  )
from
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select
  has_table_privilege(
    current_user,
    t1.oid,
    'references'
  )
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_class'
  )
  as t1;

select
  has_table_privilege(
    t2.oid,
    t1.oid,
    'select'
  )
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_class'
  )
  as t1,
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select
  has_table_privilege(
    t2.oid,
    t1.oid,
    'insert'
  )
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_class'
  )
  as t1,
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select has_table_privilege('pg_class', 'update');

select has_table_privilege('pg_class', 'delete');

select has_table_privilege('pg_class', 'truncate');

select
  has_table_privilege(t1.oid, 'select')
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_class'
  )
  as t1;

select
  has_table_privilege(t1.oid, 'trigger')
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'pg_class'
  )
  as t1;

select has_table_privilege(current_user, 'atest1', 'select');

select has_table_privilege(current_user, 'atest1', 'insert');

select
  has_table_privilege(
    t2.oid,
    'atest1',
    'update'
  )
from
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select
  has_table_privilege(
    t2.oid,
    'atest1',
    'delete'
  )
from
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select
  has_table_privilege(
    current_user,
    t1.oid,
    'references'
  )
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'atest1'
  )
  as t1;

select
  has_table_privilege(
    t2.oid,
    t1.oid,
    'select'
  )
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'atest1'
  )
  as t1,
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select
  has_table_privilege(
    t2.oid,
    t1.oid,
    'insert'
  )
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'atest1'
  )
  as t1,
  (
    select
      oid
    from
      pg_roles
    where
      rolname = current_user
  )
  as t2;

select has_table_privilege('atest1', 'update');

select has_table_privilege('atest1', 'delete');

select has_table_privilege('atest1', 'truncate');

select
  has_table_privilege(t1.oid, 'select')
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'atest1'
  )
  as t1;

select
  has_table_privilege(t1.oid, 'trigger')
from
  (
    select
      oid
    from
      pg_class
    where
      relname = 'atest1'
  )
  as t1;

select has_column_privilege('pg_authid', null, 'select');

select has_column_privilege('pg_authid', 'nosuchcol', 'select');

select has_column_privilege(9999, 'nosuchcol', 'select');

select has_column_privilege(9999, cast(99 as smallint), 'select');

select has_column_privilege('pg_authid', cast(99 as smallint), 'select');

select has_column_privilege(9999, cast(99 as smallint), 'select');

create temporary table mytable (
  f1 int,
  f2 int,
  f3 int
);

alter table mytable
  drop column f2;

select has_column_privilege('mytable', 'f2', 'select');

select
  has_column_privilege(
    'mytable',
    '........pg.dropped.2........',
    'select'
  );

select has_column_privilege('mytable', cast(2 as smallint), 'select');

select has_column_privilege('mytable', cast(99 as smallint), 'select');

revoke SELECT on table mytable from regress_priv_user3;

select has_column_privilege('mytable', cast(2 as smallint), 'select');

select has_column_privilege('mytable', cast(99 as smallint), 'select');

drop table mytable;

set session authorization regress_priv_user1;

create table atest4 (a int);

grant SELECT on table atest4 to regress_priv_user2 with grant option;

grant UPDATE on table atest4 to regress_priv_user2;

grant SELECT on table atest4 to regress_priv_group1 with grant option;

set session authorization regress_priv_user2;

grant SELECT on table atest4 to regress_priv_user3;

grant UPDATE on table atest4 to regress_priv_user3;

set session authorization regress_priv_user1;

revoke SELECT on table atest4 from regress_priv_user3;

select has_table_privilege('regress_priv_user3', 'atest4', 'SELECT');

revoke SELECT on table atest4 from regress_priv_user2;

revoke grant option for SELECT on table atest4 from regress_priv_user2 cascade;

select has_table_privilege('regress_priv_user2', 'atest4', 'SELECT');

select has_table_privilege('regress_priv_user3', 'atest4', 'SELECT');

select
  has_table_privilege(
    'regress_priv_user1',
    'atest4',
    'SELECT WITH GRANT OPTION'
  );

create role regress_sro_user;

create function sro_ifun(int)
returns int
language plpgsql
immutable
as $function$
BEGIN
	-- Below we set the table's owner to regress_sro_user
	ASSERT current_user = 'regress_sro_user',
		format('sro_ifun(%s) called by %s', $1, current_user);
	RETURN $1;
END;
$function$;

create table sro_tab (a int);

alter table sro_tab
  owner to regress_sro_user;

insert into sro_tab values (1), (2), (3);

create index "sro_idx"
on sro_tab
using btree
(
  (sro_ifun(a) + sro_ifun(0))
)
where
  sro_ifun(a + 10) > sro_ifun(10);

drop index sro_idx;

create index concurrently "sro_idx"
on sro_tab
using btree
(
  (sro_ifun(a) + sro_ifun(0))
)
where
  sro_ifun(a + 10) > sro_ifun(10);

reindex table sro_tab;

reindex index sro_idx;

reindex (CONCURRENTLY) table sro_tab;

drop index sro_idx;

create index "sro_cluster_idx"
on sro_tab
using btree
(
  (sro_ifun(a) + sro_ifun(0))
);

cluster sro_tab using sro_cluster_idx;

drop index sro_cluster_idx;

create index "sro_brin" on sro_tab using brin ((sro_ifun(a) + sro_ifun(0)));

select brin_desummarize_range('sro_brin', 0);

select brin_summarize_range('sro_brin', 0);

drop table sro_tab;

create table sro_ptab (a int)
partition by range(a);

alter table sro_ptab
  owner to regress_sro_user;

create table sro_part partition of sro_ptab for values from (1) to (10);

alter table sro_part
  owner to regress_sro_user;

insert into sro_ptab values (1), (2), (3);

create index "sro_pidx"
on sro_ptab
using btree
(
  (sro_ifun(a) + sro_ifun(0))
)
where
  sro_ifun(a + 10) > sro_ifun(10);

reindex table sro_ptab;

reindex (CONCURRENTLY) index sro_pidx;

set session authorization regress_sro_user;

create function unwanted_grant()
returns void
language sql
as $function$
GRANT regress_priv_group2 TO regress_sro_user
$function$;

create function mv_action()
returns boolean
language sql
as $function$
DECLARE c CURSOR WITH HOLD FOR SELECT public.unwanted_grant(); SELECT true
$function$;

create materialized view sro_mv as select mv_action() with no data;

refresh materialized view sro_mv;

refresh materialized view sro_mv;

set session authorization regress_sro_user;

create table sro_trojan_table ();

create function sro_trojan()
returns trigger
language plpgsql
as $function$
BEGIN PERFORM public.unwanted_grant(); RETURN NULL; END
$function$;

create constraint trigger t
after insert
on sro_trojan_table
deferrable
initially deferred
for each row
execute function sro_trojan();

create or replace function mv_action()
returns boolean
language sql
as $function$
INSERT INTO public.sro_trojan_table DEFAULT VALUES; SELECT true
$function$;

refresh materialized view sro_mv;

refresh materialized view sro_mv;

begin;

set constraints all immediate;

refresh materialized view sro_mv;

commit;

set session authorization regress_sro_user;

create function unwanted_grant_nofail(int)
returns int
language plpgsql
immutable
as $function$
BEGIN
	PERFORM public.unwanted_grant();
	RAISE WARNING 'owned';
	RETURN 1;
EXCEPTION WHEN OTHERS THEN
	RETURN 2;
END
$function$;

create materialized view sro_index_mv as select 1 as c;

create unique index
on sro_index_mv
using btree
(
  c
)
where
  unwanted_grant_nofail(1) > 0;

refresh materialized view concurrently sro_index_mv;

refresh materialized view sro_index_mv;

drop owned by regress_sro_user;

drop role regress_sro_user;

set session authorization regress_priv_user4;

create function dogrant_ok()
returns void
language sql
security definer
as $function$
GRANT regress_priv_group2 TO regress_priv_user5
$function$;

grant REGRESS_PRIV_GROUP2 to regress_priv_user5;

set role to regress_priv_group2;

grant REGRESS_PRIV_GROUP2 to regress_priv_user5;

set session authorization regress_priv_user1;

grant REGRESS_PRIV_GROUP2 to regress_priv_user5;

select dogrant_ok();

set role to regress_priv_group2;

grant REGRESS_PRIV_GROUP2 to regress_priv_user5;

set session authorization regress_priv_group2;

grant REGRESS_PRIV_GROUP2 to regress_priv_user5;

set session authorization regress_priv_user4;

drop function dogrant_ok();

revoke REGRESS_PRIV_GROUP2 from regress_priv_user5 restrict;

create sequence x_seq;

grant USAGE on table x_seq to regress_priv_user2;

select has_sequence_privilege('regress_priv_user1', 'atest1', 'SELECT');

select has_sequence_privilege('regress_priv_user1', 'x_seq', 'INSERT');

select has_sequence_privilege('regress_priv_user1', 'x_seq', 'SELECT');

set session authorization regress_priv_user2;

select has_sequence_privilege('x_seq', 'USAGE');

set session authorization regress_priv_user1;

select lo_create(1001);

select lo_create(1002);

select lo_create(1003);

select lo_create(1004);

select lo_create(1005);

grant all on large object 1001 to public;

grant SELECT on large object 1003 to regress_priv_user2;

grant SELECT, UPDATE on large object 1004 to regress_priv_user2;

grant all on large object 1005 to regress_priv_user2;

grant SELECT on large object 1005 to regress_priv_user2 with grant option;

grant SELECT, INSERT on large object 1001 to public;

grant SELECT, UPDATE on large object 1001 to nosuchuser;

grant SELECT, UPDATE on large object 999 to public;

set session authorization regress_priv_user2;

select lo_create(2001);

select lo_create(2002);

select loread(lo_open(1001, cast(X'20000' as int)), 32);

select lowrite(lo_open(1001, cast(X'40000' as int)), 'abcd');

select loread(lo_open(1001, cast(X'40000' as int)), 32);

select loread(lo_open(1002, cast(X'40000' as int)), 32);

select loread(lo_open(1003, cast(X'40000' as int)), 32);

select loread(lo_open(1004, cast(X'40000' as int)), 32);

select lowrite(lo_open(1001, cast(X'20000' as int)), 'abcd');

select lowrite(lo_open(1002, cast(X'20000' as int)), 'abcd');

select lowrite(lo_open(1003, cast(X'20000' as int)), 'abcd');

select lowrite(lo_open(1004, cast(X'20000' as int)), 'abcd');

grant SELECT on large object 1005 to regress_priv_user3;

grant UPDATE on large object 1006 to regress_priv_user3;

revoke all on large object 2001, 2002 from public;

grant all on large object 2001 to regress_priv_user3;

select lo_unlink(1001);

select lo_unlink(2002);

select
  oid,
  pg_get_userbyid(lomowner) as ownername,
  lomacl
from
  pg_largeobject_metadata
where
  oid >= 1000 and oid < 3000
order by oid;

set session authorization regress_priv_user3;

select loread(lo_open(1001, cast(X'40000' as int)), 32);

select loread(lo_open(1003, cast(X'40000' as int)), 32);

select loread(lo_open(1005, cast(X'40000' as int)), 32);

select lo_truncate(lo_open(1005, cast(X'20000' as int)), 10);

select lo_truncate(lo_open(2001, cast(X'20000' as int)), 10);

select has_largeobject_privilege(1001, 'SELECT');

select has_largeobject_privilege(1002, 'SELECT');

select has_largeobject_privilege(1003, 'SELECT');

select has_largeobject_privilege(1004, 'SELECT');

select has_largeobject_privilege(1001, 'UPDATE');

select has_largeobject_privilege(1002, 'UPDATE');

select has_largeobject_privilege(1003, 'UPDATE');

select has_largeobject_privilege(1004, 'UPDATE');

select has_largeobject_privilege(9999, 'SELECT');

set session authorization regress_priv_user2;

select has_largeobject_privilege(1001, 'SELECT');

select has_largeobject_privilege(1002, 'SELECT');

select has_largeobject_privilege(1003, 'SELECT');

select has_largeobject_privilege(1004, 'SELECT');

select has_largeobject_privilege(1001, 'UPDATE');

select has_largeobject_privilege(1002, 'UPDATE');

select has_largeobject_privilege(1003, 'UPDATE');

select has_largeobject_privilege(1004, 'UPDATE');

select has_largeobject_privilege('regress_priv_user3', 1001, 'SELECT');

select has_largeobject_privilege('regress_priv_user3', 1003, 'SELECT');

select has_largeobject_privilege('regress_priv_user3', 1005, 'SELECT');

select has_largeobject_privilege('regress_priv_user3', 1005, 'UPDATE');

select has_largeobject_privilege('regress_priv_user3', 2001, 'UPDATE');

set lo_compat_privileges = 'false';

set session authorization regress_priv_user4;

select has_largeobject_privilege(1002, 'SELECT');

select has_largeobject_privilege(1002, 'UPDATE');

select loread(lo_open(1002, cast(X'40000' as int)), 32);

select lowrite(lo_open(1002, cast(X'20000' as int)), 'abcd');

select lo_truncate(lo_open(1002, cast(X'20000' as int)), 10);

select lo_put(1002, 1, 'abcd');

select lo_unlink(1002);

select lo_export(1001, '/dev/null');

select lo_import('/dev/null');

select lo_import('/dev/null', 2003);

set lo_compat_privileges = 'true';

set session authorization regress_priv_user4;

select has_largeobject_privilege(1002, 'SELECT');

select has_largeobject_privilege(1002, 'UPDATE');

select loread(lo_open(1002, cast(X'40000' as int)), 32);

select lowrite(lo_open(1002, cast(X'20000' as int)), 'abcd');

select lo_truncate(lo_open(1002, cast(X'20000' as int)), 10);

select lo_unlink(1002);

select lo_export(1001, '/dev/null');

select * from pg_largeobject limit 0;

set session authorization regress_priv_user1;

select * from pg_largeobject limit 0;

reset session_authorization;

begin;

create or replace function terminate_nothrow(pid int)
returns boolean
language plpgsql
security definer
set client_min_messages = error
as $function$
BEGIN
	RETURN pg_terminate_backend($1);
EXCEPTION WHEN OTHERS THEN
	RETURN false;
END
$function$;

alter function terminate_nothrow owner to pg_signal_backend;

select
  backend_type
from
  pg_stat_activity
where
  case
    when coalesce(usesysid, 10) = 10
    then terminate_nothrow(pid)
  end;

rollback;

reset session_authorization;

grant PG_DATABASE_OWNER to regress_priv_user1;

grant REGRESS_PRIV_USER1 to pg_database_owner;

create table datdba_only ();

alter table datdba_only
  owner to pg_database_owner;

revoke DELETE on table datdba_only from pg_database_owner;

select
  pg_has_role(
    'regress_priv_user1',
    'pg_database_owner',
    'USAGE'
  )
  as priv,
  pg_has_role(
    'regress_priv_user1',
    'pg_database_owner',
    'MEMBER'
  )
  as mem,
  pg_has_role(
    'regress_priv_user1',
    'pg_database_owner',
    'MEMBER WITH ADMIN OPTION'
  )
  as admin;

begin;

do
$do$
BEGIN EXECUTE format(
	'ALTER DATABASE %I OWNER TO regress_priv_group2', current_catalog); END
$do$;

select
  pg_has_role(
    'regress_priv_user1',
    'pg_database_owner',
    'USAGE'
  )
  as priv,
  pg_has_role(
    'regress_priv_user1',
    'pg_database_owner',
    'MEMBER'
  )
  as mem,
  pg_has_role(
    'regress_priv_user1',
    'pg_database_owner',
    'MEMBER WITH ADMIN OPTION'
  )
  as admin;

set session authorization regress_priv_user1;

select * from information_schema.enabled_roles order by role_name collate "C";

select
  *
from
  information_schema.applicable_roles
order by role_name collate "C";

insert into datdba_only default values;

savepoint q;

delete from datdba_only;

rollback to savepoint q;

set session authorization regress_priv_user2;

select * from information_schema.enabled_roles;

insert into datdba_only default values;

rollback;

create schema "testns";

grant all on schema testns to regress_priv_user1;

create table testns.acltest1 (x int);

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');

alter default privileges
in schema testns,
testns
grant SELECT
on tables
to public,
public;

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');

drop table testns.acltest1;

create table testns.acltest1 (x int);

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');

alter default privileges
in schema testns
grant INSERT
on tables
to regress_priv_user1;

drop table testns.acltest1;

create table testns.acltest1 (x int);

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');

alter default privileges
in schema testns
revoke INSERT
on tables
from regress_priv_user1;

drop table testns.acltest1;

create table testns.acltest1 (x int);

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');

select has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');

alter default privileges
for role regress_priv_user1
revoke EXECUTE on functions from public;

alter default privileges
in schema testns
grant USAGE
on schemas
to regress_priv_user2;

select
  makeaclitem(
    cast('regress_priv_user1' as regrole),
    cast('regress_priv_user2' as regrole),
    'SELECT',
    true
  );

select
  makeaclitem(
    cast('regress_priv_user1' as regrole),
    cast('regress_priv_user2' as regrole),
    'SELECT, INSERT,  UPDATE , DELETE  ',
    false
  );

select
  makeaclitem(
    cast('regress_priv_user1' as regrole),
    cast('regress_priv_user2' as regrole),
    'SELECT, fake_privilege',
    false
  );

create role "regress_""quoted";

select
  makeaclitem(
    cast('regress_"quoted' as regrole),
    cast('regress_"quoted' as regrole),
    'SELECT',
    true
  );

select cast('"regress_""quoted"=r*/"regress_""quoted"' as aclitem);

select cast('""=r*/""' as aclitem);

drop role "regress_""quoted";

select pg_input_is_valid('regress_priv_user1=r/regress_priv_user2', 'aclitem');

select pg_input_is_valid('regress_priv_user1=r/', 'aclitem');

select * from pg_input_error_info('regress_priv_user1=r/', 'aclitem');

select
  pg_input_is_valid(
    'regress_priv_user1=r/regress_no_such_user',
    'aclitem'
  );

select
  *
from
  pg_input_error_info(
    'regress_priv_user1=r/regress_no_such_user',
    'aclitem'
  );

select pg_input_is_valid('regress_priv_user1=rY', 'aclitem');

select * from pg_input_error_info('regress_priv_user1=rY', 'aclitem');

begin;

alter default privileges grant USAGE on schemas to regress_priv_user2;

create schema "testns2";

select has_schema_privilege('regress_priv_user2', 'testns2', 'USAGE');

select has_schema_privilege('regress_priv_user6', 'testns2', 'USAGE');

select has_schema_privilege('regress_priv_user2', 'testns2', 'CREATE');

alter default privileges revoke USAGE on schemas from regress_priv_user2;

create schema "testns3";

select has_schema_privilege('regress_priv_user2', 'testns3', 'USAGE');

select has_schema_privilege('regress_priv_user2', 'testns3', 'CREATE');

alter default privileges grant all on schemas to regress_priv_user2;

create schema "testns4";

select has_schema_privilege('regress_priv_user2', 'testns4', 'USAGE');

select has_schema_privilege('regress_priv_user2', 'testns4', 'CREATE');

alter default privileges revoke all on schemas from regress_priv_user2;

commit;

begin;

select lo_create(1007);

select has_largeobject_privilege('regress_priv_user2', 1007, 'SELECT');

select has_largeobject_privilege('regress_priv_user2', 1007, 'UPDATE');

select lo_create(1008);

select has_largeobject_privilege('regress_priv_user2', 1008, 'SELECT');

select has_largeobject_privilege('regress_priv_user6', 1008, 'SELECT');

select has_largeobject_privilege('regress_priv_user2', 1008, 'UPDATE');

select lo_create(1009);

select has_largeobject_privilege('regress_priv_user2', 1009, 'SELECT');

select has_largeobject_privilege('regress_priv_user2', 1009, 'UPDATE');

select lo_create(1010);

select has_largeobject_privilege('regress_priv_user2', 1010, 'SELECT');

select has_largeobject_privilege('regress_priv_user2', 1010, 'UPDATE');

rollback;

begin;

alter default privileges grant all on functions to regress_priv_user2;

alter default privileges grant all on schemas to regress_priv_user2;

alter default privileges grant all on sequences to regress_priv_user2;

alter default privileges grant all on tables to regress_priv_user2;

alter default privileges grant all on types to regress_priv_user2;

select
  COUNT(*)
from
  pg_shdepend
where
  deptype = 'a' and
  refobjid =
  cast('regress_priv_user2' as regrole) and
  classid =
  cast('pg_default_acl' as regclass);

drop owned by regress_priv_user2, regress_priv_user2;

select
  COUNT(*)
from
  pg_shdepend
where
  deptype = 'a' and
  refobjid =
  cast('regress_priv_user2' as regrole) and
  classid =
  cast('pg_default_acl' as regclass);

rollback;

create schema "testns5";

select has_schema_privilege('regress_priv_user2', 'testns5', 'USAGE');

select has_schema_privilege('regress_priv_user2', 'testns5', 'CREATE');

set role to regress_priv_user1;

create function testns.foo()
returns int
language sql
as $function$
select 1
$function$;

create aggregate testns.agg1 (int) (sfunc = int4pl, stype = int);

create procedure testns.bar()
language sql
as $procedure$
select 1
$procedure$;

select has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE');

select
  has_function_privilege(
    'regress_priv_user2',
    'testns.agg1(int)',
    'EXECUTE'
  );

select has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE');

alter default privileges in schema testns grant EXECUTE on functions to public;

drop function testns.foo();

create function testns.foo()
returns int
language sql
as $function$
select 1
$function$;

drop aggregate testns.agg1(int);

create aggregate testns.agg1 (int) (sfunc = int4pl, stype = int);

drop procedure testns.bar();

create procedure testns.bar()
language sql
as $procedure$
select 1
$procedure$;

select has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE');

select
  has_function_privilege(
    'regress_priv_user2',
    'testns.agg1(int)',
    'EXECUTE'
  );

select has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE');

drop function testns.foo();

drop aggregate testns.agg1(int);

drop procedure testns.bar();

alter default privileges
for role regress_priv_user1
revoke USAGE on types from public;

create domain testns.priv_testdomain1 as int;

select
  has_type_privilege(
    'regress_priv_user2',
    'testns.priv_testdomain1',
    'USAGE'
  );

alter default privileges in schema testns grant USAGE on types to public;

drop domain testns.priv_testdomain1;

create domain testns.priv_testdomain1 as int;

select
  has_type_privilege(
    'regress_priv_user2',
    'testns.priv_testdomain1',
    'USAGE'
  );

drop domain testns.priv_testdomain1;

reset role;

select
  COUNT(*)
from
  pg_default_acl as d
  left outer join
    pg_namespace as n
  on defaclnamespace = n.oid
where
  nspname = 'testns';

drop schema testns cascade;

drop schema testns2 cascade;

drop schema testns3 cascade;

drop schema testns4 cascade;

drop schema testns5 cascade;

select
  d.*
from
  pg_default_acl as d
  left outer join
    pg_namespace as n
  on defaclnamespace = n.oid
where
  nspname is null and defaclnamespace <> 0;

create schema "testns";

create table testns.t1 (f1 int);

create table testns.t2 (f1 int);

select has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT');

grant all on all tables in schema testns to regress_priv_user1;

select has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT');

select has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT');

revoke all on all tables in schema testns from regress_priv_user1;

select has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT');

select has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT');

create function testns.priv_testfunc(int)
returns int
language sql
as $function$
select 3 * $1;
$function$;

create aggregate testns.priv_testagg (int) (sfunc = int4pl, stype = int);

create procedure testns.priv_testproc(int)
language sql
as $procedure$
select 3
$procedure$;

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testfunc(int)',
    'EXECUTE'
  );

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testagg(int)',
    'EXECUTE'
  );

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testproc(int)',
    'EXECUTE'
  );

revoke all on all functions in schema testns from public;

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testfunc(int)',
    'EXECUTE'
  );

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testagg(int)',
    'EXECUTE'
  );

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testproc(int)',
    'EXECUTE'
  );

revoke all on all procedures in schema testns from public;

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testproc(int)',
    'EXECUTE'
  );

grant all on all routines in schema testns to public;

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testfunc(int)',
    'EXECUTE'
  );

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testagg(int)',
    'EXECUTE'
  );

select
  has_function_privilege(
    'regress_priv_user1',
    'testns.priv_testproc(int)',
    'EXECUTE'
  );

drop schema testns cascade;

create role regress_schemauser1 superuser login;

create role regress_schemauser2 superuser login;

set role to regress_schemauser1;

create schema "testns";

select
  nspname,
  rolname
from
  pg_namespace,
  pg_roles
where
  pg_namespace.nspname = 'testns' and
  pg_namespace.nspowner = pg_roles.oid;

alter schema testns owner to regress_schemauser2;

alter role regress_schemauser2 rename to regress_schemauser_renamed;

select
  nspname,
  rolname
from
  pg_namespace,
  pg_roles
where
  pg_namespace.nspname = 'testns' and
  pg_namespace.nspowner = pg_roles.oid;

set role to regress_schemauser_renamed;

drop schema testns cascade;

drop role regress_schemauser1;

drop role regress_schemauser_renamed;

set role to regress_priv_user1;

create table dep_priv_test (a int);

grant SELECT on table dep_priv_test to regress_priv_user2 with grant option;

grant SELECT on table dep_priv_test to regress_priv_user3 with grant option;

set role to regress_priv_user2;

grant SELECT on table dep_priv_test to regress_priv_user4 with grant option;

set role to regress_priv_user3;

grant SELECT on table dep_priv_test to regress_priv_user4 with grant option;

set role to regress_priv_user4;

grant SELECT on table dep_priv_test to regress_priv_user5;

set role to regress_priv_user2;

revoke SELECT on table dep_priv_test from regress_priv_user4 cascade;

set role to regress_priv_user3;

revoke SELECT on table dep_priv_test from regress_priv_user4 cascade;

set role to regress_priv_user1;

drop table dep_priv_test;

drop sequence x_seq;

drop aggregate priv_testagg1(int);

drop function priv_testfunc2(int);

drop function priv_testfunc4(boolean);

drop procedure priv_testproc1(int);

drop view atestv0;

drop view atestv1;

drop view atestv2;

drop view atestv3 cascade;

drop view atestv4;

drop table atest1;

drop table atest2;

drop table atest3;

drop table atest4;

drop table atest5;

drop table atest6;

drop table atestc;

drop table atestp1;

drop table atestp2;

select
  lo_unlink(oid)
from
  pg_largeobject_metadata
where
  oid >= 1000 and oid < 3000
order by oid;

drop role regress_priv_group1;

drop role regress_priv_group2;

revoke USAGE on language sql from regress_priv_user1;

drop owned by regress_priv_user1;

drop role regress_priv_user1;

drop role regress_priv_user2;

drop role regress_priv_user3;

drop role regress_priv_user4;

drop role regress_priv_user5;

drop role regress_priv_user6;

drop role regress_priv_user7;

drop role regress_priv_user8;

alter default privileges
for role pg_signal_backend
revoke USAGE
on types
from pg_signal_backend;

alter default privileges
for role pg_read_all_settings
revoke USAGE
on types
from pg_read_all_settings;

create user regress_locktable_user;

create table lock_table (a int);

grant SELECT on table lock_table to regress_locktable_user;

set session authorization regress_locktable_user;

begin;

lock table lock_table in ACCESS SHARE mode;

commit;

begin;

lock table lock_table in ROW EXCLUSIVE mode;

rollback;

begin;

lock table lock_table in ACCESS EXCLUSIVE mode;

rollback;

revoke SELECT on table lock_table from regress_locktable_user;

grant INSERT on table lock_table to regress_locktable_user;

set session authorization regress_locktable_user;

begin;

lock table lock_table in ACCESS SHARE mode;

rollback;

begin;

lock table lock_table in ROW EXCLUSIVE mode;

commit;

begin;

lock table lock_table in ACCESS EXCLUSIVE mode;

rollback;

revoke INSERT on table lock_table from regress_locktable_user;

grant UPDATE on table lock_table to regress_locktable_user;

set session authorization regress_locktable_user;

begin;

lock table lock_table in ACCESS SHARE mode;

rollback;

begin;

lock table lock_table in ROW EXCLUSIVE mode;

commit;

begin;

lock table lock_table in ACCESS EXCLUSIVE mode;

commit;

revoke UPDATE on table lock_table from regress_locktable_user;

grant DELETE on table lock_table to regress_locktable_user;

set session authorization regress_locktable_user;

begin;

lock table lock_table in ACCESS SHARE mode;

rollback;

begin;

lock table lock_table in ROW EXCLUSIVE mode;

commit;

begin;

lock table lock_table in ACCESS EXCLUSIVE mode;

commit;

revoke DELETE on table lock_table from regress_locktable_user;

grant TRUNCATE on table lock_table to regress_locktable_user;

set session authorization regress_locktable_user;

begin;

lock table lock_table in ACCESS SHARE mode;

rollback;

begin;

lock table lock_table in ROW EXCLUSIVE mode;

commit;

begin;

lock table lock_table in ACCESS EXCLUSIVE mode;

commit;

revoke TRUNCATE on table lock_table from regress_locktable_user;

grant MAINTAIN on table lock_table to regress_locktable_user;

set session authorization regress_locktable_user;

begin;

lock table lock_table in ACCESS SHARE mode;

rollback;

begin;

lock table lock_table in ROW EXCLUSIVE mode;

commit;

begin;

lock table lock_table in ACCESS EXCLUSIVE mode;

commit;

revoke MAINTAIN on table lock_table from regress_locktable_user;

drop table lock_table;

drop role regress_locktable_user;

create role regress_readallstats;

select has_table_privilege('regress_readallstats', 'pg_aios', 'SELECT');

select
  has_table_privilege(
    'regress_readallstats',
    'pg_backend_memory_contexts',
    'SELECT'
  );

select
  has_table_privilege(
    'regress_readallstats',
    'pg_shmem_allocations',
    'SELECT'
  );

select
  has_table_privilege(
    'regress_readallstats',
    'pg_shmem_allocations_numa',
    'SELECT'
  );

select
  has_table_privilege(
    'regress_readallstats',
    'pg_dsm_registry_allocations',
    'SELECT'
  );

grant PG_READ_ALL_STATS to regress_readallstats;

select has_table_privilege('regress_readallstats', 'pg_aios', 'SELECT');

select
  has_table_privilege(
    'regress_readallstats',
    'pg_backend_memory_contexts',
    'SELECT'
  );

select
  has_table_privilege(
    'regress_readallstats',
    'pg_shmem_allocations',
    'SELECT'
  );

select
  has_table_privilege(
    'regress_readallstats',
    'pg_shmem_allocations_numa',
    'SELECT'
  );

select
  has_table_privilege(
    'regress_readallstats',
    'pg_dsm_registry_allocations',
    'SELECT'
  );

set role to regress_readallstats;

select COUNT(*) >= 0 as ok from pg_aios;

select COUNT(*) >= 0 as ok from pg_backend_memory_contexts;

select COUNT(*) >= 0 as ok from pg_shmem_allocations;

reset role;

drop role regress_readallstats;

create role regress_group;

create role regress_group_direct_manager;

create role regress_group_indirect_manager;

create role regress_group_member;

grant REGRESS_GROUP
to regress_group_direct_manager
with INHERIT false,
ADMIN true;

grant REGRESS_GROUP_DIRECT_MANAGER to regress_group_indirect_manager;

set session authorization regress_group_direct_manager;

grant REGRESS_GROUP to regress_group_member;

select
  cast(cast(member as regrole) as text),
  case
    when grantor = 10
    then 'BOOTSTRAP SUPERUSER'
    else cast(cast(grantor as regrole) as text)
  end
from
  pg_auth_members
where
  roleid =
  cast('regress_group' as regrole)
order by 1,
  2;

revoke REGRESS_GROUP from regress_group_member restrict;

set session authorization regress_group_indirect_manager;

grant REGRESS_GROUP to regress_group_member;

select
  cast(cast(member as regrole) as text),
  case
    when grantor = 10
    then 'BOOTSTRAP SUPERUSER'
    else cast(cast(grantor as regrole) as text)
  end
from
  pg_auth_members
where
  roleid =
  cast('regress_group' as regrole)
order by 1,
  2;

revoke REGRESS_GROUP from regress_group_member restrict;

reset session_authorization;

drop role regress_group;

drop role regress_group_direct_manager;

drop role regress_group_indirect_manager;

drop role regress_group_member;

create role regress_roleoption_protagonist;

create role regress_roleoption_donor;

create role regress_roleoption_recipient;

create schema "regress_roleoption";

grant CREATE, USAGE on schema regress_roleoption to public;

grant REGRESS_ROLEOPTION_DONOR
to regress_roleoption_protagonist
with INHERIT true,
SET false;

grant REGRESS_ROLEOPTION_RECIPIENT
to regress_roleoption_protagonist
with INHERIT false,
SET true;

set session authorization regress_roleoption_protagonist;

create table regress_roleoption.t1 (a int);

create table regress_roleoption.t2 (a int);

set session authorization regress_roleoption_donor;

create table regress_roleoption.t3 (a int);

set session authorization regress_roleoption_recipient;

create table regress_roleoption.t4 (a int);

set session authorization regress_roleoption_protagonist;

alter table regress_roleoption.t1
  owner to regress_roleoption_donor;

alter table regress_roleoption.t2
  owner to regress_roleoption_recipient;

alter table regress_roleoption.t3
  owner to regress_roleoption_protagonist;

alter table regress_roleoption.t4
  owner to regress_roleoption_protagonist;

reset session_authorization;

drop table regress_roleoption.t1;

drop table regress_roleoption.t2;

drop table regress_roleoption.t3;

drop table regress_roleoption.t4;

drop schema regress_roleoption;

drop role regress_roleoption_protagonist;

drop role regress_roleoption_donor;

drop role regress_roleoption_recipient;

create role regress_no_maintain;

create role regress_maintain;

create role regress_maintain_all in role pg_maintain;

create table maintain_test (a int);

create index on maintain_test using btree (a);

grant MAINTAIN on table maintain_test to regress_maintain;

create materialized view refresh_test as select 1;

grant MAINTAIN on table refresh_test to regress_maintain;

create schema "reindex_test";

set role to regress_no_maintain;

vacuum maintain_test;

analyze maintain_test;

vacuum (ANALYZE) maintain_test;

cluster maintain_test using maintain_test_a_idx;

refresh materialized view refresh_test;

reindex table maintain_test;

reindex index maintain_test_a_idx;

reindex schema reindex_test;

reset role;

set role to regress_maintain;

vacuum maintain_test;

analyze maintain_test;

vacuum (ANALYZE) maintain_test;

cluster maintain_test using maintain_test_a_idx;

refresh materialized view refresh_test;

reindex table maintain_test;

reindex index maintain_test_a_idx;

reindex schema reindex_test;

reset role;

set role to regress_maintain_all;

vacuum maintain_test;

analyze maintain_test;

vacuum (ANALYZE) maintain_test;

cluster maintain_test using maintain_test_a_idx;

refresh materialized view refresh_test;

reindex table maintain_test;

reindex index maintain_test_a_idx;

reindex schema reindex_test;

reset role;

drop table maintain_test;

drop materialized view refresh_test;

drop schema reindex_test;

drop role regress_no_maintain;

drop role regress_maintain;

drop role regress_maintain_all;

create role regress_grantor1;

create role regress_grantor2 role regress_grantor1;

create role regress_grantor3;

create table grantor_test1 ();

create table grantor_test2 ();

create table grantor_test3 ();

grant SELECT on table grantor_test2 to regress_grantor1 with grant option;

grant SELECT,
UPDATE
on table grantor_test3
to regress_grantor2
with grant option;

set role to regress_grantor1;

grant SELECT, UPDATE on table grantor_test1 to regress_grantor3;

grant SELECT, UPDATE on table grantor_test2 to regress_grantor3;

grant SELECT, UPDATE on table grantor_test3 to regress_grantor3;

reset role;

select
  *
from
  information_schema.table_privileges as t
where
  grantor like 'regress_grantor%'
order by row(t.*);

drop table grantor_test1, grantor_test2, grantor_test3;

drop role regress_grantor1, regress_grantor2, regress_grantor3;
