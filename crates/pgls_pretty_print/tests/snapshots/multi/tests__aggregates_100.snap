---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/aggregates.sql
snapshot_kind: text
---
set extra_float_digits = 0;

create table aggtest (
  a SMALLINT,
  b REAL
);

copy aggtest from 'filename';

analyze aggtest;

select AVG(four) as avg_1 from onek;

select AVG(a) as avg_32 from aggtest where a < 100;

select any_value(v) from (values (1), (2), (3)) as v (v);

select any_value(v) from (values (null)) as v (v);

select any_value(v) from (values (null), (1), (2)) as v (v);

select any_value(v) from (values (array['hello', 'world'])) as v (v);

select cast(AVG(b) as NUMERIC(10, 3)) as avg_107_943 from aggtest;

select AVG(gpa) as avg_3_4 from only student;

select SUM(four) as sum_1500 from onek;

select SUM(a) as sum_198 from aggtest;

select SUM(b) as avg_431_773 from aggtest;

select SUM(gpa) as avg_6_8 from only student;

select MAX(four) as max_3 from onek;

select MAX(a) as max_100 from aggtest;

select MAX(aggtest.b) as max_324_78 from aggtest;

select MAX(student.gpa) as max_3_7 from student;

select stddev_pop(b) from aggtest;

select stddev_samp(b) from aggtest;

select var_pop(b) from aggtest;

select var_samp(b) from aggtest;

select stddev_pop(cast(b as NUMERIC)) from aggtest;

select stddev_samp(cast(b as NUMERIC)) from aggtest;

select var_pop(cast(b as NUMERIC)) from aggtest;

select var_samp(cast(b as NUMERIC)) from aggtest;

select var_pop(cast(1.0 as DOUBLE PRECISION)), var_samp(cast(2.0 as DOUBLE PRECISION));

select stddev_pop(cast(3.0 as DOUBLE PRECISION)), stddev_samp(cast(4.0 as DOUBLE PRECISION));

select var_pop(cast('inf' as DOUBLE PRECISION)), var_samp(cast('inf' as DOUBLE PRECISION));

select stddev_pop(cast('inf' as DOUBLE PRECISION)), stddev_samp(cast('inf' as DOUBLE PRECISION));

select var_pop(cast('nan' as DOUBLE PRECISION)), var_samp(cast('nan' as DOUBLE PRECISION));

select stddev_pop(cast('nan' as DOUBLE PRECISION)), stddev_samp(cast('nan' as DOUBLE PRECISION));

select var_pop(cast(1.0 as REAL)), var_samp(cast(2.0 as REAL));

select stddev_pop(cast(3.0 as REAL)), stddev_samp(cast(4.0 as REAL));

select var_pop(cast('inf' as REAL)), var_samp(cast('inf' as REAL));

select stddev_pop(cast('inf' as REAL)), stddev_samp(cast('inf' as REAL));

select var_pop(cast('nan' as REAL)), var_samp(cast('nan' as REAL));

select stddev_pop(cast('nan' as REAL)), stddev_samp(cast('nan' as REAL));

select var_pop(cast(1.0 as NUMERIC)), var_samp(cast(2.0 as NUMERIC));

select stddev_pop(cast(3.0 as NUMERIC)), stddev_samp(cast(4.0 as NUMERIC));

select var_pop(cast('inf' as NUMERIC)), var_samp(cast('inf' as NUMERIC));

select stddev_pop(cast('inf' as NUMERIC)), stddev_samp(cast('inf' as NUMERIC));

select var_pop(cast('nan' as NUMERIC)), var_samp(cast('nan' as NUMERIC));

select stddev_pop(cast('nan' as NUMERIC)), stddev_samp(cast('nan' as NUMERIC));

select MAX(row(a, b)) from aggtest;

select MAX(row(b, a)) from aggtest;

select MIN(row(a, b)) from aggtest;

select MIN(row(b, a)) from aggtest;

select SUM(cast(null as INT)) from generate_series(1, 3);

select SUM(cast(null as BIGINT)) from generate_series(1, 3);

select SUM(cast(null as NUMERIC)) from generate_series(1, 3);

select SUM(cast(null as DOUBLE PRECISION)) from generate_series(1, 3);

select AVG(cast(null as INT)) from generate_series(1, 3);

select AVG(cast(null as BIGINT)) from generate_series(1, 3);

select AVG(cast(null as NUMERIC)) from generate_series(1, 3);

select AVG(cast(null as DOUBLE PRECISION)) from generate_series(1, 3);

select SUM(cast('NaN' as NUMERIC)) from generate_series(1, 3);

select AVG(cast('NaN' as NUMERIC)) from generate_series(1, 3);

select
  SUM(cast(x as DOUBLE PRECISION)),
  AVG(cast(x as DOUBLE PRECISION)),
  var_pop(cast(x as DOUBLE PRECISION))
from
  (values ('1'), ('infinity')) as v (x);

select
  SUM(cast(x as DOUBLE PRECISION)),
  AVG(cast(x as DOUBLE PRECISION)),
  var_pop(cast(x as DOUBLE PRECISION))
from
  (values ('infinity'), ('1')) as v (x);

select
  SUM(cast(x as DOUBLE PRECISION)),
  AVG(cast(x as DOUBLE PRECISION)),
  var_pop(cast(x as DOUBLE PRECISION))
from
  (values ('infinity'), ('infinity')) as v (x);

select
  SUM(cast(x as DOUBLE PRECISION)),
  AVG(cast(x as DOUBLE PRECISION)),
  var_pop(cast(x as DOUBLE PRECISION))
from
  (values ('-infinity'), ('infinity')) as v (x);

select
  SUM(cast(x as DOUBLE PRECISION)),
  AVG(cast(x as DOUBLE PRECISION)),
  var_pop(cast(x as DOUBLE PRECISION))
from
  (values ('-infinity'), ('-infinity')) as v (x);

select
  SUM(cast(x as NUMERIC)),
  AVG(cast(x as NUMERIC)),
  var_pop(cast(x as NUMERIC))
from
  (values ('1'), ('infinity')) as v (x);

select
  SUM(cast(x as NUMERIC)),
  AVG(cast(x as NUMERIC)),
  var_pop(cast(x as NUMERIC))
from
  (values ('infinity'), ('1')) as v (x);

select
  SUM(cast(x as NUMERIC)),
  AVG(cast(x as NUMERIC)),
  var_pop(cast(x as NUMERIC))
from
  (values ('infinity'), ('infinity')) as v (x);

select
  SUM(cast(x as NUMERIC)),
  AVG(cast(x as NUMERIC)),
  var_pop(cast(x as NUMERIC))
from
  (values ('-infinity'), ('infinity')) as v (x);

select
  SUM(cast(x as NUMERIC)),
  AVG(cast(x as NUMERIC)),
  var_pop(cast(x as NUMERIC))
from
  (values ('-infinity'), ('-infinity')) as v (x);

select
  AVG(cast(x as DOUBLE PRECISION)),
  var_pop(cast(x as DOUBLE PRECISION))
from
  (
    values
      (100000003),
      (100000004),
      (100000006),
      (100000007)
  )
  as v (x);

select
  AVG(cast(x as DOUBLE PRECISION)),
  var_pop(cast(x as DOUBLE PRECISION))
from
  (values (7000000000005), (7000000000007)) as v (x);

select regr_count(b, a) from aggtest;

select regr_sxx(b, a) from aggtest;

select regr_syy(b, a) from aggtest;

select regr_sxy(b, a) from aggtest;

select regr_avgx(b, a), regr_avgy(b, a) from aggtest;

select regr_r2(b, a) from aggtest;

select regr_slope(b, a), regr_intercept(b, a) from aggtest;

select covar_pop(b, a), covar_samp(b, a) from aggtest;

select corr(b, a) from aggtest;

select
  covar_pop(
    cast(1 as DOUBLE PRECISION),
    cast(2 as DOUBLE PRECISION)
  ),
  covar_samp(
    cast(3 as DOUBLE PRECISION),
    cast(4 as DOUBLE PRECISION)
  );

select
  covar_pop(
    cast(1 as DOUBLE PRECISION),
    cast('inf' as DOUBLE PRECISION)
  ),
  covar_samp(
    cast(3 as DOUBLE PRECISION),
    cast('inf' as DOUBLE PRECISION)
  );

select
  covar_pop(
    cast(1 as DOUBLE PRECISION),
    cast('nan' as DOUBLE PRECISION)
  ),
  covar_samp(
    cast(3 as DOUBLE PRECISION),
    cast('nan' as DOUBLE PRECISION)
  );

create table regr_test (
  x DOUBLE PRECISION,
  y DOUBLE PRECISION
);

insert into regr_test values (10, 150), (20, 250), (30, 350), (80, 540), (100, 200);

select
  COUNT(*),
  SUM(x),
  regr_sxx(y, x),
  SUM(y),
  regr_syy(y, x),
  regr_sxy(y, x)
from
  regr_test
where
  x in (10, 20, 30, 80);

select COUNT(*), SUM(x), regr_sxx(y, x), SUM(y), regr_syy(y, x), regr_sxy(y, x) from regr_test;

select float8_accum(cast('{4,140,2900}' as DOUBLE PRECISION[]), 100);

select float8_regr_accum(cast('{4,140,2900,1290,83075,15050}' as DOUBLE PRECISION[]), 200, 100);

select
  COUNT(*),
  SUM(x),
  regr_sxx(y, x),
  SUM(y),
  regr_syy(y, x),
  regr_sxy(y, x)
from
  regr_test
where
  x in (10, 20, 30);

select
  COUNT(*),
  SUM(x),
  regr_sxx(y, x),
  SUM(y),
  regr_syy(y, x),
  regr_sxy(y, x)
from
  regr_test
where
  x in (80, 100);

select
  float8_combine(
    cast('{3,60,200}' as DOUBLE PRECISION[]),
    cast('{0,0,0}' as DOUBLE PRECISION[])
  );

select
  float8_combine(
    cast('{0,0,0}' as DOUBLE PRECISION[]),
    cast('{2,180,200}' as DOUBLE PRECISION[])
  );

select
  float8_combine(
    cast('{3,60,200}' as DOUBLE PRECISION[]),
    cast('{2,180,200}' as DOUBLE PRECISION[])
  );

select
  float8_regr_combine(
    cast('{3,60,200,750,20000,2000}'
    as DOUBLE PRECISION[]),
    cast('{0,0,0,0,0,0}' as DOUBLE PRECISION[])
  );

select
  float8_regr_combine(
    cast('{0,0,0,0,0,0}' as DOUBLE PRECISION[]),
    cast('{2,180,200,740,57800,-3400}'
    as DOUBLE PRECISION[])
  );

select
  float8_regr_combine(
    cast('{3,60,200,750,20000,2000}'
    as DOUBLE PRECISION[]),
    cast('{2,180,200,740,57800,-3400}'
    as DOUBLE PRECISION[])
  );

drop TABLE regr_test;

select COUNT(four) as cnt_1000 from onek;

select COUNT(distinct four) as cnt_4 from onek;

select ten, COUNT(*), SUM(four) from onek group by ten order by ten;

select ten, COUNT(four), SUM(distinct four) from onek group by ten order by ten;

select newavg(four) as avg_1 from onek;

select newsum(four) as sum_1500 from onek;

select newcnt(four) as cnt_1000 from onek;

select newcnt(*) as cnt_1000 from onek;

select oldcnt(*) as cnt_1000 from onek;

select sum2(q1, q2) from int8_tbl;

select SUM(q1 + q2), SUM(q1) + SUM(q2) from int8_tbl;

select SUM(q1 - q2), SUM(q2 - q1), SUM(q1) - SUM(q2) from int8_tbl;

select SUM(q1 * 2000), SUM(-q1 * 2000), 2000 * SUM(q1) from int8_tbl;

select
  ten,
  SUM(distinct four)
from
  onek as a
group by ten
having
  exists
  (
    select
      1
    from
      onek as b
    where
      SUM(distinct a.four) = b.four
  );

select
  ten,
  SUM(distinct four)
from
  onek as a
group by ten
having
  exists
  (
    select
      1
    from
      onek as b
    where
      SUM(distinct a.four + b.four) = b.four
  );

select (select MAX((select i.unique2 from tenk1 as i where i.unique1 = o.unique1))) from tenk1 as o;

select
  s1,
  s2,
  sm
from
  generate_series(1, 3) as s1,
  lateral (
    select
      s2,
      SUM(s1 + s2) as sm
    from
      generate_series(1, 3) as s2
    group by s2
  )
  as ss
order by 1,
  2;

select
  s1,
  s2,
  sm
from
  generate_series(1, 3) as s1,
  lateral (
    select
      s2,
      SUM(s1 + s2) as sm
    from
      generate_series(1, 3) as s2
    group by s2
  )
  as ss
order by 1,
  2;

select
  array(
    select
      SUM(x + y) as s
    from
      generate_series(1, 3) as y
    group by y
    order by s
  )
from
  generate_series(1, 3) as x;

select
  array(
    select
      SUM(x + y) as s
    from
      generate_series(1, 3) as y
    group by y
    order by s
  )
from
  generate_series(1, 3) as x;

create temporary table bitwise_test (
  i2 SMALLINT,
  i4 INT,
  i8 BIGINT,
  i INT,
  x SMALLINT,
  y BIT(4)
);

select bit_and(i2) as "?", bit_or(i4) as "?", bit_xor(i8) as "?" from bitwise_test;

select
  bit_and(i2) as "1",
  bit_and(i4) as "1",
  bit_and(i8) as "1",
  bit_and(i) as "?",
  bit_and(x) as "0",
  bit_and(y) as "0100",
  bit_or(i2) as "7",
  bit_or(i4) as "7",
  bit_or(i8) as "7",
  bit_or(i) as "?",
  bit_or(x) as "7",
  bit_or(y) as "1101",
  bit_xor(i2) as "5",
  bit_xor(i4) as "5",
  bit_xor(i8) as "5",
  bit_xor(i) as "?",
  bit_xor(x) as "7",
  bit_xor(y) as "1101"
from
  bitwise_test;

select
  booland_statefunc(null, null) is null as t,
  booland_statefunc(true, null) is null as t,
  booland_statefunc(false, null) is null as t,
  booland_statefunc(null, true) is null as t,
  booland_statefunc(null, false) is null as t,
  booland_statefunc(true, true) as t,
  not booland_statefunc(true, false) as t,
  not booland_statefunc(false, true) as t,
  not booland_statefunc(false, false) as t;

select
  boolor_statefunc(null, null) is null as t,
  boolor_statefunc(true, null) is null as t,
  boolor_statefunc(false, null) is null as t,
  boolor_statefunc(null, true) is null as t,
  boolor_statefunc(null, false) is null as t,
  boolor_statefunc(true, true) as t,
  boolor_statefunc(true, false) as t,
  boolor_statefunc(false, true) as t,
  not boolor_statefunc(false, false) as t;

create temporary table bool_test (
  b1 BOOLEAN,
  b2 BOOLEAN,
  b3 BOOLEAN,
  b4 BOOLEAN
);

select bool_and(b1) as n, bool_or(b3) as n from bool_test;

select
  bool_and(b1) as f,
  bool_and(b2) as t,
  bool_and(b3) as f,
  bool_and(b4) as n,
  bool_and(not b2) as f,
  bool_and(not b3) as t
from
  bool_test;

select
  every(b1) as f,
  every(b2) as t,
  every(b3) as f,
  every(b4) as n,
  every(not b2) as f,
  every(not b3) as t
from
  bool_test;

select
  bool_or(b1) as t,
  bool_or(b2) as t,
  bool_or(b3) as f,
  bool_or(b4) as n,
  bool_or(not b2) as f,
  bool_or(not b3) as t
from
  bool_test;

select MIN(unique1) from tenk1;

select MIN(unique1) from tenk1;

select MAX(unique1) from tenk1;

select MAX(unique1) from tenk1;

select MAX(unique1) from tenk1 where unique1 < 42;

select MAX(unique1) from tenk1 where unique1 < 42;

select MAX(unique1) from tenk1 where unique1 > 42;

select MAX(unique1) from tenk1 where unique1 > 42;

begin;

set local max_parallel_workers_per_gather = 0;

select MAX(unique1) from tenk1 where unique1 > 42000;

select MAX(unique1) from tenk1 where unique1 > 42000;

rollback;

select MAX(tenthous) from tenk1 where thousand = 33;

select MAX(tenthous) from tenk1 where thousand = 33;

select MIN(tenthous) from tenk1 where thousand = 33;

select MIN(tenthous) from tenk1 where thousand = 33;

select f1, (select MIN(unique1) from tenk1 where unique1 > f1) as gt from int4_tbl;

select f1, (select MIN(unique1) from tenk1 where unique1 > f1) as gt from int4_tbl;

select distinct MAX(unique2) from tenk1;

select distinct MAX(unique2) from tenk1;

select MAX(unique2) from tenk1 order by 1;

select MAX(unique2) from tenk1 order by 1;

select MAX(unique2) from tenk1 order by MAX(unique2);

select MAX(unique2) from tenk1 order by MAX(unique2);

select MAX(unique2) from tenk1 order by MAX(unique2) + 1;

select MAX(unique2) from tenk1 order by MAX(unique2) + 1;

select MAX(unique2), generate_series(1, 3) as g from tenk1 order by g desc;

select MAX(unique2), generate_series(1, 3) as g from tenk1 order by g desc;

select MAX(100) from tenk1;

select MAX(100) from tenk1;

create table minmaxtest (f1 INT);

create table minmaxtest1 ()
inherits (minmaxtest);

create table minmaxtest2 ()
inherits (minmaxtest);

create table minmaxtest3 ()
inherits (minmaxtest);

create index "minmaxtesti" on minmaxtest using btree (f1);

create index "minmaxtest1i" on minmaxtest1 using btree (f1);

create index "minmaxtest2i" on minmaxtest2 using btree (f1 desc);

create index "minmaxtest3i"
on minmaxtest3
using btree
(
  f1
)
where
  f1 is not null;

insert into minmaxtest values (11), (12);

insert into minmaxtest1 values (13), (14);

insert into minmaxtest2 values (15), (16);

insert into minmaxtest3 values (17), (18);

select MIN(f1), MAX(f1) from minmaxtest;

select MIN(f1), MAX(f1) from minmaxtest;

select distinct MIN(f1), MAX(f1) from minmaxtest;

select distinct MIN(f1), MAX(f1) from minmaxtest;

drop TABLE minmaxtest cascade;

begin;

set local enable_sort = off;

select f1, (select distinct MIN(t1.f1) from int4_tbl as t1 where t1.f1 = t0.f1) from int4_tbl as t0;

select f1, (select distinct MIN(t1.f1) from int4_tbl as t1 where t1.f1 = t0.f1) from int4_tbl as t0;

rollback;

select MAX(MIN(unique1)) from tenk1;

select (select MAX(MIN(unique1)) from int8_tbl) from tenk1;

select
  AVG(
    (
      select
        AVG(
          a1.col1 order by (select AVG(a2.col2) from tenk1 as a3)
        )
      from
        tenk1 as a1 (col1)
    )
  )
from
  tenk1 as a2 (col2);

create temporary table t1 (
  a INT,
  b INT,
  c INT,
  d INT,
  primary key (a, b)
);

create temporary table t2 (
  x INT,
  y INT,
  z INT,
  primary key (x, y)
);

create temporary table t3 (
  a INT,
  b INT,
  c INT,
  primary key (a, b) deferrable
);

select * from t1 group by a, b, c, d;

select a, c from t1 group by a, c, d;

select
  *
from
  t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
group by t1.a,
  t1.b,
  t1.c,
  t1.d,
  t2.x,
  t2.y,
  t2.z;

select
  t1.*,
  t2.x,
  t2.z
from
  t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
group by t1.a,
  t1.b,
  t1.c,
  t1.d,
  t2.x,
  t2.z;

select * from t3 group by a, b, c;

create temporary table t1c ()
inherits (t1);

select * from t1 group by a, b, c, d;

select * from only t1 group by a, b, c, d;

create temporary table p_t1 (
  a INT,
  b INT,
  c INT,
  d INT,
  primary key (a, b)
)
partition by LIST(a);

create temporary table p_t1_1 partition of p_t1 for values in (1);

create temporary table p_t1_2 partition of p_t1 for values in (2);

select * from p_t1 group by a, b, c, d;

create unique index "t2_z_uidx" on t2 using btree (z);

select y, z from t2 group by y, z;

alter table t2
  alter column z set not null;

select y, z from t2 group by y, z;

select x, y, z from t2 group by x, y, z;

select x, y, z from t2 group by z, x, y;

drop INDEX t2_z_uidx;

create index "t2_z_uidx"
on t2
using btree
(
  z
)
where
  z > 0;

select y, z from t2 group by y, z;

drop INDEX t2_z_uidx;

alter table t2
  alter column z drop not null;

create unique index "t2_z_uidx" on t2 using btree (z) nulls not distinct;

select y, z from t2 group by y, z;

drop TABLE t1 cascade;

drop TABLE t2;

drop TABLE t3;

drop TABLE p_t1;

create temporary table t1 (
  f1 INT,
  f2 INT
);

create temporary table t2 (
  f1 BIGINT,
  f2 OID
);

select f1 from t1 left outer join t2 using ("f1") group by f1;

select f1 from t1 left outer join t2 using ("f1") group by t1.f1;

select t1.f1 from t1 left outer join t2 using ("f1") group by t1.f1;

select t1.f1 from t1 left outer join t2 using ("f1") group by f1;

select
  f1,
  COUNT(*)
from
  t1 as x (x0, x1)
  left outer join
    t1 left outer join t2 using ("f1")
  on x0 = 0
group by f1;

select
  f2,
  COUNT(*)
from
  t1 as x (x0, x1)
  left outer join
    t1 left outer join t2 using ("f2")
  on x0 = 0
group by f2;

drop TABLE t1, t2;

select SUM(two order by two), MAX(four order by four), MIN(four order by four) from tenk1;

select
  SUM(two order by two),
  MAX(four order by four),
  MIN(four order by four),
  MAX(two order by two)
from
  tenk1;

select
  MAX(four order by four),
  SUM(two order by two),
  MIN(four order by four),
  MAX(two order by two)
from
  tenk1;

select
  MAX(four order by four),
  SUM(two order by two),
  MIN(four order by four),
  MAX(two order by two),
  SUM(ten order by ten),
  MIN(ten order by ten),
  MAX(ten order by ten)
from
  tenk1;

select
  SUM(unique1 order by ten, two),
  SUM(unique1 order by four),
  SUM(unique1 order by two, four)
from
  tenk1
group by ten;

select
  SUM(unique1 order by two),
  SUM(unique1 order by four),
  SUM(unique1 order by four, two),
  SUM(unique1 order by two, random()),
  SUM(unique1 order by two, random(), random() + 1)
from
  tenk1
group by ten;

select array_agg(distinct val) from (select null as val from generate_series(1, 2));

set enable_presorted_aggregate = off;

select SUM(two order by two) from tenk1;

reset enable_presorted_aggregate;

select SUM(two order by two) filter (where two > 1) from tenk1;

select string_agg(distinct f1, ',') filter (where length(f1) > 1) from varchar_tbl;

select
  string_agg(
    distinct cast(f1 as VARCHAR(2)),
    ','
  )
  filter (where
    length(f1) > 1)
from
  varchar_tbl;

select array_agg(a order by b) from (values (1, 4), (2, 3), (3, 1), (4, 2)) as v (a, b);

select array_agg(a order by a) from (values (1, 4), (2, 3), (3, 1), (4, 2)) as v (a, b);

select array_agg(a order by a desc) from (values (1, 4), (2, 3), (3, 1), (4, 2)) as v (a, b);

select array_agg(b order by a desc) from (values (1, 4), (2, 3), (3, 1), (4, 2)) as v (a, b);

select array_agg(distinct a) from (values (1), (2), (1), (3), (null), (2)) as v (a);

select array_agg(distinct a order by a) from (values (1), (2), (1), (3), (null), (2)) as v (a);

select array_agg(distinct a order by a desc) from (values (1), (2), (1), (3), (null), (2)) as v (a);

select
  array_agg(distinct a order by a desc nulls last)
from
  (values (1), (2), (1), (3), (null), (2)) as v (a);

select
  aggfstr(a, b, c)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c);

select
  aggfns(a, b, c)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c);

select
  aggfstr(distinct a, b, c)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 3) as i;

select
  aggfns(distinct a, b, c)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 3) as i;

select
  aggfstr(distinct a, b, c order by b)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 3) as i;

select
  aggfns(distinct a, b, c order by b)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 3) as i;

select
  aggfns(distinct a, a, c order by c using ~<~, a)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 2) as i;

select
  aggfns(distinct a, a, c order by c using ~<~)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 2) as i;

select
  aggfns(distinct a, a, c order by a)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 2) as i;

select
  aggfns(
    distinct a,
    b,
    c order by a,
      c using ~<~,
      b
  )
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 2) as i;

select
  string_agg(distinct 'a', ','),
  SUM(
    (
      select
        SUM(1)
      from
        (values (1)) as b (id)
      where
        a.id = b.id
    )
  )
from
  unnest(array[1]) as a (id);

create view agg_view1
as select
  aggfns(a, b, c)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c);

select * from agg_view1;

select pg_get_viewdef(cast('agg_view1' as REGCLASS));

create or replace view agg_view1
as select
  aggfns(distinct a, b, c)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 3) as i;

select * from agg_view1;

select pg_get_viewdef(cast('agg_view1' as REGCLASS));

create or replace view agg_view1
as select
  aggfns(distinct a, b, c order by b)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 3) as i;

select * from agg_view1;

select pg_get_viewdef(cast('agg_view1' as REGCLASS));

create or replace view agg_view1
as select
  aggfns(a, b, c order by b + 1)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c);

select * from agg_view1;

select pg_get_viewdef(cast('agg_view1' as REGCLASS));

create or replace view agg_view1
as select
  aggfns(a, a, c order by b)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c);

select * from agg_view1;

select pg_get_viewdef(cast('agg_view1' as REGCLASS));

create or replace view agg_view1
as select
  aggfns(a, b, c order by c using ~<~)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c);

select * from agg_view1;

select pg_get_viewdef(cast('agg_view1' as REGCLASS));

create or replace view agg_view1
as select
  aggfns(
    distinct a,
    b,
    c order by a,
      c using ~<~,
      b
  )
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 2) as i;

select * from agg_view1;

select pg_get_viewdef(cast('agg_view1' as REGCLASS));

drop VIEW agg_view1;

select
  aggfns(distinct a, b, c order by i)
from
  (values (1, 1, 'foo')) as v (a, b, c),
  generate_series(1, 2) as i;

select
  aggfns(distinct a, b, c order by a, b + 1)
from
  (values (1, 1, 'foo')) as v (a, b, c),
  generate_series(1, 2) as i;

select
  aggfns(distinct a, b, c order by a, b, i, c)
from
  (values (1, 1, 'foo')) as v (a, b, c),
  generate_series(1, 2) as i;

select
  aggfns(distinct a, a, c order by a, b)
from
  (values (1, 1, 'foo')) as v (a, b, c),
  generate_series(1, 2) as i;

select string_agg(a, ',') from (values ('aaaa'), ('bbbb'), ('cccc')) as g (a);

select string_agg(a, ',') from (values ('aaaa'), (null), ('bbbb'), ('cccc')) as g (a);

select string_agg(a, 'AB') from (values (null), (null), ('bbbb'), ('cccc')) as g (a);

select string_agg(a, ',') from (values (null), (null)) as g (a);

select string_agg(distinct f1, ',' order by f1) from varchar_tbl;

select string_agg(distinct cast(f1 as TEXT), ',' order by f1) from varchar_tbl;

select string_agg(distinct f1, ',' order by cast(f1 as TEXT)) from varchar_tbl;

select string_agg(distinct cast(f1 as TEXT), ',' order by cast(f1 as TEXT)) from varchar_tbl;

create table bytea_test_table (v BYTEA);

select string_agg(v, '') from bytea_test_table;

insert into bytea_test_table values (decode('ff', 'hex'));

select string_agg(v, '') from bytea_test_table;

insert into bytea_test_table values (decode('aa', 'hex'));

select string_agg(v, '') from bytea_test_table;

select string_agg(v, null) from bytea_test_table;

select string_agg(v, decode('ee', 'hex')) from bytea_test_table;

select MIN(v) from bytea_test_table;

select MAX(v) from bytea_test_table;

insert into bytea_test_table values (decode('ffff', 'hex'));

insert into bytea_test_table values (decode('aaaa', 'hex'));

select MIN(v) from bytea_test_table;

select MAX(v) from bytea_test_table;

drop TABLE bytea_test_table;

create table pagg_test (
  x INT,
  y INT
)
with (autovacuum_enabled = off);

insert into pagg_test
select
  case x % 4 when 1 then null else x end,
  x % 10
from
  generate_series(1, 5000) as x;

set parallel_setup_cost = 0;

set parallel_tuple_cost = 0;

set parallel_leader_participation = 0;

set min_parallel_table_scan_size = 0;

set bytea_output = escape;

set max_parallel_workers_per_gather = 2;

create view v_pagg_test
as select
  y,
  MIN(t) as tmin,
  MAX(t) as tmax,
  COUNT(distinct t) as tndistinct,
  MIN(b) as bmin,
  MAX(b) as bmax,
  COUNT(distinct b) as bndistinct,
  MIN(a) as amin,
  MAX(a) as amax,
  COUNT(distinct a) as andistinct,
  MIN(aa) as aamin,
  MAX(aa) as aamax,
  COUNT(distinct aa) as aandistinct
from
  (
    select
      y,
      cast(unnest(regexp_split_to_array(a1.t, ','))
      as INT)
      as t,
      unnest(
        regexp_split_to_array(cast(a1.b as TEXT), ',')
      )
      as b,
      unnest(a1.a) as a,
      unnest(a1.aa) as aa
    from
      (
        select
          y,
          string_agg(cast(x as TEXT), ',') as t,
          string_agg(cast(cast(x as TEXT) as BYTEA), ',')
          as b,
          array_agg(x) as a,
          array_agg(array[x]) as aa
        from
          pagg_test
        group by y
      )
      as a1
  )
  as a2
group by y;

select * from v_pagg_test order by y;

select * from v_pagg_test order by y;

set max_parallel_workers_per_gather = 0;

select * from v_pagg_test order by y;

set max_parallel_workers_per_gather = 2;

select array_dims(array_agg(s)) from (select * from pagg_test) as s;

select array_dims(array_agg(s)) from (select * from pagg_test) as s;

reset max_parallel_workers_per_gather;

reset bytea_output;

reset min_parallel_table_scan_size;

reset parallel_leader_participation;

reset parallel_tuple_cost;

reset parallel_setup_cost;

drop VIEW v_pagg_test;

drop TABLE pagg_test;

select MIN(unique1) filter (where unique1 > 100) from tenk1;

select SUM(1 / ten) filter (where ten > 0) from tenk1;

select
  ten,
  SUM(
    distinct four
  )
  filter (where
    cast(four as TEXT) ~ '123')
from
  onek as a
group by ten;

select
  ten,
  SUM(distinct four) filter (where four > 10)
from
  onek as a
group by ten
having
  exists
  (
    select
      1
    from
      onek as b
    where
      SUM(distinct a.four) = b.four
  );

select
  MAX(
    foo collate "C"
  )
  filter (where
    bar collate "POSIX" > '0')
from
  (values ('a', 'b')) as v (foo, bar);

select any_value(v) filter (where v > 2) from (values (1), (2), (3)) as v (v);

select (select COUNT(*) from (values (1)) as t0 (inner_c)) from (values (2), (3)) as t1 (outer_c);

select
  (
    select
      COUNT(*) filter (where outer_c <> 0)
    from
      (values (1)) as t0 (inner_c)
  )
from
  (values (2), (3)) as t1 (outer_c);

select
  (
    select
      COUNT(inner_c) filter (where outer_c <> 0)
    from
      (values (1)) as t0 (inner_c)
  )
from
  (values (2), (3)) as t1 (outer_c);

select
  (
    select
      MAX(
        (
          select
            i.unique2
          from
            tenk1 as i
          where
            i.unique1 = o.unique1
        )
      )
      filter (where
        o.unique1 < 10)
  )
from
  tenk1 as o;

select
  SUM(
    unique1
  )
  filter (where
    unique1 in
    (
      select unique1 from onek where unique1 < 100
    ))
from
  tenk1;

select
  aggfns(
    distinct a,
    b,
    c order by a,
      c using ~<~,
      b
  )
  filter (where
    a > 1)
from
  (
    values
      (1, 3, 'foo'),
      (0, null, null),
      (2, 2, 'bar'),
      (3, 1, 'baz')
  )
  as v (a, b, c),
  generate_series(1, 2) as i;

select MAX(0) filter (where b1) from bool_test;

select (select MAX(0) filter (where b1)) from bool_test;

select MAX(unique1) filter (where SUM(ten) > 0) from tenk1;

select (select MAX(unique1) filter (where SUM(ten) > 0) from int8_tbl) from tenk1;

select MAX(unique1) filter (where bool_or(ten > 0)) from tenk1;

select (select MAX(unique1) filter (where bool_or(ten > 0)) from int8_tbl) from tenk1;

select
  p,
  percentile_cont(
    p
  )
  within group (order by cast(x as DOUBLE PRECISION))
from
  generate_series(1, 5) as x,
  (
    values
      (cast(0 as DOUBLE PRECISION)),
      (0.1),
      (0.25),
      (0.4),
      (0.5),
      (0.6),
      (0.75),
      (0.9),
      (1)
  )
  as v (p)
group by p
order by p;

select
  p,
  SUM()
  within group (order by cast(x as DOUBLE PRECISION))
from
  generate_series(1, 5) as x,
  (
    values
      (cast(0 as DOUBLE PRECISION)),
      (0.1),
      (0.25),
      (0.4),
      (0.5),
      (0.6),
      (0.75),
      (0.9),
      (1)
  )
  as v (p)
group by p
order by p;

select
  p,
  percentile_cont(p, p)
from
  generate_series(1, 5) as x,
  (
    values
      (cast(0 as DOUBLE PRECISION)),
      (0.1),
      (0.25),
      (0.4),
      (0.5),
      (0.6),
      (0.75),
      (0.9),
      (1)
  )
  as v (p)
group by p
order by p;

select percentile_cont(0.5) within group (order by b) from aggtest;

select percentile_cont(0.5) within group (order by b), SUM(b) from aggtest;

select percentile_cont(0.5) within group (order by thousand) from tenk1;

select percentile_disc(0.5) within group (order by thousand) from tenk1;

select RANK(3) within group (order by x) from (values (1), (1), (2), (2), (3), (3), (4)) as v (x);

select
  CUME_DIST(3) within group (order by x)
from
  (
    values (1), (1), (2), (2), (3), (3), (4)
  )
  as v (x);

select
  PERCENT_RANK(3) within group (order by x)
from
  (
    values (1), (1), (2), (2), (3), (3), (4), (5)
  )
  as v (x);

select
  DENSE_RANK(3) within group (order by x)
from
  (
    values (1), (1), (2), (2), (3), (3), (4)
  )
  as v (x);

select
  percentile_disc(
    array[0, 0.1, 0.25, 0.5, 0.75, 0.9, 1]
  )
  within group (order by thousand)
from
  tenk1;

select percentile_cont(array[0, 0.25, 0.5, 0.75, 1]) within group (order by thousand) from tenk1;

select
  percentile_disc(
    array[array[null, 1, 0.5],
    array[0.75, 0.25, null]]
  )
  within group (order by thousand)
from
  tenk1;

select
  percentile_cont(
    array[0,
    1,
    0.25,
    0.75,
    0.5,
    1,
    0.3,
    0.32,
    0.35,
    0.38,
    0.4]
  )
  within group (order by x)
from
  generate_series(1, 6) as x;

select ten, mode() within group (order by string4) from tenk1 group by ten;

select
  percentile_disc(
    array[0.25, 0.5, 0.75]
  )
  within group (order by x)
from
  unnest(
    cast('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'
    as TEXT[])
  )
  as u (x);

select
  pg_collation_for(
    percentile_disc(
      1
    )
    within group (order by x collate "POSIX")
  )
from
  (values ('fred'), ('jim')) as v (x);

select
  test_rank(3) within group (order by x)
from
  (
    values (1), (1), (2), (2), (3), (3), (4)
  )
  as v (x);

select test_percentile_disc(0.5) within group (order by thousand) from tenk1;

select RANK(x) within group (order by x) from generate_series(1, 5) as x;

select
  array(
    select
      percentile_disc(a) within group (order by x)
    from
      (values (0.3), (0.7)) as v (a)
    group by a
  )
from
  generate_series(1, 5) as g (x);

select RANK(SUM(x)) within group (order by x) from generate_series(1, 5) as x;

select RANK(3) within group (order by x) from (values ('fred'), ('jim')) as v (x);

select RANK(3) within group (order by stringu1, stringu2) from tenk1;

select RANK('fred') within group (order by x) from generate_series(1, 5) as x;

select
  RANK(
    cast('adam' as TEXT) collate "C"
  )
  within group (order by x collate "POSIX")
from
  (values ('fred'), ('jim')) as v (x);

select
  RANK(
    cast('adam' as VARCHAR)
  )
  within group (order by x)
from
  (values ('fred'), ('jim')) as v (x);

select RANK('3') within group (order by x) from generate_series(1, 5) as x;

select PERCENT_RANK(0) within group (order by x) from generate_series(1, 0) as x;

create view aggordview1
as select
  ten,
  percentile_disc(
    0.5
  )
  within group (order by thousand)
  as p50,
  percentile_disc(
    0.5
  )
  within group (order by thousand)
  filter (where
    hundred = 1)
  as px,
  RANK(
    5,
    'AZZZZ',
    50
  )
  within group (order by hundred, string4 desc, hundred)
from
  tenk1
group by ten
order by ten;

select pg_get_viewdef('aggordview1');

select * from aggordview1 order by ten;

drop VIEW aggordview1;

select least_agg(q1, q2) from int8_tbl;

select least_agg(variadic array[q1, q2]) from int8_tbl;

select cleast_agg(q1, q2) from int8_tbl;

select cleast_agg(4.5, f1) from int4_tbl;

select cleast_agg(variadic array[4.5, f1]) from int4_tbl;

select pg_typeof(cleast_agg(variadic array[4.5, f1])) from int4_tbl;

begin;

create type avg_state as (total BIGINT, count BIGINT);

create or replace function avg_transfn(state avg_state, n INT)
returns avg_state
as $function$
declare new_state avg_state;
begin
	raise notice 'avg_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state.total := n;
			new_state.count := 1;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state.total := state.total + n;
		state.count := state.count + 1;
		return state;
	end if;

	return null;
end
$function$
language plpgsql;

create function avg_finalfn(state avg_state)
returns INT
as $function$
begin
	if state is null then
		return NULL;
	else
		return state.total / state.count;
	end if;
end
$function$
language plpgsql;

create function sum_finalfn(state avg_state)
returns INT
as $function$
begin
	if state is null then
		return NULL;
	else
		return state.total;
	end if;
end
$function$
language plpgsql;

create aggregate my_avg (INT) (stype = avg_state, sfunc = avg_transfn, finalfunc = avg_finalfn);

create aggregate my_sum (INT) (stype = avg_state, sfunc = avg_transfn, finalfunc = sum_finalfn);

select my_avg(one), my_avg(one) from (values (1), (3)) as t (one);

select my_avg(one), my_sum(one) from (values (1), (3)) as t (one);

select my_avg(distinct one), my_sum(distinct one) from (values (1), (3), (1)) as t (one);

select my_avg(distinct one), my_sum(one) from (values (1), (3)) as t (one);

select my_avg(one) filter (where one > 1), my_sum(one) from (values (1), (3)) as t (one);

select my_avg(one), my_sum(two) from (values (1, 2), (3, 4)) as t (one, two);

select
  percentile_cont(0.5) within group (order by a),
  percentile_disc(0.5) within group (order by a)
from
  (
    values
      (cast(1 as DOUBLE PRECISION)),
      (3),
      (5),
      (7)
  )
  as t (a);

select
  percentile_cont(0.25) within group (order by a),
  percentile_disc(0.5) within group (order by a)
from
  (
    values
      (cast(1 as DOUBLE PRECISION)),
      (3),
      (5),
      (7)
  )
  as t (a);

select
  RANK(4) within group (order by a),
  DENSE_RANK(4) within group (order by a)
from
  (values (1), (3), (5), (7)) as t (a);

create aggregate my_sum_init (
  INT
) (
  stype = avg_state,
  sfunc = avg_transfn,
  finalfunc = sum_finalfn,
  initcond = '(10,0)'
);

create aggregate my_avg_init (
  INT
) (
  stype = avg_state,
  sfunc = avg_transfn,
  finalfunc = avg_finalfn,
  initcond = '(10,0)'
);

create aggregate my_avg_init2 (
  INT
) (
  stype = avg_state,
  sfunc = avg_transfn,
  finalfunc = avg_finalfn,
  initcond = '(4,0)'
);

select my_sum_init(one), my_avg_init(one) from (values (1), (3)) as t (one);

select my_sum_init(one), my_avg_init2(one) from (values (1), (3)) as t (one);

rollback;

begin;

create or replace function sum_transfn(state INT, n INT)
returns INT
as $function$
declare new_state int4;
begin
	raise notice 'sum_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state := n;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state := state + n;
		return state;
	end if;

	return null;
end
$function$
language plpgsql;

create function halfsum_finalfn(state INT)
returns INT
as $function$
begin
	if state is null then
		return NULL;
	else
		return state / 2;
	end if;
end
$function$
language plpgsql;

create aggregate my_sum (INT) (stype = INT, sfunc = sum_transfn);

create aggregate my_half_sum (INT) (stype = INT, sfunc = sum_transfn, finalfunc = halfsum_finalfn);

select my_sum(one), my_half_sum(one) from (values (1), (2), (3), (4)) as t (one);

rollback;

begin;

create function balkifnull(BIGINT, INT)
returns BIGINT
STRICT
language plpgsql
as $function$
BEGIN
    IF $1 IS NULL THEN
       RAISE 'erroneously called with NULL argument';
    END IF;
    RETURN NULL;
END$function$;

create aggregate balk (
  INT
) (
  sfunc = balkifnull(int8, int4),
  stype = BIGINT,
  parallel = safe,
  initcond = '0'
);

select balk(hundred) from tenk1;

rollback;

create table btg
as
  select
    i % 10 as x,
    i % 10 as y,
    'abc' || i % 10 as z,
    i as w
  from
    generate_series(1, 100) as i;

create index "btg_x_y_idx" on btg using btree (x, y);

analyze btg;

set enable_hashagg = off;

set enable_seqscan = off;

select COUNT(*) from btg group by y, x;

select COUNT(*) from btg group by z, y, w, x;

select COUNT(*) from (select * from btg order by x, y, w, z) as q1 group by w, x, z, y;

set enable_hashjoin = off;

set enable_nestloop = off;

select
  COUNT(*)
from
  btg as t1
  inner join
    btg as t2
  on t1.w = t2.w and t1.x = t2.x and t1.z = t2.z
group by t1.w,
  t1.z,
  t1.x;

reset enable_nestloop;

reset enable_hashjoin;

select COUNT(*) from btg group by w, x, z, y order by y, x, z, w;

select COUNT(*) from btg group by w, x, y, z order by x * x, z;

create index "btg_y_x_w_idx" on btg using btree (y, x, w);

select y, x, array_agg(distinct w) from btg where y < 0 group by x, y;

create table group_agg_pk
as
  select
    i % 10 as x,
    i % 2 as y,
    i % 2 as z,
    2 as w,
    i % 10 as f
  from
    generate_series(1, 100) as i;

analyze group_agg_pk;

set enable_nestloop = off;

set enable_hashjoin = off;

select
  AVG(c1.f order by c1.x, c1.y)
from
  group_agg_pk as c1
  inner join
    group_agg_pk as c2
  on c1.x = c2.x
group by c1.w,
  c1.z;

select
  AVG(c1.f order by c1.x, c1.y)
from
  group_agg_pk as c1
  inner join
    group_agg_pk as c2
  on c1.x = c2.x
group by c1.w,
  c1.z;

select
  c1.y,
  c1.x
from
  group_agg_pk as c1
  inner join
    group_agg_pk as c2
  on c1.x = c2.x
group by c1.y,
  c1.x,
  c2.x;

select
  c1.y,
  c1.x
from
  group_agg_pk as c1
  inner join
    group_agg_pk as c2
  on c1.x = c2.x
group by c1.y,
  c2.x,
  c1.x;

reset enable_nestloop;

reset enable_hashjoin;

drop TABLE group_agg_pk;

create table agg_sort_order (
  c1 INT primary key,
  c2 INT
);

create unique index "agg_sort_order_c2_idx" on agg_sort_order using btree (c2);

insert into agg_sort_order select i, i from generate_series(1, 100) as i;

analyze agg_sort_order;

select array_agg(c1 order by c2), c2 from agg_sort_order where c2 < 100 group by c1 order by 2;

drop TABLE agg_sort_order cascade;

drop TABLE btg;

reset enable_hashagg;

reset enable_seqscan;

begin;

create function balkifnull(BIGINT, BIGINT)
returns BIGINT
parallel SAFE
STRICT
language plpgsql
as $function$
BEGIN
    IF $1 IS NULL THEN
       RAISE 'erroneously called with NULL argument';
    END IF;
    RETURN NULL;
END$function$;

create aggregate balk (
  INT
) (
  sfunc = int4_sum(int8, int4),
  stype = BIGINT,
  combinefunc = balkifnull(int8, int8),
  parallel = safe,
  initcond = '0'
);

alter table tenk1
  set (parallel_workers = 4);

set local parallel_setup_cost = 0;

set local max_parallel_workers_per_gather = 4;

select balk(hundred) from tenk1;

select balk(hundred) from tenk1;

rollback;

begin;

create function rwagg_sfunc(x ANYARRAY, y ANYARRAY)
returns ANYARRAY
language plpgsql
immutable
as $function$
BEGIN
    RETURN array_fill(y[1], ARRAY[4]);
END;
$function$;

create function rwagg_finalfunc(x ANYARRAY)
returns ANYARRAY
language plpgsql
STRICT
immutable
as $function$
DECLARE
    res x%TYPE;
BEGIN
    -- assignment is essential for this test, it expands the array to R/W
    res := array_fill(x[1], ARRAY[4]);
    RETURN res;
END;
$function$;

create aggregate rwagg (
  ANYARRAY
) (
  stype = ANYARRAY,
  sfunc = rwagg_sfunc,
  finalfunc = rwagg_finalfunc
);

create function eatarray(x REAL[])
returns REAL[]
language plpgsql
STRICT
immutable
as $function$
BEGIN
    x[1] := x[1] + 1;
    RETURN x;
END;
$function$;

select eatarray(rwagg(array[cast(1.0 as REAL)])), eatarray(rwagg(array[cast(1.0 as REAL)]));

rollback;

begin;

set parallel_setup_cost = 0;

set parallel_tuple_cost = 0;

set min_parallel_table_scan_size = 0;

set max_parallel_workers_per_gather = 4;

set parallel_leader_participation = off;

set enable_indexonlyscan = off;

select
  variance(cast(unique1 as INT)),
  SUM(cast(unique1 as BIGINT)),
  regr_count(
    cast(unique1 as DOUBLE PRECISION),
    cast(unique1 as DOUBLE PRECISION)
  )
from
  (
    select * from tenk1 union all select * from tenk1
    union all
    select * from tenk1
    union all
    select * from tenk1
  )
  as u;

select
  variance(cast(unique1 as INT)),
  SUM(cast(unique1 as BIGINT)),
  regr_count(
    cast(unique1 as DOUBLE PRECISION),
    cast(unique1 as DOUBLE PRECISION)
  )
from
  (
    select * from tenk1 union all select * from tenk1
    union all
    select * from tenk1
    union all
    select * from tenk1
  )
  as u;

select
  variance(cast(unique1 as BIGINT)),
  AVG(cast(unique1 as NUMERIC))
from
  (
    select * from tenk1 union all select * from tenk1
    union all
    select * from tenk1
    union all
    select * from tenk1
  )
  as u;

select
  variance(cast(unique1 as BIGINT)),
  AVG(cast(unique1 as NUMERIC))
from
  (
    select * from tenk1 union all select * from tenk1
    union all
    select * from tenk1
    union all
    select * from tenk1
  )
  as u;

rollback;

select
  DENSE_RANK(x) within group (order by x)
from
  (values (1), (1), (2), (2), (3), (3)) as v (x)
group by x
order by 1;

select MIN(x order by y) from (values (1, null)) as d (x, y);

select MIN(x order by y) from (values (1, 2)) as d (x, y);

select
  v || 'a',
  case v || 'a' when 'aa' then 1 else 0 end,
  COUNT(*)
from
  unnest(array['a', 'b']) as u (v)
group by v || 'a'
order by 1;

select
  v || 'a',
  case when v || 'a' = 'aa' then 1 else 0 end,
  COUNT(*)
from
  unnest(array['a', 'b']) as u (v)
group by v || 'a'
order by 1;

set enable_sort = 'false';

set work_mem = '64kB';

select
  unique1,
  COUNT(*),
  SUM(twothousand)
from
  tenk1
group by unique1
having
  SUM(fivethous) > 4975
order by SUM(twothousand);

set work_mem = default;

set enable_sort = default;

set work_mem = '64kB';

create table agg_data_2k as select g from generate_series(0, 1999) as g;

analyze agg_data_2k;

create table agg_data_20k as select g from generate_series(0, 19999) as g;

analyze agg_data_20k;

set enable_hashagg = 'false';

set jit_above_cost = 0;

select
  g % 10000 as c1,
  SUM(cast(g as NUMERIC)) as c2,
  COUNT(*) as c3
from
  agg_data_20k
group by g % 10000;

create table agg_group_1
as
  select
    g % 10000 as c1,
    SUM(cast(g as NUMERIC)) as c2,
    COUNT(*) as c3
  from
    agg_data_20k
  group by g % 10000;

create table agg_group_2
as
  select
    *
  from
    (values (100), (300), (500)) as r (a),
    lateral (
      select
        cast(g / 2 as NUMERIC) as c1,
        array_agg(cast(g as NUMERIC)) as c2,
        COUNT(*) as c3
      from
        agg_data_2k
      where
        g < r.a
      group by g / 2
    )
    as s;

set jit_above_cost = default;

create table agg_group_3
as
  select
    cast(g / 2 as NUMERIC) as c1,
    SUM(cast(7 as INT)) as c2,
    COUNT(*) as c3
  from
    agg_data_2k
  group by g / 2;

create table agg_group_4
as
  select
    cast(g / 2 as NUMERIC) as c1,
    array_agg(cast(g as NUMERIC)) as c2,
    COUNT(*) as c3
  from
    agg_data_2k
  group by g / 2;

set enable_hashagg = 'true';

set enable_sort = 'false';

set jit_above_cost = 0;

select
  g % 10000 as c1,
  SUM(cast(g as NUMERIC)) as c2,
  COUNT(*) as c3
from
  agg_data_20k
group by g % 10000;

create table agg_hash_1
as
  select
    g % 10000 as c1,
    SUM(cast(g as NUMERIC)) as c2,
    COUNT(*) as c3
  from
    agg_data_20k
  group by g % 10000;

create table agg_hash_2
as
  select
    *
  from
    (values (100), (300), (500)) as r (a),
    lateral (
      select
        cast(g / 2 as NUMERIC) as c1,
        array_agg(cast(g as NUMERIC)) as c2,
        COUNT(*) as c3
      from
        agg_data_2k
      where
        g < r.a
      group by g / 2
    )
    as s;

set jit_above_cost = default;

create table agg_hash_3
as
  select
    cast(g / 2 as NUMERIC) as c1,
    SUM(cast(7 as INT)) as c2,
    COUNT(*) as c3
  from
    agg_data_2k
  group by g / 2;

create table agg_hash_4
as
  select
    cast(g / 2 as NUMERIC) as c1,
    array_agg(cast(g as NUMERIC)) as c2,
    COUNT(*) as c3
  from
    agg_data_2k
  group by g / 2;

set enable_sort = 'true';

set work_mem = default;

select * from agg_hash_1
except
select * from agg_group_1
union all
(select * from agg_group_1
except
select * from agg_hash_1);

select * from agg_hash_2
except
select * from agg_group_2
union all
(select * from agg_group_2
except
select * from agg_hash_2);

select * from agg_hash_3
except
select * from agg_group_3
union all
(select * from agg_group_3
except
select * from agg_hash_3);

select * from agg_hash_4
except
select * from agg_group_4
union all
(select * from agg_group_4
except
select * from agg_hash_4);

drop TABLE agg_group_1;

drop TABLE agg_group_2;

drop TABLE agg_group_3;

drop TABLE agg_group_4;

drop TABLE agg_hash_1;

drop TABLE agg_hash_2;

drop TABLE agg_hash_3;

drop TABLE agg_hash_4;
