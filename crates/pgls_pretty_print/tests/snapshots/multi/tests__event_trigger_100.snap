---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/event_trigger.sql
---
create event trigger "regress_event_trigger" on ddl_command_start execute function pg_backend_pid();

create function test_event_trigger()
returns event_trigger
as $function$
BEGIN
    RAISE NOTICE 'test_event_trigger: % %', tg_event, tg_tag;
END
$function$
language plpgsql;

select test_event_trigger();

create function test_event_trigger_arg(name text)
returns event_trigger
as $function$
BEGIN RETURN 1; END
$function$
language plpgsql;

create function test_event_trigger_sql()
returns event_trigger
as $function$
SELECT 1
$function$
language sql;

create event trigger "regress_event_trigger"
on elephant_bootstrap
execute function test_event_trigger();

create event trigger "regress_event_trigger"
on ddl_command_start
execute function test_event_trigger();

create event trigger "regress_event_trigger_end"
on ddl_command_end
execute function test_event_trigger();

create event trigger "regress_event_trigger2"
on ddl_command_start
when FOOD in ('sandwich')
execute function test_event_trigger();

create event trigger "regress_event_trigger2"
on ddl_command_start
when TAG in ('sandwich')
execute function test_event_trigger();

create event trigger "regress_event_trigger2"
on ddl_command_start
when TAG in ('create table', 'create skunkcabbage')
execute function test_event_trigger();

create event trigger "regress_event_trigger2"
on ddl_command_start
when TAG in ('DROP EVENT TRIGGER')
execute function test_event_trigger();

create event trigger "regress_event_trigger2"
on ddl_command_start
when TAG in ('CREATE ROLE')
execute function test_event_trigger();

create event trigger "regress_event_trigger2"
on ddl_command_start
when TAG in ('CREATE DATABASE')
execute function test_event_trigger();

create event trigger "regress_event_trigger2"
on ddl_command_start
when TAG in ('CREATE TABLESPACE')
execute function test_event_trigger();

create event trigger "regress_event_trigger2"
on ddl_command_start
when TAG in ('create table') and TAG in ('CREATE FUNCTION')
execute function test_event_trigger();

create event trigger "regress_event_trigger2"
on ddl_command_start
when TAG in ('create table', 'CREATE FUNCTION')
execute function test_event_trigger();

comment on event trigger regress_event_trigger is 'test comment';

create role regress_evt_user;

set role to regress_evt_user;

create event trigger "regress_event_trigger_noperms"
on ddl_command_start
execute function test_event_trigger();

reset role;

alter event trigger regress_event_trigger disable;

create table event_trigger_fire1 (a int);

alter event trigger regress_event_trigger enable;

set session_replication_role = replica;

create table event_trigger_fire2 (a int);

alter event trigger regress_event_trigger enable replica;

create table event_trigger_fire3 (a int);

alter event trigger regress_event_trigger enable always;

create table event_trigger_fire4 (a int);

reset session_replication_role;

create table event_trigger_fire5 (a int);

create function f1()
returns int
language plpgsql
as $function$
begin
  create table event_trigger_fire6 (a int);
  return 0;
end
$function$;

select f1();

create procedure p1()
language plpgsql
as $procedure$
begin
  create table event_trigger_fire7 (a int);
end
$procedure$;

call p1();

alter event trigger regress_event_trigger disable;

drop table
  event_trigger_fire2,
  event_trigger_fire3,
  event_trigger_fire4,
  event_trigger_fire5,
  event_trigger_fire6,
  event_trigger_fire7;

drop routine f1(), p1();

grant all on table event_trigger_fire1 to public;

comment on table event_trigger_fire1 is 'here is a comment';

revoke all on table event_trigger_fire1 from public;

drop table event_trigger_fire1;

create foreign data wrapper useless;

create server useless_server foreign data wrapper useless;

create user mapping for regress_evt_user server useless_server;

alter default privileges for role regress_evt_user revoke DELETE on tables from regress_evt_user;

alter event trigger regress_event_trigger owner to regress_evt_user;

alter role regress_evt_user superuser;

alter event trigger regress_event_trigger owner to regress_evt_user;

alter event trigger regress_event_trigger rename to regress_event_trigger2;

alter event trigger regress_event_trigger rename to regress_event_trigger3;

drop event trigger regress_event_trigger;

drop role regress_evt_user;

drop event trigger if exists regress_event_trigger2;

drop event trigger if exists regress_event_trigger2;

drop event trigger regress_event_trigger3;

drop event trigger regress_event_trigger_end;

create schema "schema_one" authorization regress_evt_user;

create schema "schema_two" authorization regress_evt_user;

create schema "audit_tbls" authorization regress_evt_user;

create temporary table a_temp_tbl ();

set session authorization regress_evt_user;

create table schema_one.table_one (a int);

create table schema_one."table two" (a int);

create table schema_one.table_three (a int);

create table audit_tbls.schema_one_table_two (the_value text);

create table schema_two.table_two (a int);

create table schema_two.table_three (
  a int,
  b text
);

create table audit_tbls.schema_two_table_three (the_value text);

create or replace function schema_two.add(int, int)
returns int
language plpgsql
called on null input
as $function$
BEGIN RETURN coalesce($1,0) + coalesce($2,0); END;
$function$;

create aggregate schema_two.newton (basetype = int, sfunc = schema_two.add, stype = int);

reset session_authorization;

create table undroppable_objs (
  object_type text,
  object_identity text
);

insert into undroppable_objs
values
  ('table', 'schema_one.table_three'),
  ('table', 'audit_tbls.schema_two_table_three');

create table dropped_objects (
  object_type text,
  schema_name text,
  object_name text,
  object_identity text,
  address_names text[],
  address_args text[],
  is_temporary boolean,
  original boolean,
  normal boolean
);

create or replace function undroppable()
returns event_trigger
language plpgsql
as $function$
DECLARE
	obj record;
BEGIN
	PERFORM 1 FROM pg_tables WHERE tablename = 'undroppable_objs';
	IF NOT FOUND THEN
		RAISE NOTICE 'table undroppable_objs not found, skipping';
		RETURN;
	END IF;
	FOR obj IN
		SELECT * FROM pg_event_trigger_dropped_objects() JOIN
			undroppable_objs USING (object_type, object_identity)
	LOOP
		RAISE EXCEPTION 'object % of type % cannot be dropped',
			obj.object_identity, obj.object_type;
	END LOOP;
END;
$function$;

create event trigger "undroppable" on sql_drop execute function undroppable();

create or replace function test_evtrig_dropped_objects()
returns event_trigger
language plpgsql
as $function$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        IF obj.object_type = 'table' THEN
                EXECUTE format('DROP TABLE IF EXISTS audit_tbls.%I',
					format('%s_%s', obj.schema_name, obj.object_name));
        END IF;

	INSERT INTO dropped_objects
		(object_type, schema_name, object_name,
		 object_identity, address_names, address_args,
		 is_temporary, original, normal) VALUES
		(obj.object_type, obj.schema_name, obj.object_name,
		 obj.object_identity, obj.address_names, obj.address_args,
		 obj.is_temporary, obj.original, obj.normal);
    END LOOP;
END
$function$;

create event trigger "regress_event_trigger_drop_objects"
on sql_drop
when TAG in ('drop table', 'drop function', 'drop view', 'drop owned', 'drop schema', 'alter table')
execute function test_evtrig_dropped_objects();

alter table schema_one.table_one
  drop column a;

drop schema schema_one, schema_two cascade;

delete from undroppable_objs where object_identity = 'audit_tbls.schema_two_table_three';

drop schema schema_one, schema_two cascade;

delete from undroppable_objs where object_identity = 'schema_one.table_three';

drop schema schema_one, schema_two cascade;

select * from dropped_objects where schema_name is null or schema_name <> 'pg_toast';

drop owned by regress_evt_user;

select * from dropped_objects where object_type = 'schema';

drop role regress_evt_user;

drop event trigger regress_event_trigger_drop_objects;

drop event trigger undroppable;

create or replace function event_trigger_report_dropped()
returns event_trigger
language plpgsql
as $function$
DECLARE r record;
BEGIN
    FOR r IN SELECT * from pg_event_trigger_dropped_objects()
    LOOP
    IF NOT r.normal AND NOT r.original THEN
        CONTINUE;
    END IF;
    RAISE NOTICE 'NORMAL: orig=% normal=% istemp=% type=% identity=% schema=% name=% addr=% args=%',
        r.original, r.normal, r.is_temporary, r.object_type,
        r.object_identity, r.schema_name, r.object_name,
        r.address_names, r.address_args;
    END LOOP;
END;
$function$;

create event trigger "regress_event_trigger_report_dropped"
on sql_drop
execute function event_trigger_report_dropped();

create or replace function event_trigger_report_end()
returns event_trigger
language plpgsql
as $function$
DECLARE r RECORD;
BEGIN
    FOR r IN SELECT * FROM pg_event_trigger_ddl_commands()
    LOOP
        RAISE NOTICE 'END: command_tag=% type=% identity=%',
            r.command_tag, r.object_type, r.object_identity;
    END LOOP;
END;
$function$;

create event trigger "regress_event_trigger_report_end"
on ddl_command_end
execute function event_trigger_report_end();

create schema "evttrig";

create table one (
  col_a serial primary key,
  col_b text default 'forty two',
  col_c serial
);

create index "one_idx" on one using btree (col_b);

create table two (col_c int check (col_c > 0) references one default 42);

create table id (col_d int not null generated always as identity);

create table evttrig.parted (id int primary key)
partition by range(id);

create table evttrig.part_1_10 partition of evttrig.parted (id) for values from (1) to (10);

create table evttrig.part_10_20
partition of evttrig.parted
(
  id
)
for values from (10) to (20)
partition by range(id);

create table evttrig.part_10_15 partition of evttrig.part_10_20 (id) for values from (10) to (15);

create table evttrig.part_15_20 partition of evttrig.part_10_20 (id) for values from (15) to (20);

alter table evttrig.two
  drop column col_c;

alter table evttrig.one
  alter column col_b drop default;

alter table evttrig.one
  drop constraint one_pkey;

alter table evttrig.one
  drop column col_c;

alter table evttrig.id
  alter column col_d type bigint;

alter table evttrig.id
  alter column col_d drop identity,
  alter column col_d type int;

drop index evttrig.one_idx;

drop schema evttrig cascade;

drop table a_temp_tbl;

create or replace function event_trigger_report_dropped()
returns event_trigger
language plpgsql
as $function$
DECLARE r record;
BEGIN
    FOR r IN SELECT * from pg_event_trigger_dropped_objects()
    LOOP
    RAISE NOTICE 'DROP: orig=% normal=% istemp=% type=% identity=% schema=% name=% addr=% args=%',
        r.original, r.normal, r.is_temporary, r.object_type,
        r.object_identity, r.schema_name, r.object_name,
        r.address_names, r.address_args;
    END LOOP;
END;
$function$;

create function event_trigger_dummy_trigger()
returns trigger
language plpgsql
as $function$
BEGIN
    RETURN new;
END;
$function$;

create table evtrg_nontemp_table (
  f1 int primary key,
  f2 int default 42
);

create trigger evtrg_nontemp_trig
before insert
on evtrg_nontemp_table
for each statement
execute function event_trigger_dummy_trigger();

create policy evtrg_nontemp_pol
on evtrg_nontemp_table
as permissive
for all
to public
using (f2 > 0);

drop table evtrg_nontemp_table;

create temporary table a_temp_tbl (
  f1 int primary key,
  f2 int default 42
);

create trigger a_temp_trig
before insert
on a_temp_tbl
for each statement
execute function event_trigger_dummy_trigger();

create policy a_temp_pol on a_temp_tbl as permissive for all to public using (f2 > 0);

drop table a_temp_tbl;

drop function event_trigger_dummy_trigger();

create operator class evttrigopclass for type int using btree as storage int;

drop event trigger regress_event_trigger_report_dropped;

drop event trigger regress_event_trigger_report_end;

select pg_event_trigger_table_rewrite_oid();

create or replace function test_evtrig_no_rewrite()
returns event_trigger
language plpgsql
as $function$
BEGIN
  RAISE EXCEPTION 'rewrites not allowed';
END;
$function$;

create event trigger "no_rewrite_allowed"
on table_rewrite
execute function test_evtrig_no_rewrite();

create table rewriteme (
  id serial primary key,
  foo double precision,
  bar timestamp with time zone
);

insert into rewriteme select x * 1.001 from generate_series(1, 500) as t (x);

alter table rewriteme
  alter column foo type numeric;

alter table rewriteme
  add column baz int default 0;

create or replace function test_evtrig_no_rewrite()
returns event_trigger
language plpgsql
as $function$
BEGIN
  RAISE NOTICE 'Table ''%'' is being rewritten (reason = %)',
               pg_event_trigger_table_rewrite_oid()::regclass,
               pg_event_trigger_table_rewrite_reason();
END;
$function$;

alter table rewriteme
  add column onemore int default 0,
  add column another int default -1,
  alter column foo type numeric(10, 4);

create materialized view heapmv using heap as select 1 as a;

alter materialized view heapmv
  set access method heap2;

drop materialized view heapmv;

alter table rewriteme
  alter column foo type numeric(12, 4);

begin;

set time zone UTC;

alter table rewriteme
  alter column bar type timestamp;

set time zone '0';

alter table rewriteme
  alter column bar type timestamp with time zone;

set time zone 'Europe/London';

alter table rewriteme
  alter column bar type timestamp;

rollback;

create or replace function test_evtrig_no_rewrite()
returns event_trigger
language plpgsql
as $function$
BEGIN
  RAISE NOTICE 'Table is being rewritten (reason = %)',
               pg_event_trigger_table_rewrite_reason();
END;
$function$;

create type rewritetype as (a int);

create table rewritemetoo1 of rewritetype;

create table rewritemetoo2 of rewritetype;

alter type rewritetype
  alter attribute a type text cascade;

create table rewritemetoo3 (a rewritetype);

alter type rewritetype
  alter attribute a type varchar cascade;

drop table rewriteme;

drop event trigger no_rewrite_allowed;

drop function test_evtrig_no_rewrite();

create or replace function reindex_start_command()
returns event_trigger
as $function$
BEGIN
    RAISE NOTICE 'REINDEX START: % %', tg_event, tg_tag;
END;
$function$
language plpgsql;

create event trigger "regress_reindex_start"
on ddl_command_start
when TAG in ('REINDEX')
execute function reindex_start_command();

create function reindex_end_command()
returns event_trigger
as $function$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_ddl_commands()
    LOOP
        RAISE NOTICE 'REINDEX END: command_tag=% type=% identity=%',
	    obj.command_tag, obj.object_type, obj.object_identity;
    END LOOP;
END;
$function$
language plpgsql;

create event trigger "regress_reindex_end"
on ddl_command_end
when TAG in ('REINDEX')
execute function reindex_end_command();

create function reindex_end_command_snap()
returns event_trigger
as $function$
BEGIN PERFORM 1; END
$function$
language plpgsql;

create event trigger "regress_reindex_end_snap"
on ddl_command_end
execute function reindex_end_command_snap();

create table concur_reindex_tab (c1 int);

create index "concur_reindex_ind" on concur_reindex_tab using btree (c1);

reindex index concur_reindex_ind;

reindex table concur_reindex_tab;

reindex (CONCURRENTLY) index concur_reindex_ind;

reindex (CONCURRENTLY) table concur_reindex_tab;

alter event trigger regress_reindex_start disable;

reindex index concur_reindex_ind;

reindex (CONCURRENTLY) index concur_reindex_ind;

drop index concur_reindex_ind;

reindex table concur_reindex_tab;

reindex (CONCURRENTLY) table concur_reindex_tab;

create schema "concur_reindex_schema";

reindex schema concur_reindex_schema;

reindex (CONCURRENTLY) schema concur_reindex_schema;

create table concur_reindex_schema.tab (a int);

create index "ind" on concur_reindex_schema.tab using btree (a);

reindex schema concur_reindex_schema;

reindex (CONCURRENTLY) schema concur_reindex_schema;

drop index concur_reindex_schema.ind;

reindex schema concur_reindex_schema;

reindex (CONCURRENTLY) schema concur_reindex_schema;

drop schema concur_reindex_schema cascade;

create table concur_reindex_part (id int)
partition by range(id);

reindex table concur_reindex_part;

reindex (CONCURRENTLY) table concur_reindex_part;

create table concur_reindex_child partition of concur_reindex_part for values from (0) to (10);

reindex table concur_reindex_part;

reindex (CONCURRENTLY) table concur_reindex_part;

create index "concur_reindex_partidx" on concur_reindex_part using btree (id);

reindex index concur_reindex_partidx;

reindex (CONCURRENTLY) index concur_reindex_partidx;

reindex table concur_reindex_part;

reindex (CONCURRENTLY) table concur_reindex_part;

drop table concur_reindex_part;

drop event trigger regress_reindex_start;

drop event trigger regress_reindex_end;

drop event trigger regress_reindex_end_snap;

drop function reindex_end_command();

drop function reindex_end_command_snap();

drop function reindex_start_command();

drop table concur_reindex_tab;

reset session_authorization;

create table event_trigger_test (
  a int,
  b text
);

create or replace function start_command()
returns event_trigger
as $function$
BEGIN
RAISE NOTICE '% - ddl_command_start', tg_tag;
END;
$function$
language plpgsql;

create or replace function end_command()
returns event_trigger
as $function$
BEGIN
RAISE NOTICE '% - ddl_command_end', tg_tag;
END;
$function$
language plpgsql;

create or replace function drop_sql_command()
returns event_trigger
as $function$
BEGIN
RAISE NOTICE '% - sql_drop', tg_tag;
END;
$function$
language plpgsql;

create event trigger "start_rls_command"
on ddl_command_start
when TAG in ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY')
execute function start_command();

create event trigger "end_rls_command"
on ddl_command_end
when TAG in ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY')
execute function end_command();

create event trigger "sql_drop_command"
on sql_drop
when TAG in ('DROP POLICY')
execute function drop_sql_command();

create policy p1 on event_trigger_test as permissive for all to public using (false);

alter policy p1 on event_trigger_test using (true);

alter policy p1 on event_trigger_test rename to p2;

drop policy p2 on event_trigger_test;

select
  e.evtname,
  pg_describe_object(
    cast('pg_event_trigger' as regclass),
    e.oid,
    0
  )
  as descr,
  b.type,
  b.object_names,
  b.object_args,
  pg_identify_object(a.classid, a.objid, a.objsubid)
  as ident
from
  pg_event_trigger as e,
  lateral pg_identify_object_as_address(
    cast('pg_event_trigger' as regclass),
    e.oid,
    0
  )
  as b,
  lateral pg_get_object_address(
    b.type,
    b.object_names,
    b.object_args
  )
  as a
order by e.evtname;

drop event trigger start_rls_command;

drop event trigger end_rls_command;

drop event trigger sql_drop_command;

create function test_event_trigger_guc()
returns event_trigger
language plpgsql
as $function$
DECLARE
	obj record;
BEGIN
	FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
	LOOP
		RAISE NOTICE '% dropped %', tg_tag, obj.object_type;
	END LOOP;
END;
$function$;

create event trigger "test_event_trigger_guc"
on sql_drop
when TAG in ('DROP POLICY')
execute function test_event_trigger_guc();

set event_triggers = 'on';

create policy pguc on event_trigger_test as permissive for all to public using (false);

drop policy pguc on event_trigger_test;

create policy pguc on event_trigger_test as permissive for all to public using (false);

set event_triggers = off;

drop policy pguc on event_trigger_test;
