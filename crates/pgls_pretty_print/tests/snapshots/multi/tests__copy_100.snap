---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/copy.sql
snapshot_kind: text
---
create temporary table copytest (
  style TEXT,
  test TEXT,
  filler INT
);

insert into copytest values ('DOS', 'abc
def', 1);

insert into copytest values ('Unix', 'abc
def', 2);

insert into copytest values ('Mac', 'abcdef', 3);

insert into copytest values ('esc\ape', 'a\r\\
\nb', 4);

copy copytest to 'filename' with (FORMAT 'csv');

create temporary table copytest2 (like copytest);

copy copytest2 from 'filename' with (FORMAT 'csv');

select * from copytest except select * from copytest2;

truncate copytest2;

copy copytest to 'filename' with (FORMAT 'csv', QUOTE '''', ESCAPE '\');

copy copytest2 from 'filename' with (FORMAT 'csv', QUOTE '''', ESCAPE '\');

select * from copytest except select * from copytest2;

truncate copytest2;

copy copytest2 (test) from 'filename' with (FORMAT 'csv');

select test from copytest2 order by test collate "C";

truncate copytest2;

copy copytest2 (test) from stdout;

select test from copytest2;

create temporary table copytest3 (
  c1 INT,
  "col with , comma" TEXT,
  "col with "" quote" INT
);

copy copytest3 from stdout with (FORMAT 'csv', HEADER);

copy copytest3 to stdout with (FORMAT 'csv', HEADER);

create temporary table copytest4 (
  c1 INT,
  "colname with tab: 	" TEXT
);

copy copytest4 from stdout with (HEADER);

copy copytest4 to stdout with (HEADER);

create temporary table copytest5 (c1 INT);

copy copytest5 from stdout with (FORMAT 'csv', HEADER 2);

truncate copytest5;

copy copytest5 from stdout with (FORMAT 'csv', HEADER 4);

select COUNT(*) from copytest5;

truncate copytest5;

copy copytest5 from stdout with (FORMAT 'csv', HEADER 5);

select COUNT(*) from copytest5;

create table parted_copytest (
  a INT,
  b INT,
  c TEXT
)
partition by LIST(b);

create table parted_copytest_a1 (
  c TEXT,
  b INT,
  a INT
);

create table parted_copytest_a2 (
  a INT,
  c TEXT,
  b INT
);

alter table parted_copytest
  ATTACH partition
  parted_copytest_a1 for values in (1);

alter table parted_copytest
  ATTACH partition
  parted_copytest_a2 for values in (2);

insert into parted_copytest select x, 1, 'One' from generate_series(1, 1000) as x;

insert into parted_copytest select x, 2, 'Two' from generate_series(1001, 1010) as x;

insert into parted_copytest select x, 1, 'One' from generate_series(1011, 1020) as x;

copy (select * from parted_copytest order by a) to 'filename';

truncate parted_copytest;

copy parted_copytest from 'filename';

begin;

truncate parted_copytest;

copy parted_copytest from 'filename' with (FREEZE);

rollback;

select
  cast(tableoid as REGCLASS),
  COUNT(*),
  SUM(a)
from
  parted_copytest
group by tableoid
order by cast(cast(tableoid as REGCLASS) as NAME);

truncate parted_copytest;

create function part_ins_func()
returns trigger
language plpgsql
as $function$
begin
  return new;
end;
$function$;

create TRIGGER part_ins_trig
  before insert
  on parted_copytest_a2
  for EACH ROW
  EXECUTE FUNCTION part_ins_func();

copy parted_copytest from 'filename';

select
  cast(tableoid as REGCLASS),
  COUNT(*),
  SUM(a)
from
  parted_copytest
group by tableoid
order by cast(cast(tableoid as REGCLASS) as NAME);

truncate parted_copytest;

create index on parted_copytest using btree (b);

drop TRIGGER part_ins_trig on parted_copytest_a2;

copy parted_copytest from stdout;

select * from parted_copytest where b = 1;

select * from parted_copytest where b = 2;

drop TABLE parted_copytest;

create table tab_progress_reporting (
  name TEXT,
  age INT,
  location point,
  salary INT,
  manager NAME
);

create function notice_after_tab_progress_reporting()
returns trigger
as $function$
declare report record;
begin
  -- The fields ignored here are the ones that may not remain
  -- consistent across multiple runs.  The sizes reported may differ
  -- across platforms, so just check if these are strictly positive.
  with progress_data as (
    select
       relid::regclass::text as relname,
       command,
       type,
       bytes_processed > 0 as has_bytes_processed,
       bytes_total > 0 as has_bytes_total,
       tuples_processed,
       tuples_excluded,
       tuples_skipped
      from pg_stat_progress_copy
      where pid = pg_backend_pid())
  select into report (to_jsonb(r)) as value
    from progress_data r;

  raise info 'progress: %', report.value::text;
  return new;
end;
$function$
language plpgsql;

create TRIGGER check_after_tab_progress_reporting
  after insert
  on tab_progress_reporting
  for EACH STATEMENT
  EXECUTE FUNCTION notice_after_tab_progress_reporting();

copy tab_progress_reporting from stdout;

truncate tab_progress_reporting;

copy tab_progress_reporting from 'filename' where salary < 2000;

copy tab_progress_reporting from stdout with (ON_ERROR 'ignore');

drop TRIGGER check_after_tab_progress_reporting on tab_progress_reporting;

drop FUNCTION notice_after_tab_progress_reporting();

drop TABLE tab_progress_reporting;

create table header_copytest (
  a INT,
  b INT,
  c TEXT
);

alter table header_copytest
  drop column c;

alter table header_copytest
  add column c TEXT;

copy header_copytest to stdout;

copy header_copytest from stdout;

copy header_copytest from stdout;

select * from header_copytest order by a;

alter table header_copytest
  drop column b;

copy header_copytest (c, a) from stdout;

select * from header_copytest order by a;

drop TABLE header_copytest;

create temporary table oversized_column_default (
  col1 VARCHAR(5) default 'more than 5 chars',
  col2 VARCHAR(5)
);

copy oversized_column_default from stdout;

copy oversized_column_default (col2) from stdout;

copy oversized_column_default from stdout with (DEFAULT '');

drop TABLE oversized_column_default;

create table parted_si (
  id INT not null,
  data TEXT not null,
  rand DOUBLE PRECISION not null default random()
)
partition by LIST((id % 2));

create table parted_si_p_even partition of parted_si for values in (0);

create table parted_si_p_odd partition of parted_si for values in (1);

copy parted_si (id, data) from 'filename';

select
  cast(tableoid as REGCLASS),
  id % 2 = 0 as is_even,
  COUNT(*)
from
  parted_si
group by 1,
  2
order by 1;

drop TABLE parted_si;

begin;

create FOREIGN DATA WRAPPER copytest_wrapper;

create server copytest_server foreign data wrapper copytest_wrapper;

create foreign table copytest_foreign_table ( a INT ) SERVER copytest_server;

copy copytest_foreign_table from stdout with (FREEZE);

create materialized view copytest_mv as select 1 as id with no data;

copy copytest_mv (id) to stdout;

refresh materialized view copytest_mv;

copy copytest_mv (id) to stdout;

drop MATERIALIZED VIEW copytest_mv;
