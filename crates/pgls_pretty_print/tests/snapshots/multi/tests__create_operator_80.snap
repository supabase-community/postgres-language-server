---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/create_operator.sql
snapshot_kind: text
---
create operator ## (LEFTARG = path,
RIGHTARG = path,
FUNCTION = path_inter,
COMMUTATOR = ##);

create operator @#@ (RIGHTARG = BIGINT, PROCEDURE = factorial);

create operator #%# (LEFTARG = BIGINT, PROCEDURE = factorial);

select @#@24;

select @@##@@24;

set search_path to pg_catalog;

select @#@24;

reset search_path;

select @#@24.0;

comment on operator ###### (NONE, INT) is 'bad prefix';

comment on operator ###### (INT, NONE) is 'bad postfix';

comment on operator ###### (INT, BIGINT) is 'bad infix';

drop OPERATOR ###### (NONE, INT);

drop OPERATOR ###### (INT, NONE);

drop OPERATOR ###### (INT, BIGINT);

create operator !=- (RIGHTARG = BIGINT, PROCEDURE = factorial);

select !=-10;

select 2 <> 1, 2 <> 2;

select 2 <> 1;

do
$$ -- use DO to protect -- from psql
  declare r boolean;
  begin
    execute $e$ select 2 !=-- comment
      1 $e$ into r;
    raise info 'r = %', r;
  end;
$$;

select true <> -1 between 1 and 1;

select false <> 1 between 1 and 1;

select false <= -1 between 1 and 1;

select false >= -1 between 1 and 1;

select 2 <= 3, 3 >= 2, 2 <> 3;

select 3 <= 2, 2 >= 3, 2 <> 2;

begin;

create role regress_rol_op1;

create schema "schema_op1";

grant USAGE on schema schema_op1 to PUBLIC;

revoke USAGE on schema schema_op1 from regress_rol_op1;

set role to regress_rol_op1;

create operator schema_op1.#*# (RIGHTARG = BIGINT, PROCEDURE = factorial);

rollback;

begin;

create operator #*# (LEFTARG = setof BIGINT, PROCEDURE = factorial);

rollback;

begin;

create operator #*# (RIGHTARG = setof BIGINT, PROCEDURE = factorial);

rollback;

begin;

create or replace function fn_op2(BOOLEAN, BOOLEAN)
returns BOOLEAN
as '
    SELECT NULL::BOOLEAN;
'
language "sql"
immutable;

create operator === (LEFTARG = BOOLEAN,
RIGHTARG = BOOLEAN,
PROCEDURE = fn_op2,
COMMUTATOR = ===,
NEGATOR = !==,
RESTRICT = contsel,
JOIN = contjoinsel,
SORT1,
SORT2,
LTCMP,
GTCMP,
HASHES,
MERGES);

rollback;

create operator #@%# (RIGHTARG = BIGINT,
PROCEDURE = factorial,
INVALID_ATT = BIGINT);

create operator #@%# (PROCEDURE = factorial);

create operator #@%# (RIGHTARG = BIGINT);

begin;

create role regress_rol_op3;

create type type_op3 as enum ('new', 'open', 'closed');

create function fn_op3(type_op3, BIGINT)
returns BIGINT
as '
    SELECT NULL::int8;
'
language "sql"
immutable;

revoke USAGE on type type_op3 from regress_rol_op3;

revoke USAGE on type type_op3 from PUBLIC;

set role to regress_rol_op3;

create operator #*# (LEFTARG = type_op3, RIGHTARG = BIGINT, PROCEDURE = fn_op3);

rollback;

begin;

create role regress_rol_op4;

create type type_op4 as enum ('new', 'open', 'closed');

create function fn_op4(BIGINT, type_op4)
returns BIGINT
as '
    SELECT NULL::int8;
'
language "sql"
immutable;

revoke USAGE on type type_op4 from regress_rol_op4;

revoke USAGE on type type_op4 from PUBLIC;

set role to regress_rol_op4;

create operator #*# (LEFTARG = BIGINT, RIGHTARG = type_op4, PROCEDURE = fn_op4);

rollback;

begin;

create role regress_rol_op5;

create type type_op5 as enum ('new', 'open', 'closed');

create function fn_op5(BIGINT, BIGINT)
returns BIGINT
as '
    SELECT NULL::int8;
'
language "sql"
immutable;

revoke EXECUTE on function fn_op5(BIGINT, BIGINT) from regress_rol_op5;

revoke EXECUTE on function fn_op5(BIGINT, BIGINT) from PUBLIC;

set role to regress_rol_op5;

create operator #*# (LEFTARG = BIGINT, RIGHTARG = BIGINT, PROCEDURE = fn_op5);

rollback;

begin;

create role regress_rol_op6;

create type type_op6 as enum ('new', 'open', 'closed');

create function fn_op6(BIGINT, BIGINT)
returns type_op6
as '
    SELECT NULL::type_op6;
'
language "sql"
immutable;

revoke USAGE on type type_op6 from regress_rol_op6;

revoke USAGE on type type_op6 from PUBLIC;

set role to regress_rol_op6;

create operator #*# (LEFTARG = BIGINT, RIGHTARG = BIGINT, PROCEDURE = fn_op6);

rollback;

begin;

create operator === (LEFTARG = INT,
RIGHTARG = INT,
PROCEDURE = int4eq,
NEGATOR = ===);

rollback;

begin;

create operator === (LEFTARG = INT,
RIGHTARG = INT,
PROCEDURE = int4eq,
COMMUTATOR = ===!!!);

create operator ===!!! (LEFTARG = INT,
RIGHTARG = INT,
PROCEDURE = int4ne,
NEGATOR = ===!!!);

rollback;

create operator === (LEFTARG = INT,
RIGHTARG = INT,
PROCEDURE = int4eq,
COMMUTATOR = =);

create operator === (LEFTARG = INT,
RIGHTARG = INT,
PROCEDURE = int4eq,
NEGATOR = <>);

create operator === (LEFTARG = box,
RIGHTARG = box,
PROCEDURE = area_equal_function,
COMMUTATOR = ===,
NEGATOR = !==,
RESTRICT = area_restriction_function,
JOIN = area_join_function,
HASHES,
MERGES);
