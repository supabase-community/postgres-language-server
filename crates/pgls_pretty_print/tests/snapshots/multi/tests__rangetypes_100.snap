---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/rangetypes.sql
snapshot_kind: text
---
select cast('' as textrange);

select cast('-[a,z)' as textrange);

select cast('[a,z) - ' as textrange);

select cast('(",a)' as textrange);

select cast('(,,a)' as textrange);

select cast('(),a)' as textrange);

select cast('(a,))' as textrange);

select cast('(],a)' as textrange);

select cast('(a,])' as textrange);

select cast('[z,a]' as textrange);

select cast('  empty  ' as textrange);

select cast(' ( empty, empty )  ' as textrange);

select cast(' ( " a " " a ", " z " " z " )  ' as textrange);

select cast('(a,)' as textrange);

select cast('[,z]' as textrange);

select cast('[a,]' as textrange);

select cast('(,)' as textrange);

select cast('[ , ]' as textrange);

select cast('["",""]' as textrange);

select cast('[",",","]' as textrange);

select cast('["\\","\\"]' as textrange);

select cast('(\\,a)' as textrange);

select cast('((,z)' as textrange);

select cast('([,z)' as textrange);

select cast('(!,()' as textrange);

select cast('(!,[)' as textrange);

select cast('[a,a]' as textrange);

select cast('[a,a)' as textrange);

select cast('(a,a]' as textrange);

select cast('(a,a)' as textrange);

select pg_input_is_valid('(1,4)', 'int4range');

select pg_input_is_valid('(1,4', 'int4range');

select * from pg_input_error_info('(1,4', 'int4range');

select pg_input_is_valid('(4,1)', 'int4range');

select * from pg_input_error_info('(4,1)', 'int4range');

select pg_input_is_valid('(4,zed)', 'int4range');

select * from pg_input_error_info('(4,zed)', 'int4range');

select pg_input_is_valid('[1,2147483647]', 'int4range');

select * from pg_input_error_info('[1,2147483647]', 'int4range');

select pg_input_is_valid('[2000-01-01,5874897-12-31]', 'daterange');

select * from pg_input_error_info('[2000-01-01,5874897-12-31]', 'daterange');

create table numrange_test (nr numrange);

create index "numrange_test_btree" on numrange_test using btree (nr);

insert into numrange_test values ('[,)');

insert into numrange_test values ('[3,]');

insert into numrange_test values ('[, 5)');

insert into numrange_test values (numrange(1.1, 2.2));

insert into numrange_test values ('empty');

insert into numrange_test values (numrange(1.7, 1.7, '[]'));

select nr, isempty(nr), lower(nr), upper(nr) from numrange_test;

select nr, lower_inc(nr), lower_inf(nr), upper_inc(nr), upper_inf(nr) from numrange_test;

select * from numrange_test where range_contains(nr, numrange(1.9, 1.91));

select * from numrange_test where nr @> numrange(1.0, 10000.1);

select * from numrange_test where range_contained_by(numrange(-1e7, -10000.1), nr);

select * from numrange_test where 1.9 <@ nr;

select * from numrange_test where nr = 'empty';

select * from numrange_test where nr = '(1.1, 2.2)';

select * from numrange_test where nr = '[1.1, 2.2)';

select * from numrange_test where nr < 'empty';

select * from numrange_test where nr < numrange(-1000.0, -1000.0, '[]');

select * from numrange_test where nr < numrange(0.0, 1.0, '[]');

select * from numrange_test where nr < numrange(1000.0, 1001.0, '[]');

select * from numrange_test where nr <= 'empty';

select * from numrange_test where nr >= 'empty';

select * from numrange_test where nr > 'empty';

select * from numrange_test where nr > numrange(-1001.0, -1000.0, '[]');

select * from numrange_test where nr > numrange(0.0, 1.0, '[]');

select * from numrange_test where nr > numrange(1000.0, 1000.0, '[]');

select numrange(2.0, 1.0);

select numrange(2.0, 3.0) -|- numrange(3.0, 4.0);

select range_adjacent(numrange(2.0, 3.0), numrange(3.1, 4.0));

select range_adjacent(numrange(2.0, 3.0), numrange(3.1, null));

select numrange(2.0, 3.0, '[]') -|- numrange(3.0, 4.0, '()');

select numrange(1.0, 2.0) -|- numrange(2.0, 3.0, '[]');

select range_adjacent(numrange(2.0, 3.0, '(]'), numrange(1.0, 2.0, '(]'));

select numrange(1.1, 3.3) <@ numrange(0.1, 10.1);

select numrange(0.1, 10.1) <@ numrange(1.1, 3.3);

select numrange(1.1, 2.2) - numrange(2.0, 3.0);

select numrange(1.1, 2.2) - numrange(2.2, 3.0);

select numrange(1.1, 2.2, '[]') - numrange(2.0, 3.0);

select range_minus(numrange(10.1, 12.2, '[]'), numrange(110.0, 120.2, '(]'));

select range_minus(numrange(10.1, 12.2, '[]'), numrange(0.0, 120.2, '(]'));

select numrange(4.5, 5.5, '[]') && numrange(5.5, 6.5);

select numrange(1.0, 2.0) << numrange(3.0, 4.0);

select numrange(1.0, 3.0, '[]') << numrange(3.0, 4.0, '[]');

select numrange(1.0, 3.0, '()') << numrange(3.0, 4.0, '()');

select numrange(1.0, 2.0) >> numrange(3.0, 4.0);

select numrange(3.0, 70.0) &< numrange(6.6, 100.0);

select numrange(1.1, 2.2) < numrange(1.0, 200.2);

select numrange(1.1, 2.2) < numrange(1.1, 1.2);

select numrange(1.0, 2.0) + numrange(2.0, 3.0);

select numrange(1.0, 2.0) + numrange(1.5, 3.0);

select numrange(1.0, 2.0) + numrange(2.5, 3.0);

select range_merge(numrange(1.0, 2.0), numrange(2.0, 3.0));

select range_merge(numrange(1.0, 2.0), numrange(1.5, 3.0));

select range_merge(numrange(1.0, 2.0), numrange(2.5, 3.0));

select numrange(1.0, 2.0) * numrange(2.0, 3.0);

select numrange(1.0, 2.0) * numrange(1.5, 3.0);

select numrange(1.0, 2.0) * numrange(2.5, 3.0);

select range_intersect_agg(nr) from numrange_test;

select range_intersect_agg(nr) from numrange_test where false;

select range_intersect_agg(nr) from numrange_test where nr @> 4.0;

analyze numrange_test;

create table numrange_test2 (nr numrange);

create index "numrange_test2_hash_idx" on numrange_test2 using hash (nr);

insert into numrange_test2 values ('[, 5)');

insert into numrange_test2 values (numrange(1.1, 2.2));

insert into numrange_test2 values (numrange(1.1, 2.2));

insert into numrange_test2 values (numrange(1.1, 2.2, '()'));

insert into numrange_test2 values ('empty');

select * from numrange_test2 where nr = cast('empty' as numrange);

select * from numrange_test2 where nr = numrange(1.1, 2.2);

select * from numrange_test2 where nr = numrange(1.1, 2.3);

set enable_nestloop = t;

set enable_hashjoin = f;

set enable_mergejoin = f;

select * from numrange_test natural join numrange_test2 order by nr;

set enable_nestloop = f;

set enable_hashjoin = t;

set enable_mergejoin = f;

select * from numrange_test natural join numrange_test2 order by nr;

set enable_nestloop = f;

set enable_hashjoin = f;

set enable_mergejoin = t;

select * from numrange_test natural join numrange_test2 order by nr;

set enable_nestloop = default;

set enable_hashjoin = default;

set enable_mergejoin = default;

drop table numrange_test2;

create table textrange_test (tr textrange);

create index "textrange_test_btree" on textrange_test using btree (tr);

insert into textrange_test values ('[,)');

insert into textrange_test values ('["a",]');

insert into textrange_test values ('[,"q")');

insert into textrange_test values (textrange('b', 'g'));

insert into textrange_test values ('empty');

insert into textrange_test values (textrange('d', 'd', '[]'));

select tr, isempty(tr), lower(tr), upper(tr) from textrange_test;

select tr, lower_inc(tr), lower_inf(tr), upper_inc(tr), upper_inf(tr) from textrange_test;

select * from textrange_test where range_contains(tr, textrange('f', 'fx'));

select * from textrange_test where tr @> textrange('a', 'z');

select * from textrange_test where range_contained_by(textrange('0', '9'), tr);

select * from textrange_test where cast('e' as text) <@ tr;

select * from textrange_test where tr = 'empty';

select * from textrange_test where tr = '("b","g")';

select * from textrange_test where tr = '["b","g")';

select * from textrange_test where tr < 'empty';

select int4range(1, 10, '[]');

select int4range(1, 10, '[)');

select int4range(1, 10, '(]');

select int4range(1, 10, '()');

select int4range(1, 2, '()');

select daterange(cast('2000-01-10' as date), cast('2000-01-20' as date), '[]');

select daterange(cast('2000-01-10' as date), cast('2000-01-20' as date), '[)');

select daterange(cast('2000-01-10' as date), cast('2000-01-20' as date), '(]');

select daterange(cast('2000-01-10' as date), cast('2000-01-20' as date), '()');

select daterange(cast('2000-01-10' as date), cast('2000-01-11' as date), '()');

select daterange(cast('2000-01-10' as date), cast('2000-01-11' as date), '(]');

select daterange(cast('-infinity' as date), cast('2000-01-01' as date), '()');

select daterange(cast('-infinity' as date), cast('2000-01-01' as date), '[)');

select daterange(cast('2000-01-01' as date), cast('infinity' as date), '[)');

select daterange(cast('2000-01-01' as date), cast('infinity' as date), '[]');

create table test_range_gist (ir int4range);

create index "test_range_gist_idx" on test_range_gist using gist (ir);

insert into test_range_gist select int4range(g, g + 10) from generate_series(1, 2000) as g;

insert into test_range_gist select cast('empty' as int4range) from generate_series(1, 500) as g;

insert into test_range_gist select int4range(g, g + 10000) from generate_series(1, 1000) as g;

insert into test_range_gist select cast('empty' as int4range) from generate_series(1, 500) as g;

insert into test_range_gist select int4range(null, g * 10, '(]') from generate_series(1, 100) as g;

insert into test_range_gist select int4range(g * 10, null, '(]') from generate_series(1, 100) as g;

insert into test_range_gist select int4range(g, g + 10) from generate_series(1, 2000) as g;

analyze test_range_gist;

set enable_seqscan = t;

set enable_indexscan = f;

set enable_bitmapscan = f;

select COUNT(*) from test_range_gist where ir @> cast('empty' as int4range);

select COUNT(*) from test_range_gist where ir = int4range(10, 20);

select COUNT(*) from test_range_gist where ir @> 10;

select COUNT(*) from test_range_gist where ir @> int4range(10, 20);

select COUNT(*) from test_range_gist where ir && int4range(10, 20);

select COUNT(*) from test_range_gist where ir <@ int4range(10, 50);

select COUNT(*) from test_range_gist where ir << int4range(100, 500);

select COUNT(*) from test_range_gist where ir >> int4range(100, 500);

select COUNT(*) from test_range_gist where ir &< int4range(100, 500);

select COUNT(*) from test_range_gist where ir &> int4range(100, 500);

select COUNT(*) from test_range_gist where ir -|- int4range(100, 500);

select COUNT(*) from test_range_gist where ir @> cast('{}' as int4multirange);

select
  COUNT(*)
from
  test_range_gist
where
  ir @>
  int4multirange(
    int4range(10, 20),
    int4range(30, 40)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir &&
  cast('{(10,20),(30,40),(50,60)}'
  as int4multirange);

select
  COUNT(*)
from
  test_range_gist
where
  ir <@
  cast('{(10,30),(40,60),(70,90)}'
  as int4multirange);

select
  COUNT(*)
from
  test_range_gist
where
  ir <<
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir >>
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir &<
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir &>
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir -|-
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

set enable_seqscan = f;

set enable_indexscan = t;

set enable_bitmapscan = f;

select COUNT(*) from test_range_gist where ir @> cast('empty' as int4range);

select COUNT(*) from test_range_gist where ir = int4range(10, 20);

select COUNT(*) from test_range_gist where ir @> 10;

select COUNT(*) from test_range_gist where ir @> int4range(10, 20);

select COUNT(*) from test_range_gist where ir && int4range(10, 20);

select COUNT(*) from test_range_gist where ir <@ int4range(10, 50);

select COUNT(*) from test_range_gist where ir << int4range(100, 500);

select COUNT(*) from test_range_gist where ir >> int4range(100, 500);

select COUNT(*) from test_range_gist where ir &< int4range(100, 500);

select COUNT(*) from test_range_gist where ir &> int4range(100, 500);

select COUNT(*) from test_range_gist where ir -|- int4range(100, 500);

select COUNT(*) from test_range_gist where ir @> cast('{}' as int4multirange);

select
  COUNT(*)
from
  test_range_gist
where
  ir @>
  int4multirange(
    int4range(10, 20),
    int4range(30, 40)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir &&
  cast('{(10,20),(30,40),(50,60)}'
  as int4multirange);

select
  COUNT(*)
from
  test_range_gist
where
  ir <@
  cast('{(10,30),(40,60),(70,90)}'
  as int4multirange);

select
  COUNT(*)
from
  test_range_gist
where
  ir <<
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir >>
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir &<
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir &>
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir -|-
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

drop index test_range_gist_idx;

create index "test_range_gist_idx" on test_range_gist using gist (ir);

select COUNT(*) from test_range_gist where ir @> cast('empty' as int4range);

select COUNT(*) from test_range_gist where ir = int4range(10, 20);

select COUNT(*) from test_range_gist where ir @> 10;

select COUNT(*) from test_range_gist where ir @> int4range(10, 20);

select COUNT(*) from test_range_gist where ir && int4range(10, 20);

select COUNT(*) from test_range_gist where ir <@ int4range(10, 50);

select COUNT(*) from test_range_gist where ir << int4range(100, 500);

select COUNT(*) from test_range_gist where ir >> int4range(100, 500);

select COUNT(*) from test_range_gist where ir &< int4range(100, 500);

select COUNT(*) from test_range_gist where ir &> int4range(100, 500);

select COUNT(*) from test_range_gist where ir -|- int4range(100, 500);

select COUNT(*) from test_range_gist where ir @> cast('{}' as int4multirange);

select
  COUNT(*)
from
  test_range_gist
where
  ir @>
  int4multirange(
    int4range(10, 20),
    int4range(30, 40)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir &&
  cast('{(10,20),(30,40),(50,60)}'
  as int4multirange);

select
  COUNT(*)
from
  test_range_gist
where
  ir <@
  cast('{(10,30),(40,60),(70,90)}'
  as int4multirange);

select
  COUNT(*)
from
  test_range_gist
where
  ir <<
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir >>
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir &<
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir &>
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

select
  COUNT(*)
from
  test_range_gist
where
  ir -|-
  int4multirange(
    int4range(100, 200),
    int4range(400, 500)
  );

create table test_range_spgist (ir int4range);

create index "test_range_spgist_idx" on test_range_spgist using spgist (ir);

insert into test_range_spgist select int4range(g, g + 10) from generate_series(1, 2000) as g;

insert into test_range_spgist select cast('empty' as int4range) from generate_series(1, 500) as g;

insert into test_range_spgist select int4range(g, g + 10000) from generate_series(1, 1000) as g;

insert into test_range_spgist select cast('empty' as int4range) from generate_series(1, 500) as g;

insert into test_range_spgist
select
  int4range(null, g * 10, '(]')
from
  generate_series(1, 100) as g;

insert into test_range_spgist
select
  int4range(g * 10, null, '(]')
from
  generate_series(1, 100) as g;

insert into test_range_spgist select int4range(g, g + 10) from generate_series(1, 2000) as g;

set enable_seqscan = t;

set enable_indexscan = f;

set enable_bitmapscan = f;

select COUNT(*) from test_range_spgist where ir @> cast('empty' as int4range);

select COUNT(*) from test_range_spgist where ir = int4range(10, 20);

select COUNT(*) from test_range_spgist where ir @> 10;

select COUNT(*) from test_range_spgist where ir @> int4range(10, 20);

select COUNT(*) from test_range_spgist where ir && int4range(10, 20);

select COUNT(*) from test_range_spgist where ir <@ int4range(10, 50);

select COUNT(*) from test_range_spgist where ir << int4range(100, 500);

select COUNT(*) from test_range_spgist where ir >> int4range(100, 500);

select COUNT(*) from test_range_spgist where ir &< int4range(100, 500);

select COUNT(*) from test_range_spgist where ir &> int4range(100, 500);

select COUNT(*) from test_range_spgist where ir -|- int4range(100, 500);

set enable_seqscan = f;

set enable_indexscan = t;

set enable_bitmapscan = f;

select COUNT(*) from test_range_spgist where ir @> cast('empty' as int4range);

select COUNT(*) from test_range_spgist where ir = int4range(10, 20);

select COUNT(*) from test_range_spgist where ir @> 10;

select COUNT(*) from test_range_spgist where ir @> int4range(10, 20);

select COUNT(*) from test_range_spgist where ir && int4range(10, 20);

select COUNT(*) from test_range_spgist where ir <@ int4range(10, 50);

select COUNT(*) from test_range_spgist where ir << int4range(100, 500);

select COUNT(*) from test_range_spgist where ir >> int4range(100, 500);

select COUNT(*) from test_range_spgist where ir &< int4range(100, 500);

select COUNT(*) from test_range_spgist where ir &> int4range(100, 500);

select COUNT(*) from test_range_spgist where ir -|- int4range(100, 500);

drop index test_range_spgist_idx;

create index "test_range_spgist_idx" on test_range_spgist using spgist (ir);

select COUNT(*) from test_range_spgist where ir @> cast('empty' as int4range);

select COUNT(*) from test_range_spgist where ir = int4range(10, 20);

select COUNT(*) from test_range_spgist where ir @> 10;

select COUNT(*) from test_range_spgist where ir @> int4range(10, 20);

select COUNT(*) from test_range_spgist where ir && int4range(10, 20);

select COUNT(*) from test_range_spgist where ir <@ int4range(10, 50);

select COUNT(*) from test_range_spgist where ir << int4range(100, 500);

select COUNT(*) from test_range_spgist where ir >> int4range(100, 500);

select COUNT(*) from test_range_spgist where ir &< int4range(100, 500);

select COUNT(*) from test_range_spgist where ir &> int4range(100, 500);

select COUNT(*) from test_range_spgist where ir -|- int4range(100, 500);

select ir from test_range_spgist where ir -|- int4range(10, 20) order by ir;

select ir from test_range_spgist where ir -|- int4range(10, 20) order by ir;

reset enable_seqscan;

reset enable_indexscan;

reset enable_bitmapscan;

create table test_range_elem (i int);

create index "test_range_elem_idx" on test_range_elem using btree (i);

insert into test_range_elem select i from generate_series(1, 100) as i;

set enable_seqscan = f;

select COUNT(*) from test_range_elem where i <@ int4range(10, 50);

create index on test_range_elem using spgist ((int4range(i, i + 10)));

select COUNT(*) from test_range_elem where int4range(i, i + 10) <@ int4range(10, 30);

select COUNT(*) from test_range_elem where int4range(i, i + 10) <@ int4range(10, 30);

reset enable_seqscan;

drop table test_range_elem;

create table test_range_excl (
  room int4range,
  speaker int4range,
  during tsrange,
  exclude using gist (room with =, during with &&),
  exclude using gist (speaker with =,
  during with &&)
);

insert into test_range_excl
values
  (
    int4range(123, 123, '[]'),
    int4range(1, 1, '[]'),
    '[2010-01-02 10:00, 2010-01-02 11:00)'
  );

insert into test_range_excl
values
  (
    int4range(123, 123, '[]'),
    int4range(2, 2, '[]'),
    '[2010-01-02 11:00, 2010-01-02 12:00)'
  );

insert into test_range_excl
values
  (
    int4range(123, 123, '[]'),
    int4range(3, 3, '[]'),
    '[2010-01-02 10:10, 2010-01-02 11:00)'
  );

insert into test_range_excl
values
  (
    int4range(124, 124, '[]'),
    int4range(3, 3, '[]'),
    '[2010-01-02 10:10, 2010-01-02 11:10)'
  );

insert into test_range_excl
values
  (
    int4range(125, 125, '[]'),
    int4range(1, 1, '[]'),
    '[2010-01-02 10:10, 2010-01-02 11:00)'
  );

select int8range(cast(10000000000 as bigint), cast(20000000000 as bigint), '(]');

set time zone '-08';

select cast('[2010-01-01 01:00:00 -05, 2010-01-01 02:00:00 -08)' as tstzrange);

select cast('[2010-01-01 01:00:00 -08, 2010-01-01 02:00:00 -05)' as tstzrange);

set timezone to default;

create type bogus_float8range as range (subtype = double precision, subtype_diff = float4mi);

select cast('[123.001, 5.e9)' as float8range) @> cast(888.882 as double precision);

create table float8range_test (
  f8r float8range,
  i int
);

insert into float8range_test values (float8range(-100.00007, '1.111113e9'), 42);

select * from float8range_test;

drop table float8range_test;

create domain mydomain as int;

create type mydomainrange as range (subtype = mydomain);

select cast('[4,50)' as mydomainrange) @> cast(7 as mydomain);

drop domain mydomain;

drop domain mydomain cascade;

create domain restrictedrange as int4range check (upper(value) < 10);

select cast('[4,5)' as restrictedrange) @> 7;

select cast('[4,50)' as restrictedrange) @> 7;

drop domain restrictedrange;

create type textrange1 as range (subtype = text, collation = "C");

create type textrange2 as range (subtype = text, collation = "C");

select textrange1('a', 'Z') @> cast('b' as text);

select textrange2('a', 'z') @> cast('b' as text);

drop type textrange1;

drop type textrange2;

create function anyarray_anyrange_func(a anyarray, r anyrange)
returns anyelement
as $function$select $1[1] + lower($2);$function$
language sql;

select anyarray_anyrange_func(array[1, 2], int4range(10, 20));

select anyarray_anyrange_func(array[1, 2], numrange(10, 20));

drop function anyarray_anyrange_func(anyarray, anyrange);

create function bogus_func(anyelement)
returns anyrange
as $function$select int4range(1,10)$function$
language sql;

create function bogus_func(int)
returns anyrange
as $function$select int4range(1,10)$function$
language sql;

create function range_add_bounds(anyrange)
returns anyelement
as $function$select lower($1) + upper($1)$function$
language sql;

select range_add_bounds(int4range(1, 17));

select range_add_bounds(numrange(1.0001, 123.123));

create function rangetypes_sql(q anyrange, b anyarray, out c anyelement)
as $function$ select upper($1) + $2[1] $function$
language sql;

select rangetypes_sql(int4range(1, 10), array[2, 20]);

select rangetypes_sql(numrange(1, 10), array[2, 20]);

create function
anycompatiblearray_anycompatiblerange_func(
  a anycompatiblearray,
  r anycompatiblerange
)
returns anycompatible
as $function$select $1[1] + lower($2);$function$
language sql;

select anycompatiblearray_anycompatiblerange_func(array[1, 2], int4range(10, 20));

select anycompatiblearray_anycompatiblerange_func(array[1, 2], numrange(10, 20));

select anycompatiblearray_anycompatiblerange_func(array[1.1, 2], int4range(10, 20));

drop function anycompatiblearray_anycompatiblerange_func(anycompatiblearray, anycompatiblerange);

create function bogus_func(anycompatible)
returns anycompatiblerange
as $function$select int4range(1,10)$function$
language sql;

select array[numrange(1.1, 1.2), numrange(12.3, 155.5)];

create table i8r_array (
  f1 int,
  f2 int8range[]
);

insert into i8r_array values (42, array[int8range(1, 10), int8range(2, 20)]);

select * from i8r_array;

drop table i8r_array;

create type arrayrange as range (subtype = int[]);

select arrayrange(array[1, 2], array[2, 1]);

select arrayrange(array[2, 1], array[1, 2]);

select array[1, 1] <@ arrayrange(array[1, 2], array[2, 1]);

select array[1, 3] <@ arrayrange(array[1, 2], array[2, 1]);

create type two_ints as (a int, b int);

create type two_ints_range as range (subtype = two_ints);

select
  *,
  row_to_json(upper(t)) as u
from
  (
    values
      (two_ints_range(row(1, 2), row(3, 4))),
      (two_ints_range(row(5, 6), row(7, 8)))
  )
  as v (t);

alter type two_ints
  add attribute c two_ints_range;

drop type two_ints cascade;

create type varbitrange as range (subtype = bit varying);

set enable_sort = off;

select cast('(01,10)' as varbitrange) except select cast('(10,11)' as varbitrange);

reset enable_sort;

create function outparam_succeed(i anyrange, out r anyrange, out t text)
as $function$ select $1, 'foo'::text $function$
language sql;

select * from outparam_succeed(int4range(1, 2));

create function outparam2_succeed(r anyrange, out lu anyarray, out ul anyarray)
as $function$ select array[lower($1), upper($1)], array[upper($1), lower($1)] $function$
language sql;

select * from outparam2_succeed(int4range(1, 11));

create function outparam_succeed2(i anyrange, out r anyarray, out t text)
as $function$ select ARRAY[upper($1)], 'foo'::text $function$
language sql;

select * from outparam_succeed2(int4range(int4range(1, 2)));

create function inoutparam_succeed(out i anyelement, inout r anyrange)
as $function$ select upper($1), $1 $function$
language sql;

select * from inoutparam_succeed(int4range(1, 2));

create function table_succeed(r anyrange)
returns table (
  l anyelement,
  u anyelement
)
as $function$ select lower($1), upper($1) $function$
language sql;

select * from table_succeed(int4range(1, 11));

create function outparam_fail(i anyelement, out r anyrange, out t text)
as $function$ select '[1,10]', 'foo' $function$
language sql;

create function inoutparam_fail(inout i anyelement, out r anyrange)
as $function$ select $1, '[1,10]' $function$
language sql;

create function table_fail(i anyelement)
returns table (
  i anyelement,
  r anyrange
)
as $function$ select $1, '[1,10]' $function$
language sql;

select current_date <@ cast('empty' as daterange);

select current_date <@ daterange(null, null);

select current_date <@ daterange('2000-01-01', null, '[)');

select current_date <@ daterange(null, '2000-01-01', '(]');

select current_date <@ daterange('-Infinity', cast('1997-04-10' as date), '()');

select current_date <@ daterange('-Infinity', cast('1997-04-10' as date), '[)');

select current_date <@ daterange(cast('2002-09-25' as date), 'Infinity', '[)');

select current_date <@ daterange(cast('2002-09-25' as date), 'Infinity', '[]');

select daterange('-Infinity', cast('1997-04-10' as date), '()') @> current_date;

select daterange(cast('2002-09-25' as date), 'Infinity', '[]') @> current_date;

select NOW() <@ tstzrange('2024-01-20 00:00', '2024-01-21 00:00');

select clock_timestamp() <@ tstzrange('2024-01-20 00:00', '2024-01-21 00:00');

select clock_timestamp() <@ tstzrange('2024-01-20 00:00', null);

create type textrange_supp as range (subtype = text, subtype_opclass = text_pattern_ops);

create temporary table text_support_test (t text collate "C");

insert into text_support_test values ('a'), ('c'), ('d'), ('ch');

select * from text_support_test where t <@ textrange_supp('a', 'd');

select * from text_support_test where t <@ textrange_supp('a', 'd');

drop table text_support_test;

drop type textrange_supp;
