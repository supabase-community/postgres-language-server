---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/indexing.sql
snapshot_kind: text
---
create table idxpart (
  a INT,
  b INT,
  c TEXT
)
partition by range(a);

create index "idxpart_idx" on idxpart using btree (a);

select relhassubclass from pg_class where relname = 'idxpart_idx';

select indexdef from pg_indexes where indexname like 'idxpart_idx%';

drop INDEX idxpart_idx;

create table idxpart1 partition of idxpart for values from (0) to (10);

create table idxpart2
partition of idxpart
for values from (10) to (100)
partition by range(b);

create table idxpart21 partition of idxpart2 for values from (0) to (100);

create index "idxpart_idx" on only idxpart using btree (a);

select relhassubclass from pg_class where relname = 'idxpart_idx';

drop INDEX idxpart_idx;

create index on idxpart using btree (a);

select
  relname,
  relkind,
  relhassubclass,
  cast(inhparent as REGCLASS)
from
  pg_class
  left outer join
    pg_index as ix
  on indexrelid = oid
  left outer join
    pg_inherits
  on ix.indexrelid = inhrelid
where
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT,
  c TEXT
)
partition by range(a);

create table idxpart1 partition of idxpart for values from (0) to (10);

create index concurrently on idxpart using btree (a);

drop TABLE idxpart;

create table idxpart (col1 INT)
partition by range(col1);

create index on idxpart using btree (col1);

create table idxpart_two (col2 INT);

select col2 from idxpart_two as fk left outer join idxpart as pk on col1 = col2;

drop TABLE idxpart, idxpart_two;

create table idxpart (
  a INT,
  b TEXT,
  c INT
)
partition by range(a);

create table idxpart1
partition of idxpart
for values from (minvalue) to (maxvalue);

create index "partidx_abc_idx" on idxpart using btree (a, b, c);

insert into idxpart (a, b, c) select i, i, i from generate_series(1, 50) as i;

alter table idxpart
  alter column c type NUMERIC;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT,
  c TEXT
)
partition by range(a);

create index "idxparti" on idxpart using btree (a);

create index "idxparti2" on idxpart using btree (b, c);

create table idxpart1 (like idxpart);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (10);

create index "idxpart_c" on only idxpart using btree (c);

create index "idxpart1_c" on idxpart1 using btree (c);

alter table idxpart_c
  ATTACH partition
  idxpart1_c for values from (10) to (20);

alter index idxpart_c
  ATTACH partition
  idxpart1_c;

select
  relname,
  relpartbound
from
  pg_class
where
  relname in ('idxpart_c', 'idxpart1_c')
order by relname;

alter table idxpart_c
  DETACH partition
  idxpart1_c;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT
)
partition by range(a, b);

create table idxpart1 partition of idxpart for values from (0, 0) to (10, 10);

create index on idxpart1 using btree (a, b);

create index on idxpart using btree (a, b);

select
  relname,
  relkind,
  relhassubclass,
  cast(inhparent as REGCLASS)
from
  pg_class
  left outer join
    pg_index as ix
  on indexrelid = oid
  left outer join
    pg_inherits
  on ix.indexrelid = inhrelid
where
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart;

create table idxpart (a INT)
partition by range(a);

create index on idxpart using btree (a);

create table idxpart1 partition of idxpart for values from (0) to (10);

drop INDEX idxpart1_a_idx;

drop INDEX concurrently idxpart_a_idx;

drop INDEX idxpart_a_idx;

select
  relname,
  relkind
from
  pg_class
where
  relname like 'idxpart%'
order by relname;

create index on idxpart using btree (a);

drop TABLE idxpart1;

select
  relname,
  relkind
from
  pg_class
where
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart;

create temporary table idxpart_temp (a INT)
partition by range(a);

create index on idxpart_temp using btree (a);

create temporary table idxpart1_temp
partition of idxpart_temp
for values from (0) to (10);

drop INDEX idxpart1_temp_a_idx;

drop INDEX concurrently idxpart_temp_a_idx;

select
  relname,
  relkind
from
  pg_class
where
  relname like 'idxpart_temp%'
order by relname;

drop TABLE idxpart_temp;

create table idxpart (
  a INT,
  b INT
)
partition by range(a, b);

create table idxpart1 partition of idxpart for values from (0, 0) to (10, 10);

create index "idxpart_a_b_idx" on only idxpart using btree (a, b);

create index "idxpart1_a_b_idx" on idxpart1 using btree (a, b);

create index "idxpart1_tst1" on idxpart1 using btree (b, a);

create index "idxpart1_tst2" on idxpart1 using hash (a);

create index "idxpart1_tst3"
on idxpart1
using btree
(
  a,
  b
)
where
  a > 10;

alter index idxpart
  ATTACH partition
  idxpart1;

alter index idxpart_a_b_idx
  ATTACH partition
  idxpart1;

alter index idxpart_a_b_idx
  ATTACH partition
  idxpart_a_b_idx;

alter index idxpart_a_b_idx
  ATTACH partition
  idxpart1_b_idx;

alter index idxpart_a_b_idx
  ATTACH partition
  idxpart1_tst1;

alter index idxpart_a_b_idx
  ATTACH partition
  idxpart1_tst2;

alter index idxpart_a_b_idx
  ATTACH partition
  idxpart1_tst3;

alter index idxpart_a_b_idx
  ATTACH partition
  idxpart1_a_b_idx;

alter index idxpart_a_b_idx
  ATTACH partition
  idxpart1_a_b_idx;

create index "idxpart1_2_a_b" on idxpart1 using btree (a, b);

alter index idxpart_a_b_idx
  ATTACH partition
  idxpart1_2_a_b;

drop TABLE idxpart;

select
  cast(indexrelid as REGCLASS),
  cast(indrelid as REGCLASS)
from
  pg_index
where
  cast(cast(indexrelid as REGCLASS)
  as TEXT) like 'idxpart%';

create table idxpart (
  a INT,
  b INT
)
partition by range(a);

create table idxpart1 (
  a INT,
  b INT
);

create index on idxpart1 using hash (a);

create index
on idxpart1
using btree
(
  a
)
where
  b > 1;

create index on idxpart1 using btree ((a + 0));

create index on idxpart1 using btree (a, a);

create index on idxpart using btree (a);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (1000);

drop TABLE idxpart;

create table idxpart (a INT)
partition by range(a);

create table idxpart1 partition of idxpart for values from (0) to (100);

create table idxpart2
partition of idxpart
for values from (100) to (1000)
partition by range(a);

create table idxpart21 partition of idxpart2 for values from (100) to (200);

create table idxpart22 partition of idxpart2 for values from (200) to (300);

create index on idxpart22 using btree (a);

create index on only idxpart2 using btree (a);

create index on idxpart using btree (a);

select
  cast(indexrelid as REGCLASS),
  cast(indrelid as REGCLASS),
  cast(inhparent as REGCLASS)
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
where
  cast(cast(indexrelid as REGCLASS)
  as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

alter index idxpart2_a_idx
  ATTACH partition
  idxpart22_a_idx;

select
  cast(indexrelid as REGCLASS),
  cast(indrelid as REGCLASS),
  cast(inhparent as REGCLASS)
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
where
  cast(cast(indexrelid as REGCLASS)
  as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

alter index idxpart2_a_idx
  ATTACH partition
  idxpart22_a_idx;

create index on idxpart21 using btree (a);

alter index idxpart2_a_idx
  ATTACH partition
  idxpart21_a_idx;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT,
  c TEXT,
  d BOOLEAN
)
partition by range(a);

create index "idxparti" on idxpart using btree (a);

create index "idxparti2" on idxpart using btree (b, c);

create table idxpart1 (like idxpart including INDEXES);

select
  relname,
  relkind,
  cast(inhparent as REGCLASS)
from
  pg_class
  left outer join
    pg_index as ix
  on indexrelid = oid
  left outer join
    pg_inherits
  on ix.indexrelid = inhrelid
where
  relname like 'idxpart%'
order by relname;

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (10);

select
  relname,
  relkind,
  cast(inhparent as REGCLASS)
from
  pg_class
  left outer join
    pg_index as ix
  on indexrelid = oid
  left outer join
    pg_inherits
  on ix.indexrelid = inhrelid
where
  relname like 'idxpart%'
order by relname;

create index
on idxpart1
using btree
(
  (a + b)
)
where
  d = true;

select
  relname,
  relkind,
  cast(inhparent as REGCLASS)
from
  pg_class
  left outer join
    pg_index as ix
  on indexrelid = oid
  left outer join
    pg_inherits
  on ix.indexrelid = inhrelid
where
  relname like 'idxpart%'
order by relname;

create index "idxparti3"
on idxpart
using btree
(
  (a + b)
)
where
  d = true;

select
  relname,
  relkind,
  cast(inhparent as REGCLASS)
from
  pg_class
  left outer join
    pg_index as ix
  on indexrelid = oid
  left outer join
    pg_inherits
  on ix.indexrelid = inhrelid
where
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT
)
partition by range(a);

create table idxpart1
partition of idxpart
for values from (1) to (1000)
partition by range(a);

create table idxpart11 partition of idxpart1 for values from (1) to (100);

create index on only idxpart1 using btree (a);

create index on only idxpart using btree (a);

select
  relname,
  indisvalid
from
  pg_class
  inner join
    pg_index
  on indexrelid = oid
where
  relname like 'idxpart%'
order by relname;

alter index idxpart_a_idx
  ATTACH partition
  idxpart1_a_idx;

select
  relname,
  indisvalid
from
  pg_class
  inner join
    pg_index
  on indexrelid = oid
where
  relname like 'idxpart%'
order by relname;

create index on idxpart11 using btree (a);

alter index idxpart1_a_idx
  ATTACH partition
  idxpart11_a_idx;

select
  relname,
  indisvalid
from
  pg_class
  inner join
    pg_index
  on indexrelid = oid
where
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart;

create table idxpart (a INT)
partition by range(a);

create table idxpart1 (like idxpart);

create index on idxpart1 using btree (a);

create index on idxpart using btree (a);

create table idxpart2 (like idxpart);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (1000);

alter table idxpart
  ATTACH partition
  idxpart2
  for values from (1000) to (2000);

create table idxpart3 partition of idxpart for values from (2000) to (3000);

select
  relname,
  relkind
from
  pg_class
where
  relname like 'idxpart%'
order by relname;

alter table idxpart
  DETACH partition
  idxpart1;

alter table idxpart
  DETACH partition
  idxpart2;

alter table idxpart
  DETACH partition
  idxpart3;

drop INDEX idxpart1_a_idx;

drop INDEX idxpart2_a_idx;

drop INDEX idxpart3_a_idx;

select
  relname,
  relkind
from
  pg_class
where
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart, idxpart1, idxpart2, idxpart3;

select
  relname,
  relkind
from
  pg_class
where
  relname like 'idxpart%'
order by relname;

create table idxpart (a INT)
partition by range(a);

create table idxpart1 (like idxpart);

create index on idxpart1 using btree (a);

create index on idxpart using btree (a);

create table idxpart2 (like idxpart);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (1000);

alter table idxpart
  ATTACH partition
  idxpart2
  for values from (1000) to (2000);

create table idxpart3 partition of idxpart for values from (2000) to (3000);

select
  relname,
  relkind
from
  pg_class
where
  relname like 'idxpart%'
order by relname;

alter table idxpart
  DETACH partition
  idxpart1;

alter table idxpart
  DETACH partition
  idxpart2;

alter table idxpart
  DETACH partition
  idxpart3;

drop INDEX idxpart_a_idx;

select
  relname,
  relkind
from
  pg_class
where
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart, idxpart1, idxpart2, idxpart3;

select
  relname,
  relkind
from
  pg_class
where
  relname like 'idxpart%'
order by relname;

create table idxpart (
  a INT,
  b INT,
  c INT
)
partition by range(a);

create index on idxpart using btree (c);

create table idxpart1 partition of idxpart for values from (0) to (250);

create table idxpart2 partition of idxpart for values from (250) to (500);

alter table idxpart
  DETACH partition
  idxpart2;

alter table idxpart2
  drop column c;

drop TABLE idxpart, idxpart2;

create table idxpart (
  a INT,
  b INT
)
partition by range(a);

create table idxpart1 (like idxpart);

create index on idxpart1 using btree ((a + b));

create index on idxpart using btree ((a + b));

create table idxpart2 (like idxpart);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (1000);

alter table idxpart
  ATTACH partition
  idxpart2
  for values from (1000) to (2000);

create table idxpart3 partition of idxpart for values from (2000) to (3000);

select
  relname as child,
  cast(inhparent as REGCLASS) as parent,
  pg_get_indexdef as childdef
from
  pg_class
  inner join
    pg_inherits
  on inhrelid = oid,
  lateral pg_get_indexdef(pg_class.oid)
where
  relkind in ('i', 'I') and
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart;

create table idxpart (a TEXT)
partition by range(a);

create table idxpart1 (like idxpart);

create table idxpart2 (like idxpart);

create index on idxpart2 using btree (a collate "POSIX");

create index on idxpart2 using btree (a);

create index on idxpart2 using btree (a collate "C");

alter table idxpart
  ATTACH partition
  idxpart1
  for values from ('aaa') to ('bbb');

alter table idxpart
  ATTACH partition
  idxpart2
  for values from ('bbb') to ('ccc');

create table idxpart3 partition of idxpart for values from ('ccc') to ('ddd');

create index on idxpart using btree (a collate "C");

create table idxpart4 partition of idxpart for values from ('ddd') to ('eee');

select
  relname as child,
  cast(inhparent as REGCLASS) as parent,
  pg_get_indexdef as childdef
from
  pg_class
  left outer join
    pg_inherits
  on inhrelid = oid,
  lateral pg_get_indexdef(pg_class.oid)
where
  relkind in ('i', 'I') and
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart;

create table idxpart (a TEXT)
partition by range(a);

create table idxpart1 (like idxpart);

create table idxpart2 (like idxpart);

create index on idxpart2 using btree (a);

alter table idxpart
  ATTACH partition
  idxpart1
  for values from ('aaa') to ('bbb');

alter table idxpart
  ATTACH partition
  idxpart2
  for values from ('bbb') to ('ccc');

create table idxpart3 partition of idxpart for values from ('ccc') to ('ddd');

create index on idxpart using btree (a text_pattern_ops);

create table idxpart4 partition of idxpart for values from ('ddd') to ('eee');

select
  relname as child,
  cast(inhparent as REGCLASS) as parent,
  pg_get_indexdef as childdef
from
  pg_class
  left outer join
    pg_inherits
  on inhrelid = oid,
  lateral pg_get_indexdef(pg_class.oid)
where
  relkind in ('i', 'I') and
  relname like 'idxpart%'
order by relname;

drop INDEX idxpart_a_idx;

create index on only idxpart using btree (a text_pattern_ops);

alter index idxpart_a_idx
  ATTACH partition
  idxpart2_a_idx;

drop TABLE idxpart;

create table idxpart (
  col1 INT,
  a INT,
  col2 INT,
  b INT
)
partition by range(a);

create table idxpart1 (
  b INT,
  col1 INT,
  col2 INT,
  col3 INT,
  a INT
);

alter table idxpart
  drop column col1,
  drop column col2;

alter table idxpart1
  drop column col1,
  drop column col2,
  drop column col3;

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (1000);

create index "idxpart_1_idx" on only idxpart using btree (b, a);

create index "idxpart1_1_idx" on idxpart1 using btree (b, a);

create index "idxpart1_1b_idx" on idxpart1 using btree (b);

create index "idxpart_2_idx"
on only idxpart
using btree
(
  (b + a)
)
where
  a > 1;

create index "idxpart1_2_idx"
on idxpart1
using btree
(
  (b + a)
)
where
  a > 1;

create index "idxpart1_2b_idx"
on idxpart1
using btree
(
  (a + b)
)
where
  a > 1;

create index "idxpart1_2c_idx"
on idxpart1
using btree
(
  (b + a)
)
where
  b > 1;

alter index idxpart_1_idx
  ATTACH partition
  idxpart1_1b_idx;

alter index idxpart_1_idx
  ATTACH partition
  idxpart1_1_idx;

alter index idxpart_2_idx
  ATTACH partition
  idxpart1_2b_idx;

alter index idxpart_2_idx
  ATTACH partition
  idxpart1_2c_idx;

alter index idxpart_2_idx
  ATTACH partition
  idxpart1_2_idx;

select
  relname as child,
  cast(inhparent as REGCLASS) as parent,
  pg_get_indexdef as childdef
from
  pg_class
  left outer join
    pg_inherits
  on inhrelid = oid,
  lateral pg_get_indexdef(pg_class.oid)
where
  relkind in ('i', 'I') and
  relname like 'idxpart%'
order by relname;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT,
  c TEXT
)
partition by range(a);

create index "idxparti" on idxpart using btree (a);

create index "idxparti2" on idxpart using btree (c, b);

create table idxpart1 (
  c TEXT,
  a INT,
  b INT
);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (10);

create table idxpart2 (
  c TEXT,
  a INT,
  b INT
);

create index on idxpart2 using btree (a);

create index on idxpart2 using btree (c, b);

alter table idxpart
  ATTACH partition
  idxpart2 for values from (10) to (20);

select
  c.relname,
  pg_get_indexdef(indexrelid)
from
  pg_class as c
  inner join
    pg_index as i
  on c.oid = i.indexrelid
where
  cast(cast(indrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop TABLE idxpart;

create table idxpart (
  col1 INT,
  col2 INT,
  a INT,
  b INT
)
partition by range(a);

create table idxpart1 (
  col2 INT,
  b INT,
  col1 INT,
  a INT
);

create table idxpart2 (
  col1 INT,
  col2 INT,
  b INT,
  a INT
);

alter table idxpart
  drop column col1,
  drop column col2;

alter table idxpart1
  drop column col1,
  drop column col2;

alter table idxpart2
  drop column col1,
  drop column col2;

create index on idxpart2 using btree ((abs(b)));

alter table idxpart
  ATTACH partition
  idxpart2 for values from (0) to (1);

create index on idxpart using btree ((abs(b)));

create index on idxpart using btree ((b + 1));

alter table idxpart
  ATTACH partition
  idxpart1 for values from (1) to (2);

select
  c.relname,
  pg_get_indexdef(indexrelid)
from
  pg_class as c
  inner join
    pg_index as i
  on c.oid = i.indexrelid
where
  cast(cast(indrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop TABLE idxpart;

create table idxpart (
  col1 INT,
  a INT,
  col3 INT,
  b INT
)
partition by range(a);

alter table idxpart
  drop column col1,
  drop column col3;

create table idxpart1 (
  col1 INT,
  col2 INT,
  col3 INT,
  col4 INT,
  b INT,
  a INT
);

alter table idxpart1
  drop column col1,
  drop column col2,
  drop column col3,
  drop column col4;

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (1000);

create table idxpart2 (
  col1 INT,
  col2 INT,
  b INT,
  a INT
);

create index
on idxpart2
using btree
(
  a
)
where
  b > 1000;

alter table idxpart2
  drop column col1,
  drop column col2;

alter table idxpart
  ATTACH partition
  idxpart2
  for values from (1000) to (2000);

create index
on idxpart
using btree
(
  a
)
where
  b > 1000;

select
  c.relname,
  pg_get_indexdef(indexrelid)
from
  pg_class as c
  inner join
    pg_index as i
  on c.oid = i.indexrelid
where
  cast(cast(indrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop TABLE idxpart;

create table idxpart1 (
  drop_1 INT,
  drop_2 INT,
  col_keep INT,
  drop_3 INT
);

alter table idxpart1
  drop column drop_1;

alter table idxpart1
  drop column drop_2;

alter table idxpart1
  drop column drop_3;

create index on idxpart1 using btree (col_keep);

create table idxpart (col_keep INT)
partition by range(col_keep);

create index on idxpart using btree (col_keep);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (1000);

select
  cast(attrelid as REGCLASS),
  attname,
  attnum
from
  pg_attribute
where
  cast(cast(attrelid as REGCLASS) as TEXT) like 'idxpart%' and
  attnum > 0
order by cast(attrelid as REGCLASS),
  attnum;

drop TABLE idxpart;

create table idxpart (
  drop_1 INT,
  drop_2 INT,
  col_keep INT,
  drop_3 INT
)
partition by range(col_keep);

alter table idxpart
  drop column drop_1;

alter table idxpart
  drop column drop_2;

alter table idxpart
  drop column drop_3;

create table idxpart1 (col_keep INT);

create index on idxpart1 using btree (col_keep);

create index on idxpart using btree (col_keep);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (1000);

select
  cast(attrelid as REGCLASS),
  attname,
  attnum
from
  pg_attribute
where
  cast(cast(attrelid as REGCLASS) as TEXT) like 'idxpart%' and
  attnum > 0
order by cast(attrelid as REGCLASS),
  attnum;

drop TABLE idxpart;

create table idxpart (
  a INT primary key,
  b INT
)
partition by range(a);

create table failpart
partition of idxpart
(
  b primary key
)
for values from (0) to (100);

drop TABLE idxpart;

create table idxpart (a INT)
partition by range(a);

create table idxpart1pk
partition of idxpart
(
  a primary key
)
for values from (0) to (100);

drop TABLE idxpart;

create table idxpart (
  a INT unique,
  b INT
)
partition by range(a, b);

create table idxpart (
  a INT,
  b INT unique
)
partition by range(a, b);

create table idxpart (
  a INT primary key,
  b INT
)
partition by range(b, a);

create table idxpart (
  a INT,
  b INT primary key
)
partition by range(b, a);

create table idxpart (
  a INT,
  b INT,
  c TEXT,
  primary key (a, b, c)
)
partition by range(b, c, a);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  exclude using gist (a with =)
)
partition by range(a);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE,
  exclude using gist (a with =, b with =)
)
partition by range(a, b);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE,
  exclude using gist (a with =, b with =)
)
partition by range(a);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE,
  exclude using gist (a with =)
)
partition by range(a, b);

create table idxpart (
  a INT4RANGE,
  exclude using gist (a with -|-)
)
partition by range(a);

create table idxpart (
  a INT4RANGE,
  b INT4RANGE,
  exclude using gist (a with =, b with &&)
)
partition by range(a);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE,
  c INT4RANGE,
  exclude using gist (b with =, c with &&)
)
partition by range(a);

create table idxpart (
  a INT4RANGE,
  b INT4RANGE,
  c INT4RANGE,
  exclude using gist (a with =,
  b with =,
  c with &&)
)
partition by range(a, b);

drop TABLE idxpart;

create table idxpart (
  a INT primary key,
  b INT
)
partition by range((b + a));

create table idxpart (
  a INT unique,
  b INT
)
partition by range((b + a));

create table idxpart (
  a INT,
  b INT,
  c TEXT
)
partition by range(a, b);

alter table idxpart
  add primary key (a);

alter table idxpart
  add primary key (a, b);

create table idxpart1
partition of idxpart
for values from (0, 0) to (1000, 1000);

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT
)
partition by range(a, b);

alter table idxpart
  add unique (a);

alter table idxpart
  add unique (b, a);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE
)
partition by range(a);

alter table idxpart
  add exclude using gist (a with =);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE
)
partition by range(a, b);

alter table idxpart
  add exclude using gist (a with =, b with =);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE
)
partition by range(a);

alter table idxpart
  add exclude using gist (a with =, b with =);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE
)
partition by range(a, b);

alter table idxpart
  add exclude using gist (a with =);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE
)
partition by range(a, b);

alter table idxpart
  add exclude using gist (a with -|-);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE
)
partition by range(a);

alter table idxpart
  add exclude using gist (a with =, b with &&);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE,
  c INT4RANGE
)
partition by range(a);

alter table idxpart
  add exclude using gist (b with =, c with &&);

drop TABLE idxpart;

create table idxpart (
  a INT4RANGE,
  b INT4RANGE,
  c INT4RANGE
)
partition by range(a, b);

alter table idxpart
  add exclude using gist (a with =,
  b with =,
  c with &&);

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT,
  primary key (a, b)
)
partition by range(a, b);

create table idxpart1 partition of idxpart for values from (1, 1) to (10, 10);

create table idxpart2
partition of idxpart
for values from (10, 10) to (20, 20)
partition by range(b);

create table idxpart21 partition of idxpart2 for values from (10) to (15);

create table idxpart22 partition of idxpart2 for values from (15) to (20);

create table idxpart3 (
  b INT not null,
  a INT not null
);

alter table idxpart
  ATTACH partition
  idxpart3
  for values from (20, 20) to (30, 30);

select
  conname,
  contype,
  cast(conrelid as REGCLASS),
  cast(conindid as REGCLASS),
  conkey
from
  pg_constraint
where
  cast(cast(conrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(conrelid as REGCLASS) as TEXT),
  conname;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT,
  primary key (a)
)
partition by range(a);

create table idxpart2
partition of idxpart
for values from (0) to (1000)
partition by range(b);

drop TABLE idxpart;

create table idxpart (
  a INT unique,
  b INT
)
partition by range(a);

create table idxpart1 (
  a INT not null,
  b INT,
  unique (a, b)
)
partition by range(a, b);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (1) to (1000);

drop TABLE idxpart, idxpart1;

create table idxpart (
  a INT,
  b INT,
  primary key (a, b)
)
partition by range(a);

create table idxpart2
partition of idxpart
for values from (0) to (1000)
partition by range(b);

create table idxpart21 partition of idxpart2 for values from (0) to (1000);

select
  conname,
  contype,
  cast(conrelid as REGCLASS),
  cast(conindid as REGCLASS),
  conkey
from
  pg_constraint
where
  cast(cast(conrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(conrelid as REGCLASS) as TEXT),
  conname;

drop TABLE idxpart;

create table idxpart (i INT)
partition by HASH(i);

create table idxpart0
partition of idxpart
(
  i
)
for values with (MODULUS 2, REMAINDER 0);

create table idxpart1
partition of idxpart
(
  i
)
for values with (MODULUS 2, REMAINDER 1);

alter table idxpart0
  add primary key (i);

alter table idxpart
  add primary key (i);

select
  cast(indrelid as REGCLASS),
  cast(indexrelid as REGCLASS),
  cast(inhparent as REGCLASS),
  indisvalid,
  conname,
  conislocal,
  coninhcount,
  connoinherit,
  convalidated
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
  left outer join
    pg_constraint as con
  on idx.indexrelid = con.conindid
where
  cast(cast(indrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop INDEX idxpart0_pkey;

drop INDEX idxpart1_pkey;

alter table idxpart0
  drop constraint idxpart0_pkey;

alter table idxpart1
  drop constraint idxpart1_pkey;

alter table idxpart
  drop constraint idxpart_pkey;

select
  cast(indrelid as REGCLASS),
  cast(indexrelid as REGCLASS),
  cast(inhparent as REGCLASS),
  indisvalid,
  conname,
  conislocal,
  coninhcount,
  connoinherit,
  convalidated
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
  left outer join
    pg_constraint as con
  on idx.indexrelid = con.conindid
where
  cast(cast(indrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop TABLE idxpart;

create table idxpart (
  c1 INT primary key,
  c2 INT,
  c3 VARCHAR(10)
)
partition by range(c1);

create table idxpart1 (like idxpart);

alter table idxpart1
  add primary key (c1, c2);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (100) to (200);

drop TABLE idxpart, idxpart1;

create table idxpart (
  a INT,
  b INT,
  primary key (a)
)
partition by range(a);

create table idxpart1 (
  a INT not null,
  b INT
)
partition by range(a);

create table idxpart11 (
  a INT not null,
  b INT primary key
);

alter table idxpart1
  ATTACH partition
  idxpart11 for values from (0) to (1000);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (0) to (10000);

drop TABLE idxpart, idxpart1, idxpart11;

create table idxpart (a INT)
partition by range(a);

create table idxpart0 (like idxpart);

alter table idxpart0
  add primary key (a);

alter table idxpart
  ATTACH partition
  idxpart0 for values from (0) to (1000);

alter table only idxpart
  add primary key (a);

select
  cast(indrelid as REGCLASS),
  cast(indexrelid as REGCLASS),
  cast(inhparent as REGCLASS),
  indisvalid,
  conname,
  conislocal,
  coninhcount,
  connoinherit,
  convalidated
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
  left outer join
    pg_constraint as con
  on idx.indexrelid = con.conindid
where
  cast(cast(indrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

alter index idxpart_pkey
  ATTACH partition
  idxpart0_pkey;

select
  cast(indrelid as REGCLASS),
  cast(indexrelid as REGCLASS),
  cast(inhparent as REGCLASS),
  indisvalid,
  conname,
  conislocal,
  coninhcount,
  connoinherit,
  convalidated
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
  left outer join
    pg_constraint as con
  on idx.indexrelid = con.conindid
where
  cast(cast(indrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop TABLE idxpart;

create table idxpart (a INT)
partition by range(a);

create table idxpart0 (like idxpart);

alter table idxpart0
  add unique (a);

alter table idxpart
  ATTACH partition
  idxpart0 default;

alter table only idxpart
  add primary key (a);

alter table idxpart0
  alter column a set not null;

alter table only idxpart
  add primary key (a);

alter index idxpart_pkey
  ATTACH partition
  idxpart0_a_key;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT
)
partition by range(a);

create table idxpart1 (
  a INT not null,
  b INT
);

create unique index on idxpart1 using btree (a);

alter table idxpart
  add primary key (a);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (1) to (1000);

select
  cast(indrelid as REGCLASS),
  cast(indexrelid as REGCLASS),
  cast(inhparent as REGCLASS),
  indisvalid,
  conname,
  conislocal,
  coninhcount,
  connoinherit,
  convalidated
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
  left outer join
    pg_constraint as con
  on idx.indexrelid = con.conindid
where
  cast(cast(indrelid as REGCLASS) as TEXT) like 'idxpart%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop TABLE idxpart;

create table idxpart (
  a INT,
  b INT
)
partition by range(a);

create table idxpart1 (
  a INT not null,
  b INT
);

create unique index on idxpart1 using btree (a);

alter table idxpart
  ATTACH partition
  idxpart1 for values from (1) to (1000);

alter table only idxpart
  add primary key (a);

alter index idxpart_pkey
  ATTACH partition
  idxpart1_a_idx;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b TEXT,
  primary key (a, b)
)
partition by range(a);

create table idxpart1 partition of idxpart for values from (0) to (100000);

create table idxpart2 (
  c INT,
  like idxpart
);

insert into idxpart2 (c, a, b) values (42, 572814, 'inserted first');

alter table idxpart2
  drop column c;

create unique index on idxpart using btree (a);

alter table idxpart
  ATTACH partition
  idxpart2
  for values from (100000) to (1000000);

insert into idxpart values (0, 'zero'), (42, 'life'), (2 ^ 16, 'sixteen');

insert into idxpart
select
  2 ^ g,
  format('two to power of %s', g)
from
  generate_series(15, 17) as g;

insert into idxpart values (16, 'sixteen');

insert into idxpart (b, a) values ('one', 142857), ('two', 285714);

insert into idxpart
select
  a * 2,
  b || b
from
  idxpart
where
  a between 2 ^ 16 and 2 ^ 19;

insert into idxpart values (572814, 'five');

insert into idxpart values (857142, 'six');

select cast(tableoid as REGCLASS), * from idxpart order by a;

drop TABLE idxpart;

create table idxpart (
  a INT,
  b TEXT,
  c INT[]
)
partition by range(a);

create table idxpart1 partition of idxpart for values from (0) to (100000);

set enable_seqscan = off;

create index "idxpart_brin" on idxpart using brin (b);

select * from idxpart where b = 'abcd';

drop INDEX idxpart_brin;

create index "idxpart_spgist" on idxpart using spgist (b);

select * from idxpart where b = 'abcd';

drop INDEX idxpart_spgist;

create index "idxpart_gin" on idxpart using gin (c);

select * from idxpart where c @> array[42];

drop INDEX idxpart_gin;

reset enable_seqscan;

drop TABLE idxpart;

create table idxpart (a INT)
partition by range(a);

create table idxpart1 partition of idxpart for values from (0) to (100);

create table idxpart2
partition of idxpart
for values from (100) to (1000)
partition by range(a);

create table idxpart21 partition of idxpart2 for values from (100) to (200);

create table idxpart22 partition of idxpart2 for values from (200) to (300);

create index on idxpart22 using btree (a);

create index on only idxpart2 using btree (a);

alter index idxpart2_a_idx
  ATTACH partition
  idxpart22_a_idx;

create index on idxpart using btree (a);

create table idxpart_another (
  a INT,
  b INT,
  primary key (a, b)
)
partition by range(a);

create table idxpart_another_1
partition of idxpart_another
for values from (0) to (100);

create table idxpart3 (
  c INT,
  b INT,
  a INT
)
partition by range(a);

alter table idxpart3
  drop column b,
  drop column c;

create table idxpart31 partition of idxpart3 for values from (1000) to (1200);

create table idxpart32 partition of idxpart3 for values from (1200) to (1400);

alter table idxpart
  ATTACH partition
  idxpart3
  for values from (1000) to (2000);

create schema "regress_indexing";

set search_path to regress_indexing;

create table pk (a INT primary key)
partition by range(a);

create table pk1 partition of pk for values from (0) to (1000);

create table pk2 (
  b INT,
  a INT
);

alter table pk2
  drop column b;

alter table pk2
  alter column a set not null;

alter table pk
  ATTACH partition
  pk2 for values from (1000) to (2000);

create table pk3 partition of pk for values from (2000) to (3000);

create table pk4 (like pk);

alter table pk
  ATTACH partition
  pk4 for values from (3000) to (4000);

create table pk5 (like pk)
partition by range(a);

create table pk51 partition of pk5 for values from (4000) to (4500);

create table pk52 partition of pk5 for values from (4500) to (5000);

alter table pk
  ATTACH partition
  pk5 for values from (4000) to (5000);

reset search_path;

create table covidxpart (
  a INT,
  b INT
)
partition by LIST(a);

create unique index on covidxpart using btree (a) include (b);

create table covidxpart1 partition of covidxpart for values in (1);

create table covidxpart2 partition of covidxpart for values in (2);

insert into covidxpart values (1, 1);

insert into covidxpart values (1, 1);

create table covidxpart3 (
  b INT,
  c INT,
  a INT
);

alter table covidxpart3
  drop column c;

alter table covidxpart
  ATTACH partition
  covidxpart3 for values in (3);

insert into covidxpart values (3, 1);

insert into covidxpart values (3, 1);

create table covidxpart4 (
  b INT,
  a INT
);

create unique index on covidxpart4 using btree (a) include (b);

create unique index on covidxpart4 using btree (a);

alter table covidxpart
  ATTACH partition
  covidxpart4 for values in (4);

insert into covidxpart values (4, 1);

insert into covidxpart values (4, 1);

create unique index on covidxpart using btree (b) include (a);

create table parted_pk_detach_test (a INT primary key)
partition by LIST(a);

create table parted_pk_detach_test1
partition of parted_pk_detach_test
for values in (1);

alter table parted_pk_detach_test1
  drop constraint parted_pk_detach_test1_pkey;

alter table parted_pk_detach_test
  DETACH partition
  parted_pk_detach_test1;

alter table parted_pk_detach_test1
  drop constraint parted_pk_detach_test1_pkey;

drop TABLE parted_pk_detach_test, parted_pk_detach_test1;

create table parted_uniq_detach_test (a INT unique)
partition by LIST(a);

create table parted_uniq_detach_test1
partition of parted_uniq_detach_test
for values in (1);

alter table parted_uniq_detach_test1
  drop constraint parted_uniq_detach_test1_a_key;

alter table parted_uniq_detach_test
  DETACH partition
  parted_uniq_detach_test1;

alter table parted_uniq_detach_test1
  drop constraint parted_uniq_detach_test1_a_key;

drop TABLE parted_uniq_detach_test, parted_uniq_detach_test1;

create table parted_index_col_drop (
  a INT,
  b INT,
  c INT
)
partition by LIST(a);

create table parted_index_col_drop1
partition of parted_index_col_drop
for values in (1)
partition by LIST(a);

create table parted_index_col_drop2
partition of parted_index_col_drop
for values in (2)
partition by LIST(a);

create table parted_index_col_drop11
partition of parted_index_col_drop1
for values in (1);

create index on parted_index_col_drop using btree (b);

create index on parted_index_col_drop using btree (c);

create index on parted_index_col_drop using btree (b, c);

alter table parted_index_col_drop
  drop column c;

drop TABLE parted_index_col_drop;

create table parted_inval_tab (a INT)
partition by range(a);

create index "parted_inval_idx" on parted_inval_tab using btree (a);

create table parted_inval_tab_1 (a INT)
partition by range(a);

create table parted_inval_tab_1_1
partition of parted_inval_tab_1
for values from (0) to (10);

create table parted_inval_tab_1_2
partition of parted_inval_tab_1
for values from (10) to (20);

create index "parted_inval_ixd_1" on only parted_inval_tab_1 using btree (a);

alter table parted_inval_tab
  ATTACH partition
  parted_inval_tab_1
  for values from (1) to (100);

select
  cast(indexrelid as REGCLASS),
  indisvalid,
  cast(indrelid as REGCLASS),
  cast(inhparent as REGCLASS)
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
where
  cast(cast(indexrelid as REGCLASS)
  as TEXT) like 'parted_inval%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop TABLE parted_inval_tab;

create table parted_isvalid_tab (
  a INT,
  b INT
)
partition by range(a);

create table parted_isvalid_tab_1
partition of parted_isvalid_tab
for values from (1) to (10)
partition by range(a);

create table parted_isvalid_tab_2
partition of parted_isvalid_tab
for values from (10) to (20)
partition by range(a);

create table parted_isvalid_tab_11
partition of parted_isvalid_tab_1
for values from (1) to (5);

create table parted_isvalid_tab_12
partition of parted_isvalid_tab_1
for values from (5) to (10);

insert into parted_isvalid_tab_11 values (1, 0);

create index
concurrently "parted_isvalid_idx_11"
on parted_isvalid_tab_11
using btree
(
  (a / b)
);

create index "parted_isvalid_idx" on parted_isvalid_tab using btree ((a / b));

select
  cast(indexrelid as REGCLASS),
  indisvalid,
  cast(indrelid as REGCLASS),
  cast(inhparent as REGCLASS)
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
where
  cast(cast(indexrelid as REGCLASS)
  as TEXT) like 'parted_isvalid%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop TABLE parted_isvalid_tab;

begin;

create table parted_replica_tab (id INT not null)
partition by range(id);

create table parted_replica_tab_1
partition of parted_replica_tab
for values from (1) to (10)
partition by range(id);

create table parted_replica_tab_11
partition of parted_replica_tab_1
for values from (1) to (5);

create unique index "parted_replica_idx"
on only parted_replica_tab
using btree
(
  id
);

create unique
index "parted_replica_idx_1"
on only parted_replica_tab_1
using btree
(
  id
);

alter table only parted_replica_tab_1
  REPLICA IDENTITY
  using index
  parted_replica_idx_1;

create unique
index "parted_replica_idx_11"
on parted_replica_tab_11
using btree
(
  id
);

select
  cast(indexrelid as REGCLASS),
  indisvalid,
  indisreplident,
  cast(indrelid as REGCLASS),
  cast(inhparent as REGCLASS)
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
where
  cast(cast(indexrelid as REGCLASS)
  as TEXT) like 'parted_replica%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

alter index parted_replica_idx
  ATTACH partition
  parted_replica_idx_1;

select
  cast(indexrelid as REGCLASS),
  indisvalid,
  indisreplident,
  cast(indrelid as REGCLASS),
  cast(inhparent as REGCLASS)
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
where
  cast(cast(indexrelid as REGCLASS)
  as TEXT) like 'parted_replica%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

alter index parted_replica_idx_1
  ATTACH partition
  parted_replica_idx_11;

alter table only parted_replica_tab_1
  REPLICA IDENTITY
  using index
  parted_replica_idx_1;

commit;

select
  cast(indexrelid as REGCLASS),
  indisvalid,
  indisreplident,
  cast(indrelid as REGCLASS),
  cast(inhparent as REGCLASS)
from
  pg_index as idx
  left outer join
    pg_inherits as inh
  on idx.indexrelid = inh.inhrelid
where
  cast(cast(indexrelid as REGCLASS)
  as TEXT) like 'parted_replica%'
order by cast(cast(indexrelid as REGCLASS)
  as TEXT) collate "C";

drop TABLE parted_replica_tab;

create table test_pg_index_toast_table (a INT);

create or replace function test_pg_index_toast_func(a INT, b INT[])
returns BOOLEAN
as $function$ select true $function$
language sql
immutable;

select array_agg(n) as b from generate_series(1, 10000) as n;

create index
concurrently "test_pg_index_toast_index"
on test_pg_index_toast_table
using btree
(
  (test_pg_index_toast_func(a, 'b'))
);

reindex (CONCURRENTLY) index test_pg_index_toast_index;

drop INDEX concurrently test_pg_index_toast_index;

create index "test_pg_index_toast_index"
on test_pg_index_toast_table
using btree
(
  (test_pg_index_toast_func(a, 'b'))
);

reindex index test_pg_index_toast_index;

drop INDEX test_pg_index_toast_index;

drop FUNCTION test_pg_index_toast_func;

drop TABLE test_pg_index_toast_table;
