---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/create_am.sql
snapshot_kind: text
---
create ACCESS METHOD gist2 type INDEX HANDLER gisthandler;

create ACCESS METHOD bogus type INDEX HANDLER int4in;

create ACCESS METHOD bogus type INDEX HANDLER heap_tableam_handler;

create index "grect2ind2" on fast_emp4000 using gist2 (home_base);

create OPERATOR class box_ops default
  for type box
  using gist2
  as OPERATOR 1 <<,
  OPERATOR 2 &<,
  OPERATOR 3 &&,
  OPERATOR 4 &>,
  OPERATOR 5 >>,
  OPERATOR 6 ~=,
  OPERATOR 7 @>,
  OPERATOR 8 <@,
  OPERATOR 9 &<|,
  OPERATOR 10 <<|,
  OPERATOR 11 |>>,
  OPERATOR 12 |&>,
  FUNCTION 1 gist_box_consistent(
    internal,
    box,
    SMALLINT,
    OID,
    internal),
  FUNCTION 2 gist_box_union(internal, internal),
  FUNCTION 5 gist_box_penalty(internal, internal, internal),
  FUNCTION 6 gist_box_picksplit(internal, internal),
  FUNCTION 7 gist_box_same(box, box, internal);

create index "grect2ind2" on fast_emp4000 using gist2 (home_base);

begin;

drop INDEX grect2ind;

set enable_seqscan = off;

set enable_indexscan = 'on';

set enable_bitmapscan = off;

select
  *
from
  fast_emp4000
where
  home_base <@ cast('(200,200),(2000,1000)' as box)
order by home_base[0][0];

select
  *
from
  fast_emp4000
where
  home_base <@ cast('(200,200),(2000,1000)' as box)
order by home_base[0][0];

select COUNT(*) from fast_emp4000 where home_base && cast('(1000,1000,0,0)' as box);

select COUNT(*) from fast_emp4000 where home_base && cast('(1000,1000,0,0)' as box);

select COUNT(*) from fast_emp4000 where home_base is null;

select COUNT(*) from fast_emp4000 where home_base is null;

rollback;

drop ACCESS METHOD gist2;

begin;

lock table fast_emp4000 in ACCESS EXCLUSIVE mode;

drop ACCESS METHOD gist2 cascade;

commit;

set default_table_access_method = '';

set default_table_access_method = 'I do not exist AM';

set default_table_access_method = btree;

create ACCESS METHOD heap2 type TABLE HANDLER heap_tableam_handler;

create ACCESS METHOD bogus type TABLE HANDLER int4in;

create ACCESS METHOD bogus type TABLE HANDLER bthandler;

select amname, amhandler, amtype from pg_am where amtype = 't' order by 1, 2;

create table tableam_tbl_heap2 (f1 INT) using heap2;

insert into tableam_tbl_heap2 values (1);

select f1 from tableam_tbl_heap2 order by f1;

create table tableam_tblas_heap2 using heap2 as select * from tableam_tbl_heap2;

select f1 from tableam_tbl_heap2 order by f1;

create materialized view tableam_tblmv_heap2 using heap2 as select * from tableam_tbl_heap2;

select f1 from tableam_tblmv_heap2 order by f1;

create table tableam_parted_heap2 (
  a TEXT,
  b INT
)
partition by LIST(a) using heap2;

select
  a.amname
from
  pg_class as c,
  pg_am as a
where
  c.relname = 'tableam_parted_heap2' and
  a.oid = c.relam;

drop TABLE tableam_parted_heap2;

create table tableam_parted_heap2 (
  a TEXT,
  b INT
)
partition by LIST(a);

set default_table_access_method = heap;

create table tableam_parted_a_heap2 partition of tableam_parted_heap2 for values in ('a');

set default_table_access_method = heap2;

create table tableam_parted_b_heap2 partition of tableam_parted_heap2 for values in ('b');

reset default_table_access_method;

create table tableam_parted_c_heap2
partition of tableam_parted_heap2
for values in ('c') using heap;

create table tableam_parted_d_heap2
partition of tableam_parted_heap2
for values in ('d') using heap2;

select
  pc.relkind,
  pa.amname,
  (case
    when relkind = 't'
    then (
      select
        'toast for ' || cast(relname as REGCLASS)
      from
        pg_class as pcm
      where
        pcm.reltoastrelid = pc.oid
    )
    else cast(cast(relname as REGCLASS) as TEXT)
  end) collate "C"
  as relname
from
  pg_class as pc,
  pg_am as pa
where
  pa.oid = pc.relam and pa.amname = 'heap2'
order by 3,
  1,
  2;

select
  pg_describe_object(classid, objid, objsubid)
  as obj
from
  pg_depend,
  pg_am
where
  pg_depend.refclassid = cast('pg_am' as REGCLASS) and
  pg_am.oid = pg_depend.refobjid and
  pg_am.amname = 'heap2'
order by classid,
  objid,
  objsubid;

create table heaptable using heap
as
  select
    a,
    repeat(cast(a as TEXT), 100)
  from
    generate_series(1, 9) as a;

select
  amname
from
  pg_class as c,
  pg_am as am
where
  c.relam = am.oid and
  c.oid = cast('heaptable' as REGCLASS);

alter table heaptable
  set ACCESS METHOD heap2;

select
  pg_describe_object(classid, objid, objsubid)
  as obj,
  pg_describe_object(
    refclassid,
    refobjid,
    refobjsubid
  )
  as objref,
  deptype
from
  pg_depend
where
  classid = cast('pg_class' as REGCLASS) and
  objid = cast('heaptable' as REGCLASS)
order by 1,
  2;

alter table heaptable
  set ACCESS METHOD heap;

select
  pg_describe_object(classid, objid, objsubid)
  as obj,
  pg_describe_object(
    refclassid,
    refobjid,
    refobjsubid
  )
  as objref,
  deptype
from
  pg_depend
where
  classid = cast('pg_class' as REGCLASS) and
  objid = cast('heaptable' as REGCLASS)
order by 1,
  2;

alter table heaptable
  set ACCESS METHOD heap2;

select
  amname
from
  pg_class as c,
  pg_am as am
where
  c.relam = am.oid and
  c.oid = cast('heaptable' as REGCLASS);

select COUNT(a), COUNT(1) filter (where a = 1) from heaptable;

begin;

set local default_table_access_method = heap2;

alter table heaptable
  set ACCESS METHOD default;

select
  amname
from
  pg_class as c,
  pg_am as am
where
  c.relam = am.oid and
  c.oid = cast('heaptable' as REGCLASS);

set local default_table_access_method = heap;

alter table heaptable
  set ACCESS METHOD default;

select
  amname
from
  pg_class as c,
  pg_am as am
where
  c.relam = am.oid and
  c.oid = cast('heaptable' as REGCLASS);

rollback;

create materialized view heapmv using heap as select * from heaptable;

select
  amname
from
  pg_class as c,
  pg_am as am
where
  c.relam = am.oid and
  c.oid = cast('heapmv' as REGCLASS);

alter materialized view heapmv
  set ACCESS METHOD heap2;

select
  amname
from
  pg_class as c,
  pg_am as am
where
  c.relam = am.oid and
  c.oid = cast('heapmv' as REGCLASS);

select COUNT(a), COUNT(1) filter (where a = 1) from heapmv;

alter table heaptable
  set ACCESS METHOD heap,
  set ACCESS METHOD heap2;

alter table heaptable
  set ACCESS METHOD default,
  set ACCESS METHOD heap2;

alter materialized view heapmv
  set ACCESS METHOD heap,
  set ACCESS METHOD heap2;

drop MATERIALIZED VIEW heapmv;

drop TABLE heaptable;

create table am_partitioned (
  x INT,
  y INT
)
partition by HASH(x) using heap2;

select
  pg_describe_object(classid, objid, objsubid)
  as obj,
  pg_describe_object(
    refclassid,
    refobjid,
    refobjsubid
  )
  as refobj
from
  pg_depend,
  pg_am
where
  pg_depend.refclassid = cast('pg_am' as REGCLASS) and
  pg_am.oid = pg_depend.refobjid and
  pg_depend.objid =
  cast('am_partitioned' as REGCLASS);

drop TABLE am_partitioned;

begin;

set local default_table_access_method = heap;

create table am_partitioned (
  x INT,
  y INT
)
partition by HASH(x);

select relam from pg_class where relname = 'am_partitioned';

select
  pg_describe_object(classid, objid, objsubid)
  as obj,
  pg_describe_object(
    refclassid,
    refobjid,
    refobjsubid
  )
  as refobj
from
  pg_depend,
  pg_am
where
  pg_depend.refclassid = cast('pg_am' as REGCLASS) and
  pg_am.oid = pg_depend.refobjid and
  pg_depend.objid =
  cast('am_partitioned' as REGCLASS);

alter table am_partitioned
  set ACCESS METHOD heap2;

select
  a.amname
from
  pg_class as c,
  pg_am as a
where
  c.relname = 'am_partitioned' and a.oid = c.relam;

select
  pg_describe_object(classid, objid, objsubid)
  as obj,
  pg_describe_object(
    refclassid,
    refobjid,
    refobjsubid
  )
  as refobj
from
  pg_depend,
  pg_am
where
  pg_depend.refclassid = cast('pg_am' as REGCLASS) and
  pg_am.oid = pg_depend.refobjid and
  pg_depend.objid =
  cast('am_partitioned' as REGCLASS);

set local default_table_access_method = heap2;

alter table am_partitioned
  set ACCESS METHOD heap;

select
  a.amname
from
  pg_class as c,
  pg_am as a
where
  c.relname = 'am_partitioned' and a.oid = c.relam;

select
  pg_describe_object(classid, objid, objsubid)
  as obj,
  pg_describe_object(
    refclassid,
    refobjid,
    refobjsubid
  )
  as refobj
from
  pg_depend,
  pg_am
where
  pg_depend.refclassid = cast('pg_am' as REGCLASS) and
  pg_am.oid = pg_depend.refobjid and
  pg_depend.objid =
  cast('am_partitioned' as REGCLASS);

set local default_table_access_method = heap2;

alter table am_partitioned
  set ACCESS METHOD heap2;

select
  a.amname
from
  pg_class as c,
  pg_am as a
where
  c.relname = 'am_partitioned' and a.oid = c.relam;

alter table am_partitioned
  set ACCESS METHOD default;

select relam from pg_class where relname = 'am_partitioned';

select relam from pg_class where relname = 'am_partitioned';

set local default_table_access_method = heap;

create table am_partitioned_0 partition of am_partitioned for values with (MODULUS 10, REMAINDER 0);

set local default_table_access_method = heap2;

create table am_partitioned_1 partition of am_partitioned for values with (MODULUS 10, REMAINDER 1);

set local default_table_access_method = heap;

alter table am_partitioned
  set ACCESS METHOD heap2;

create table am_partitioned_2 partition of am_partitioned for values with (MODULUS 10, REMAINDER 2);

alter table am_partitioned
  set ACCESS METHOD default;

select relam from pg_class where relname = 'am_partitioned';

create table am_partitioned_3 partition of am_partitioned for values with (MODULUS 10, REMAINDER 3);

alter table am_partitioned
  set ACCESS METHOD default;

create table am_partitioned_5p
partition of am_partitioned
for values with (MODULUS 10, REMAINDER 5)
partition by HASH(y);

create table am_partitioned_5p1
partition of am_partitioned_5p
for values with (MODULUS 10, REMAINDER 1);

alter table am_partitioned
  set ACCESS METHOD heap2;

create table am_partitioned_6p
partition of am_partitioned
for values with (MODULUS 10, REMAINDER 6)
partition by HASH(y);

create table am_partitioned_6p1
partition of am_partitioned_6p
for values with (MODULUS 10, REMAINDER 1);

select
  c.relname,
  a.amname
from
  pg_class as c,
  pg_am as a
where
  c.relam = a.oid and
  c.relname like 'am_partitioned%'
union all
select
  c.relname,
  'default'
from
  pg_class as c
where
  c.relam = 0 and c.relname like 'am_partitioned%'
order by 1;

drop TABLE am_partitioned;

commit;

begin;

set local default_table_access_method = heap2;

create table tableam_tbl_heapx (f1 INT);

create table tableam_tblas_heapx as select * from tableam_tbl_heapx;

select into tableam_tblselectinto_heapx from tableam_tbl_heapx;

create materialized view tableam_tblmv_heapx using heap2 as select * from tableam_tbl_heapx;

create table tableam_parted_heapx (
  a TEXT,
  b INT
)
partition by LIST(a);

create table tableam_parted_1_heapx partition of tableam_parted_heapx for values in ('a', 'b');

create table tableam_parted_2_heapx
partition of tableam_parted_heapx
for values in ('c', 'd') using heap;

create view tableam_view_heapx
as select * from tableam_tbl_heapx;

create sequence tableam_seq_heapx;

create FOREIGN DATA WRAPPER fdw_heap2 VALIDATOR postgresql_fdw_validator ;

create server fs_heap2 foreign data wrapper fdw_heap2;

create foreign table tableam_fdw_heapx () SERVER fs_heap2;

select
  pc.relkind,
  pa.amname,
  (case
    when relkind = 't'
    then (
      select
        'toast for ' || cast(relname as REGCLASS)
      from
        pg_class as pcm
      where
        pcm.reltoastrelid = pc.oid
    )
    else cast(cast(relname as REGCLASS) as TEXT)
  end) collate "C"
  as relname
from
  pg_class as pc
  left outer join
    pg_am as pa
  on pa.oid = pc.relam
where
  pc.relname like 'tableam_%_heapx'
order by 3,
  1,
  2;

rollback;

create table i_am_a_failure () using i_do_not_exist_am;

create table i_am_a_failure () using "I do not exist AM";

create table i_am_a_failure () using btree;

create foreign table fp partition of tableam_parted_a_heap2 default SERVER x;

drop ACCESS METHOD heap2;
