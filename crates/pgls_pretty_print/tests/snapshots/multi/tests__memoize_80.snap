---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/memoize.sql
snapshot_kind: text
---
create function explain_memoize(query text, hide_hitmiss boolean)
returns setof text
language plpgsql
as $function$
declare
    ln text;
begin
    for ln in
        execute format('explain (analyze, costs off, summary off, timing off, buffers off) %s',
            query)
    loop
        if hide_hitmiss = true then
                ln := regexp_replace(ln, 'Hits: 0', 'Hits: Zero');
                ln := regexp_replace(ln, 'Hits: \d+', 'Hits: N');
                ln := regexp_replace(ln, 'Misses: 0', 'Misses: Zero');
                ln := regexp_replace(ln, 'Misses: \d+', 'Misses: N');
        end if;
        ln := regexp_replace(ln, 'Evictions: 0', 'Evictions: Zero');
        ln := regexp_replace(ln, 'Evictions: \d+', 'Evictions: N');
        ln := regexp_replace(ln, 'Memory Usage: \d+', 'Memory Usage: N');
        ln := regexp_replace(ln, 'Heap Fetches: \d+', 'Heap Fetches: N');
        ln := regexp_replace(ln, 'loops=\d+', 'loops=N');
        ln := regexp_replace(ln, 'Index Searches: \d+', 'Index Searches: N');
        ln := regexp_replace(ln, 'Memory: \d+kB', 'Memory: NkB');
        return next ln;
    end loop;
end;
$function$;

set enable_hashjoin = off;

set enable_bitmapscan = off;

select
  explain_memoize(
    '
SELECT COUNT(*),AVG(t1.unique1) FROM tenk1 t1
INNER JOIN tenk1 t2 ON t1.unique1 = t2.twenty
WHERE t2.unique1 < 1000;',
    false
  );

select
  COUNT(*),
  AVG(t1.unique1)
from
  tenk1 as t1
  inner join
    tenk1 as t2
  on t1.unique1 = t2.twenty
where
  t2.unique1 < 1000;

select
  explain_memoize(
    '
SELECT COUNT(*),AVG(t2.unique1) FROM tenk1 t1,
LATERAL (SELECT t2.unique1 FROM tenk1 t2
         WHERE t1.twenty = t2.unique1 OFFSET 0) t2
WHERE t1.unique1 < 1000;',
    false
  );

select
  COUNT(*),
  AVG(t2.unique1)
from
  tenk1 as t1,
  lateral (
    select
      t2.unique1
    from
      tenk1 as t2
    where
      t1.twenty = t2.unique1
    offset 0
  )
  as t2
where
  t1.unique1 < 1000;

select
  explain_memoize(
    '
SELECT COUNT(*),AVG(t2.t1two) FROM tenk1 t1 LEFT JOIN
LATERAL (
    SELECT t1.two as t1two, * FROM tenk1 t2 WHERE t2.unique1 < 4 OFFSET 0
) t2
ON t1.two = t2.two
WHERE t1.unique1 < 10;',
    false
  );

select
  COUNT(*),
  AVG(t2.t1two)
from
  tenk1 as t1
  left outer join
    lateral (
      select
        t1.two as t1two,
        *
      from
        tenk1 as t2
      where
        t2.unique1 < 4
      offset 0
    )
    as t2
  on t1.two = t2.two
where
  t1.unique1 < 10;

select
  explain_memoize(
    '
SELECT COUNT(*), AVG(t1.twenty) FROM tenk1 t1 LEFT JOIN
LATERAL (SELECT t1.two+1 AS c1, t2.unique1 AS c2 FROM tenk1 t2) s ON TRUE
WHERE s.c1 = s.c2 AND t1.unique1 < 1000;',
    false
  );

select
  COUNT(*),
  AVG(t1.twenty)
from
  tenk1 as t1
  left outer join
    lateral (
      select
        t1.two + 1 as c1,
        t2.unique1 as c2
      from
        tenk1 as t2
    )
    as s
  on true
where
  s.c1 = s.c2 and t1.unique1 < 1000;

select
  explain_memoize(
    '
SELECT COUNT(*), AVG(t1.twenty) FROM tenk1 t1 LEFT JOIN
LATERAL (SELECT t1.twenty AS c1, t2.unique1 AS c2, t2.two FROM tenk1 t2) s
ON t1.two = s.two
WHERE s.c1 = s.c2 AND t1.unique1 < 1000;',
    false
  );

select
  COUNT(*),
  AVG(t1.twenty)
from
  tenk1 as t1
  left outer join
    lateral (
      select
        t1.twenty as c1,
        t2.unique1 as c2,
        t2.two
      from
        tenk1 as t2
    )
    as s
  on t1.two = s.two
where
  s.c1 = s.c2 and t1.unique1 < 1000;

set enable_mergejoin = off;

create table expr_key (
  x numeric,
  t text
);

insert into expr_key (x, t)
select
  cast(d1 as numeric),
  cast(d1 as text)
from
  (
    select
      round(cast(d / pi() as numeric), 7)
      as d1
    from
      generate_series(1, 20) as d
  )
  as t;

insert into expr_key select * from expr_key;

create index "expr_key_idx_x_t" on expr_key using btree (x, t);

vacuum (ANALYZE) expr_key;

select
  explain_memoize(
    '
SELECT * FROM expr_key t1 INNER JOIN expr_key t2
ON t1.x = t2.t::numeric AND t1.t::numeric = t2.x;',
    false
  );

drop table expr_key;

set work_mem = '64kB';

set hash_mem_multiplier = 1.0;

select
  explain_memoize(
    '
SELECT COUNT(*),AVG(t1.unique1) FROM tenk1 t1
INNER JOIN tenk1 t2 ON t1.unique1 = t2.thousand
WHERE t2.unique1 < 1200;',
    true
  );

create table flt (f double precision);

create index "flt_f_idx" on flt using btree (f);

insert into flt
values
  (cast('-0.0' as double precision)),
  (cast('+0.0' as double precision));

analyze flt;

set enable_seqscan = off;

select
  explain_memoize(
    '
SELECT * FROM flt f1 INNER JOIN flt f2 ON f1.f = f2.f;',
    false
  );

select
  explain_memoize(
    '
SELECT * FROM flt f1 INNER JOIN flt f2 ON f1.f >= f2.f;',
    false
  );

drop table flt;

create table strtest (
  n name,
  t text
);

create index "strtest_n_idx" on strtest using btree (n);

create index "strtest_t_idx" on strtest using btree (t);

insert into strtest
values
  ('one', 'one'),
  ('two', 'two'),
  (
    'three', repeat(fipshash('three'), 100)
  );

insert into strtest select * from strtest;

analyze strtest;

select
  explain_memoize(
    '
SELECT * FROM strtest s1 INNER JOIN strtest s2 ON s1.n >= s2.n;',
    false
  );

select
  explain_memoize(
    '
SELECT * FROM strtest s1 INNER JOIN strtest s2 ON s1.t >= s2.t;',
    false
  );

drop table strtest;

set enable_partitionwise_join = 'on';

create table prt (a int)
partition by range(a);

create table prt_p1 partition of prt for values from (0) to (10);

create table prt_p2 partition of prt for values from (10) to (20);

insert into prt values (0), (0), (0), (0);

insert into prt values (10), (10), (10), (10);

create index "iprt_p1_a" on prt_p1 using btree (a);

create index "iprt_p2_a" on prt_p2 using btree (a);

analyze prt;

select
  explain_memoize(
    '
SELECT * FROM prt t1 INNER JOIN prt t2 ON t1.a = t2.a;',
    false
  );

set enable_partitionwise_join = off;

select
  explain_memoize(
    '
SELECT * FROM prt_p1 t1 INNER JOIN
(SELECT * FROM prt_p1 UNION ALL SELECT * FROM prt_p2) t2
ON t1.a = t2.a;',
    false
  );

drop table prt;

reset enable_partitionwise_join;

select
  unique1
from
  tenk1 as t0
where
  unique1 < 3 and
  exists
  (
    select
      1
    from
      tenk1 as t1
      inner join
        tenk1 as t2
      on t1.unique1 = t2.hundred
    where
      t0.ten = t1.twenty and t0.two <> t2.four
    offset 0
  );

select
  unique1
from
  tenk1 as t0
where
  unique1 < 3 and
  exists
  (
    select
      1
    from
      tenk1 as t1
      inner join
        tenk1 as t2
      on t1.unique1 = t2.hundred
    where
      t0.ten = t1.twenty and t0.two <> t2.four
    offset 0
  );

reset enable_seqscan;

reset enable_mergejoin;

reset work_mem;

reset hash_mem_multiplier;

reset enable_bitmapscan;

reset enable_hashjoin;

set min_parallel_table_scan_size = 0;

set parallel_setup_cost = 0;

set parallel_tuple_cost = 0;

set max_parallel_workers_per_gather = 2;

select
  COUNT(*),
  AVG(t2.unique1)
from
  tenk1 as t1,
  lateral (
    select
      t2.unique1
    from
      tenk1 as t2
    where
      t1.twenty = t2.unique1
  )
  as t2
where
  t1.unique1 < 1000;

select
  COUNT(*),
  AVG(t2.unique1)
from
  tenk1 as t1,
  lateral (
    select
      t2.unique1
    from
      tenk1 as t2
    where
      t1.twenty = t2.unique1
  )
  as t2
where
  t1.unique1 < 1000;

reset max_parallel_workers_per_gather;

reset parallel_tuple_cost;

reset parallel_setup_cost;

reset min_parallel_table_scan_size;

create table tab_anti (
  a int,
  b boolean
);

insert into tab_anti select i % 3, false from generate_series(1, 100) as i;

analyze tab_anti;

select
  explain_memoize(
    '
SELECT COUNT(*) FROM tab_anti t1 LEFT JOIN
LATERAL (SELECT DISTINCT ON (a) a, b, t1.a AS x FROM tab_anti t2) t2
ON t1.a+1 = t2.a
WHERE t2.a IS NULL;',
    false
  );

select
  COUNT(*)
from
  tab_anti as t1
  left outer join
    lateral (
      select distinct on (
        a)
        a,
        b,
        t1.a as x
      from
        tab_anti as t2
    )
    as t2
  on t1.a + 1 = t2.a
where
  t2.a is null;

select
  *
from
  tab_anti as t1
where
  t1.a in
  (
    select
      a
    from
      tab_anti as t2
    where
      t2.b in
      (
        select
          t1.b
        from
          tab_anti as t3
        where
          t2.a > 1
        offset 0
      )
  );

drop table tab_anti;
