---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/update.sql
snapshot_kind: text
---
create table update_test (
  a int default 10,
  b int,
  c text
);

create table upsert_test (
  a int primary key,
  b text
);

insert into update_test values (5, 10, 'foo');

insert into update_test (b, a) values (15, 10);

select * from update_test;

update update_test set a = default, b = default;

select * from update_test;

update update_test as t set b = 10 where t.a = 10;

select * from update_test;

update update_test as t set b = t.b + 10 where t.a = 10;

select * from update_test;

update update_test as t set t."b" = t.b + 10 where t.a = 10;

update update_test set a = v.i from (values (100, 20)) as v (i, j) where update_test.b = v.j;

select * from update_test;

update update_test set a = v.* from (values (100, 20)) as v (i, j) where update_test.b = v.j;

insert into update_test select a, b + 1, c from update_test;

select * from update_test;

update update_test set (c, b, a) = ('bugle', b + 11, default) where c = 'foo';

select * from update_test;

update update_test set (c, b) = ('car', a + b), a = a + 1 where a = 10;

select * from update_test;

update update_test set (c, b) = ('car', a + b), b = a + 1 where a = 10;

update update_test
set (b, a) = (
  select
    a,
    b
  from
    update_test
  where
    b = 41 and c = 'car'
)
where
  a = 100 and b = 20;

select * from update_test;

update update_test as o
set (b, a) = (
  select
    a + 1,
    b
  from
    update_test as i
  where
    i.a = o.a and
    i.b = o.b and
    i.c is not distinct from o.c
);

select * from update_test;

update update_test set (b, a) = (select a + 1, b from update_test);

update update_test set (b, a) = (select a + 1, b from update_test where a = 1000) where a = 11;

select * from update_test;

update update_test
set (a, b) = row(v.*)
from (values (21, 100)) as v (i, j)
where
  update_test.a = v.i;

update update_test set (a, b) = v.* from (values (21, 101)) as v (i, j) where update_test.a = v.i;

update update_test as t set b = update_test.b + 10 where t.a = 10;

update update_test set c = repeat('x', 10000) where c = 'car';

select a, b, char_length(c) from update_test;

update update_test as t
set (a, b) = (
  select b, a from update_test as s where s.a = t.a
)
where
  current_user = session_user;

update update_test as t
set (a, b) = (
  select b, a from update_test as s where s.a = t.a
)
where
  current_user = session_user;

select a, b, char_length(c) from update_test;

insert into upsert_test values (1, 'Boo'), (3, 'Zoo');

with aaa as (select 1 as a, 'Foo' as b)
insert into upsert_test
values (1, 'Bar')
on conflict
(a)
do
update
set (b, a) = (select b, a from aaa)
returning *;

insert into upsert_test
values (1, 'Baz'), (3, 'Zaz')
on conflict
(a)
do
update
set (b, a) = (
  select
    b || ', Correlated',
    a
  from
    upsert_test as i
  where
    i.a = upsert_test.a
)
returning *;

insert into upsert_test
values (1, 'Bat'), (3, 'Zot')
on conflict
(a)
do
update
set (b, a) = (
  select
    b || ', Excluded',
    a
  from
    upsert_test as i
  where
    i.a = excluded.a
)
returning *;

insert into upsert_test
values (2, 'Beeble')
on conflict
(a)
do
update
set (b, a) = (
  select
    b || ', Excluded',
    a
  from
    upsert_test as i
  where
    i.a = excluded.a
)
returning cast(tableoid as regclass),
xmin = cast(pg_current_xact_id() as xid)
as xmin_correct,
xmax = 0 as xmax_correct;

insert into upsert_test
values (2, 'Brox')
on conflict
(a)
do
update
set (b, a) = (
  select
    b || ', Excluded',
    a
  from
    upsert_test as i
  where
    i.a = excluded.a
)
returning cast(tableoid as regclass),
xmin = cast(pg_current_xact_id() as xid)
as xmin_correct,
xmax = cast(pg_current_xact_id() as xid)
as xmax_correct;

drop table update_test;

drop table upsert_test;

create table upsert_test (
  a int primary key,
  b text
)
partition by LIST(a);

create table upsert_test_1 partition of upsert_test for values in (1);

create table upsert_test_2 (
  b text,
  a int primary key
);

alter table upsert_test
  attach partition
  upsert_test_2 for values in (2);

insert into upsert_test values (1, 'Boo'), (2, 'Zoo');

with aaa as (select 1 as a, 'Foo' as b)
insert into upsert_test
values (1, 'Bar')
on conflict
(a)
do
update
set (b, a) = (select b, a from aaa)
returning *;

with aaa as (select 1 as ctea, ' Foo' as cteb)
insert into upsert_test
values (1, 'Bar'), (2, 'Baz')
on conflict
(a)
do
update
set (b, a) = (
  select
    upsert_test.b || cteb,
    upsert_test.a
  from
    aaa
)
returning *;

drop table upsert_test;

create table range_parted (
  a text,
  b bigint,
  c numeric,
  d int,
  e varchar
)
partition by range(a, b);

create table part_b_20_b_30 (
  e varchar,
  c numeric,
  a text,
  b bigint,
  d int
);

alter table range_parted
  attach partition
  part_b_20_b_30
  for values from ('b', 20) to ('b', 30);

create table part_b_10_b_20 (
  e varchar,
  c numeric,
  a text,
  b bigint,
  d int
)
partition by range(c);

create table part_b_1_b_10 partition of range_parted for values from ('b', 1) to ('b', 10);

alter table range_parted
  attach partition
  part_b_10_b_20
  for values from ('b', 10) to ('b', 20);

create table part_a_10_a_20 partition of range_parted for values from ('a', 10) to ('a', 20);

create table part_a_1_a_10 partition of range_parted for values from ('a', 1) to ('a', 10);

update part_b_10_b_20 set b = b - 6;

create table part_c_100_200 (
  e varchar,
  c numeric,
  a text,
  b bigint,
  d int
)
partition by range((abs(d)));

alter table part_c_100_200
  drop column e,
  drop column c,
  drop column a;

alter table part_c_100_200
  add column c numeric,
  add column e varchar,
  add column a text;

alter table part_c_100_200
  drop column b;

alter table part_c_100_200
  add column b bigint;

create table part_d_1_15 partition of part_c_100_200 for values from (1) to (15);

create table part_d_15_20 partition of part_c_100_200 for values from (15) to (20);

alter table part_b_10_b_20
  attach partition
  part_c_100_200 for values from (100) to (200);

create table part_c_1_100 (
  e varchar,
  d int,
  c numeric,
  b bigint,
  a text
);

alter table part_b_10_b_20
  attach partition
  part_c_1_100 for values from (1) to (100);

update range_parted set c = c - 50 where c > 97;

update part_c_100_200 set c = c - 20, d = c where c = 105;

update part_b_10_b_20 set a = 'a';

update range_parted set d = d - 10 where d > 10;

update range_parted set e = d;

update part_c_1_100 set c = c + 20 where c = 98;

update part_b_10_b_20 set c = c + 20 returning c, b, a;

update part_b_10_b_20 set b = b - 6 where c > 116 returning *;

update range_parted set b = b - 6 where c > 116 returning a, b + c;

create table mintab (c1 int);

insert into mintab values (120);

create view upview
as select
  *
from
  range_parted
where
  (select c > c1 from mintab)
with cascaded check option;

update upview set c = 199 where b = 4;

update upview set c = 120 where b = 4;

update upview set a = 'b', b = 15, c = 120 where b = 4;

update upview set a = 'b', b = 15 where b = 4;

drop view upview;

update range_parted set c = 95 where a = 'b' and b > 10 and c > 100 returning range_parted, *;

create function trans_updatetrigfunc()
returns trigger
language plpgsql
as $function$
  begin
    raise notice 'trigger = %, old table = %, new table = %',
                 TG_NAME,
                 (select string_agg(old_table::text, ', ' ORDER BY a) FROM old_table),
                 (select string_agg(new_table::text, ', ' ORDER BY a) FROM new_table);
    return null;
  end;
$function$;

create trigger trans_updatetrig
after update
on range_parted
referencing old table as old_table
new table as new_table
for each statement
execute function trans_updatetrigfunc();

update range_parted
set c = case when c = 96 then 110 else c + 1 end
where
  a = 'b' and b > 10 and c >= 96;

create trigger trans_deletetrig
after delete
on range_parted
referencing old table as old_table
for each statement
execute function trans_updatetrigfunc();

create trigger trans_inserttrig
after insert
on range_parted
referencing new table as new_table
for each statement
execute function trans_updatetrigfunc();

update range_parted set c = c + 50 where a = 'b' and b > 10 and c >= 96;

drop trigger trans_deletetrig on range_parted;

drop trigger trans_inserttrig on range_parted;

create function func_parted_mod_b()
returns trigger
as $function$
BEGIN
   NEW.b = NEW.b + 1;
   return NEW;
END $function$
language plpgsql;

create trigger trig_c1_100
before insert or update
on part_c_1_100
for each row
execute function func_parted_mod_b();

create trigger trig_d1_15
before insert or update
on part_d_1_15
for each row
execute function func_parted_mod_b();

create trigger trig_d15_20
before insert or update
on part_d_15_20
for each row
execute function func_parted_mod_b();

update range_parted
set c = case when c = 96 then 110 else c + 1 end
where
  a = 'b' and b > 10 and c >= 96;

update range_parted set c = c + 50 where a = 'b' and b > 10 and c >= 96;

update range_parted set b = 15 where b = 1;

drop trigger trans_updatetrig on range_parted;

drop trigger trig_c1_100 on part_c_1_100;

drop trigger trig_d1_15 on part_d_1_15;

drop trigger trig_d15_20 on part_d_15_20;

drop function func_parted_mod_b();

alter table range_parted
  enable row level security;

create user regress_range_parted_user;

grant all on table range_parted, mintab to regress_range_parted_user;

create policy seeall on range_parted as permissive for select to public using (true);

create policy policy_range_parted
on range_parted
as permissive
for update
to public
using (true)
with check (c % 2 = 0);

set session authorization regress_range_parted_user;

update range_parted set a = 'b', c = 151 where a = 'a' and c = 200;

reset session_authorization;

create function func_d_1_15()
returns trigger
as $function$
BEGIN
   NEW.c = NEW.c + 1; -- Make even numbers odd, or vice versa
   return NEW;
END $function$
language plpgsql;

create trigger trig_d_1_15 before insert on part_d_1_15 for each row execute function func_d_1_15();

set session authorization regress_range_parted_user;

update range_parted set a = 'b', c = 151 where a = 'a' and c = 200;

reset session_authorization;

set session authorization regress_range_parted_user;

update range_parted set a = 'b', c = 150 where a = 'a' and c = 200;

reset session_authorization;

drop trigger trig_d_1_15 on part_d_1_15;

drop function func_d_1_15();

reset session_authorization;

create policy policy_range_parted_subplan
on range_parted
as restrictive
for update
to public
using (true)
with check ((select range_parted.c <= c1 from mintab));

set session authorization regress_range_parted_user;

update range_parted set a = 'b', c = 122 where a = 'a' and c = 200;

update range_parted set a = 'b', c = 120 where a = 'a' and c = 200;

reset session_authorization;

create policy policy_range_parted_wholerow
on range_parted
as restrictive
for update
to public
using (true)
with check (range_parted =
cast(row('b', 10, 112, 1, null) as range_parted));

set session authorization regress_range_parted_user;

update range_parted set a = 'b', c = 112 where a = 'a' and c = 200;

reset session_authorization;

set session authorization regress_range_parted_user;

update range_parted set a = 'b', c = 116 where a = 'a' and c = 200;

reset session_authorization;

drop policy policy_range_parted on range_parted;

drop policy policy_range_parted_subplan on range_parted;

drop policy policy_range_parted_wholerow on range_parted;

revoke all on table range_parted, mintab from regress_range_parted_user;

drop role regress_range_parted_user;

drop table mintab;

create function trigfunc()
returns trigger
language plpgsql
as $function$
  begin
    raise notice 'trigger = % fired on table % during %',
                 TG_NAME, TG_TABLE_NAME, TG_OP;
    return null;
  end;
$function$;

create trigger parent_delete_trig
after delete
on range_parted
for each statement
execute function trigfunc();

create trigger parent_update_trig
after update
on range_parted
for each statement
execute function trigfunc();

create trigger parent_insert_trig
after insert
on range_parted
for each statement
execute function trigfunc();

create trigger c1_delete_trig
after delete
on part_c_1_100
for each statement
execute function trigfunc();

create trigger c1_update_trig
after update
on part_c_1_100
for each statement
execute function trigfunc();

create trigger c1_insert_trig
after insert
on part_c_1_100
for each statement
execute function trigfunc();

create trigger d1_delete_trig
after delete
on part_d_1_15
for each statement
execute function trigfunc();

create trigger d1_update_trig
after update
on part_d_1_15
for each statement
execute function trigfunc();

create trigger d1_insert_trig
after insert
on part_d_1_15
for each statement
execute function trigfunc();

create trigger d15_delete_trig
after delete
on part_d_15_20
for each statement
execute function trigfunc();

create trigger d15_update_trig
after update
on part_d_15_20
for each statement
execute function trigfunc();

create trigger d15_insert_trig
after insert
on part_d_15_20
for each statement
execute function trigfunc();

update range_parted set c = c - 50 where c > 97;

drop trigger parent_delete_trig on range_parted;

drop trigger parent_update_trig on range_parted;

drop trigger parent_insert_trig on range_parted;

drop trigger c1_delete_trig on part_c_1_100;

drop trigger c1_update_trig on part_c_1_100;

drop trigger c1_insert_trig on part_c_1_100;

drop trigger d1_delete_trig on part_d_1_15;

drop trigger d1_update_trig on part_d_1_15;

drop trigger d1_insert_trig on part_d_1_15;

drop trigger d15_delete_trig on part_d_15_20;

drop trigger d15_update_trig on part_d_15_20;

drop trigger d15_insert_trig on part_d_15_20;

create table part_def partition of range_parted default;

insert into range_parted values ('c', 9);

update part_def set a = 'd' where a = 'c';

update part_def set a = 'a' where a = 'd';

update part_a_10_a_20 set a = 'ad' where a = 'a';

update range_parted set a = 'ad' where a = 'a';

update range_parted set a = 'bd' where a = 'b';

update range_parted set a = 'a' where a = 'ad';

update range_parted set a = 'b' where a = 'bd';

drop table range_parted;

create table list_parted (
  a text,
  b int
)
partition by LIST(a);

create table list_part1 partition of list_parted for values in ('a', 'b');

create table list_default partition of list_parted default;

insert into list_part1 values ('a', 1);

insert into list_default values ('d', 10);

update list_default set a = 'a' where a = 'd';

update list_default set a = 'x' where a = 'd';

drop table list_parted;

create table utrtest (
  a int,
  b text
)
partition by LIST(a);

create table utr1 (
  a int check (a in (1)),
  q text,
  b text
);

create table utr2 (
  a int check (a in (2)),
  b text
);

alter table utr1
  drop column q;

alter table utrtest
  attach partition
  utr1 for values in (1);

alter table utrtest
  attach partition
  utr2 for values in (2);

insert into utrtest
values (1, 'foo')
returning *,
cast(tableoid as regclass),
xmin = cast(pg_current_xact_id() as xid)
as xmin_ok;

insert into utrtest
values (2, 'bar')
returning *,
cast(tableoid as regclass),
xmin = cast(pg_current_xact_id() as xid)
as xmin_ok;

insert into utrtest values (2, 'bar') returning *, cast(tableoid as regclass);

update utrtest
set b = b || b
from (values (1), (2)) as s (x)
where
  a = s.x
returning *,
cast(tableoid as regclass),
xmin = cast(pg_current_xact_id() as xid)
as xmin_ok;

update utrtest
set a = 3 - a
from (values (1), (2)) as s (x)
where
  a = s.x
returning *,
cast(tableoid as regclass),
xmin = cast(pg_current_xact_id() as xid)
as xmin_ok;

update utrtest
set a = 3 - a
from (values (1), (2)) as s (x)
where
  a = s.x
returning *,
cast(tableoid as regclass);

delete from utrtest
returning *,
cast(tableoid as regclass),
xmax = cast(pg_current_xact_id() as xid)
as xmax_ok;

drop table utrtest;

create table list_parted (
  a numeric,
  b int,
  c bigint
)
partition by LIST(a);

create table sub_parted partition of list_parted for values in (1) partition by LIST(b);

create table sub_part1 (
  b int,
  c bigint,
  a numeric
);

alter table sub_parted
  attach partition
  sub_part1 for values in (1);

create table sub_part2 (
  b int,
  c bigint,
  a numeric
);

alter table sub_parted
  attach partition
  sub_part2 for values in (2);

create table list_part1 (
  a numeric,
  b int,
  c bigint
);

alter table list_parted
  attach partition
  list_part1 for values in (2, 3);

insert into list_parted values (2, 5, 50);

insert into list_parted values (3, 6, 60);

insert into sub_parted values (1, 1, 60);

insert into sub_parted values (1, 2, 10);

update sub_parted set a = 2 where c = 10;

select cast(cast(tableoid as regclass) as text), * from list_parted where a = 2 order by 1;

update list_parted set b = c + a where a = 2;

select cast(cast(tableoid as regclass) as text), * from list_parted where a = 2 order by 1;

create function func_parted_mod_b()
returns trigger
as $function$
BEGIN
   NEW.b = 2; -- This is changing partition key column.
   return NEW;
END $function$
language plpgsql;

create trigger parted_mod_b
before update
on sub_part1
for each row
execute function func_parted_mod_b();

select cast(cast(tableoid as regclass) as text), * from list_parted order by 1, 2, 3, 4;

update list_parted set c = 70 where b = 1;

select cast(cast(tableoid as regclass) as text), * from list_parted order by 1, 2, 3, 4;

drop trigger parted_mod_b on sub_part1;

create or replace function func_parted_mod_b()
returns trigger
as $function$
BEGIN
   raise notice 'Trigger: Got OLD row %, but returning NULL', OLD;
   return NULL;
END $function$
language plpgsql;

create trigger trig_skip_delete
before delete
on sub_part2
for each row
execute function func_parted_mod_b();

update list_parted set b = 1 where c = 70;

select cast(cast(tableoid as regclass) as text), * from list_parted order by 1, 2, 3, 4;

drop trigger trig_skip_delete on sub_part2;

update list_parted set b = 1 where c = 70;

select cast(cast(tableoid as regclass) as text), * from list_parted order by 1, 2, 3, 4;

drop function func_parted_mod_b();

create table non_parted (id int);

insert into non_parted values (1), (1), (1), (2), (2), (2), (3), (3), (3);

update list_parted as t1 set a = 2 from non_parted as t2 where t1.a = t2.id and a = 1;

select cast(cast(tableoid as regclass) as text), * from list_parted order by 1, 2, 3, 4;

drop table non_parted;

drop table list_parted;

create or replace function dummy_hashint4(a int, seed bigint)
returns bigint
as $function$ begin return (a + seed); end; $function$
language plpgsql
immutable;

create operator class custom_opclass
  for type int
  using hash
  as operator 1 =,
  function 2 dummy_hashint4(int, bigint);

create table hash_parted (
  a int,
  b int
)
partition by HASH(a custom_opclass,
b custom_opclass);

create table hpart1 partition of hash_parted for values with (MODULUS 2, REMAINDER 1);

create table hpart2 partition of hash_parted for values with (MODULUS 4, REMAINDER 2);

create table hpart3 partition of hash_parted for values with (MODULUS 8, REMAINDER 0);

create table hpart4 partition of hash_parted for values with (MODULUS 8, REMAINDER 4);

insert into hpart1 values (1, 1);

insert into hpart2 values (2, 5);

insert into hpart4 values (3, 4);

update hpart1 set a = 3, b = 4 where a = 1;

update hash_parted set b = b - 1 where b = 1;

update hash_parted set b = b + 8 where b = 1;

drop table hash_parted;

drop operator class custom_opclass using hash;

drop function dummy_hashint4(int, bigint);
