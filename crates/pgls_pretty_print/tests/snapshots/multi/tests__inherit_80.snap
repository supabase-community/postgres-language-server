---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/inherit.sql
snapshot_kind: text
---
create table a (aa text);

create table b (bb text)
inherits (a);

create table c (cc text)
inherits (a);

create table d (dd text)
inherits (b,
c,
a);

insert into a (aa) values ('aaa');

insert into a (aa) values ('aaaa');

insert into a (aa) values ('aaaaa');

insert into a (aa) values ('aaaaaa');

insert into a (aa) values ('aaaaaaa');

insert into a (aa) values ('aaaaaaaa');

insert into b (aa) values ('bbb');

insert into b (aa) values ('bbbb');

insert into b (aa) values ('bbbbb');

insert into b (aa) values ('bbbbbb');

insert into b (aa) values ('bbbbbbb');

insert into b (aa) values ('bbbbbbbb');

insert into c (aa) values ('ccc');

insert into c (aa) values ('cccc');

insert into c (aa) values ('ccccc');

insert into c (aa) values ('cccccc');

insert into c (aa) values ('ccccccc');

insert into c (aa) values ('cccccccc');

insert into d (aa) values ('ddd');

insert into d (aa) values ('dddd');

insert into d (aa) values ('ddddd');

insert into d (aa) values ('dddddd');

insert into d (aa) values ('ddddddd');

insert into d (aa) values ('dddddddd');

select relname, a.* from a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from d, pg_class where d.tableoid = pg_class.oid;

select relname, a.* from only a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from only b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from only c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from only d, pg_class where d.tableoid = pg_class.oid;

update a set aa = 'zzzz' where aa = 'aaaa';

update only a set aa = 'zzzzz' where aa = 'aaaaa';

update b set aa = 'zzz' where aa = 'aaa';

update only b set aa = 'zzz' where aa = 'aaa';

update a set aa = 'zzzzzz' where aa like 'aaa%';

select relname, a.* from a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from d, pg_class where d.tableoid = pg_class.oid;

select relname, a.* from only a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from only b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from only c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from only d, pg_class where d.tableoid = pg_class.oid;

update b set aa = 'new';

select relname, a.* from a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from d, pg_class where d.tableoid = pg_class.oid;

select relname, a.* from only a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from only b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from only c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from only d, pg_class where d.tableoid = pg_class.oid;

update a set aa = 'new';

delete from only c where aa = 'new';

select relname, a.* from a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from d, pg_class where d.tableoid = pg_class.oid;

select relname, a.* from only a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from only b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from only c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from only d, pg_class where d.tableoid = pg_class.oid;

delete from a;

select relname, a.* from a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from d, pg_class where d.tableoid = pg_class.oid;

select relname, a.* from only a, pg_class where a.tableoid = pg_class.oid;

select relname, b.* from only b, pg_class where b.tableoid = pg_class.oid;

select relname, c.* from only c, pg_class where c.tableoid = pg_class.oid;

select relname, d.* from only d, pg_class where d.tableoid = pg_class.oid;

create temporary table z (
  b text,
  primary key (aa, b)
)
inherits (a);

insert into z values (null, 'text');

create temporary table z2 (
  b text,
  unique (aa, b)
)
inherits (a);

insert into z2 values (null, 'text');

create table some_tab (
  f1 int,
  f2 int,
  f3 int,
  check (f1 < 10) no inherit
);

create table some_tab_child ()
inherits (some_tab);

insert into some_tab_child
select
  i,
  i + 1,
  0
from
  generate_series(1, 1000) as i;

create index on some_tab_child using btree (f1, f2);

create function some_tab_stmt_trig_func()
returns trigger
as $function$begin raise notice 'updating some_tab'; return NULL; end;$function$
language plpgsql;

create trigger some_tab_stmt_trig
before update
on some_tab
for each statement
execute function some_tab_stmt_trig_func();

update some_tab set f3 = 11 where f1 = 12 and f2 = 13;

update some_tab set f3 = 11 where f1 = 12 and f2 = 13;

drop table some_tab cascade;

drop function some_tab_stmt_trig_func();

create table some_tab (
  a int,
  b int
);

create table some_tab_child ()
inherits (some_tab);

insert into some_tab_child values (1, 2);

update some_tab set a = a + 1 where false;

update some_tab set a = a + 1 where false;

update some_tab set a = a + 1 where false returning b, a;

update some_tab set a = a + 1 where false returning b, a;

select * from some_tab;

drop table some_tab cascade;

create temporary table foo (
  f1 int,
  f2 int
);

create temporary table foo2 (f3 int)
inherits (foo);

create temporary table bar (
  f1 int,
  f2 int
);

create temporary table bar2 (f3 int)
inherits (bar);

insert into foo values (1, 1);

insert into foo values (3, 3);

insert into foo2 values (2, 2, 2);

insert into foo2 values (3, 3, 3);

insert into bar values (1, 1);

insert into bar values (2, 2);

insert into bar values (3, 3);

insert into bar values (4, 4);

insert into bar2 values (1, 1, 1);

insert into bar2 values (2, 2, 2);

insert into bar2 values (3, 3, 3);

insert into bar2 values (4, 4, 4);

update bar set f2 = f2 + 100 where f1 in (select f1 from foo);

select
  cast(cast(tableoid as regclass) as text)
  as relname,
  bar.*
from
  bar
order by 1,
  2;

update bar
set f2 = f2 + 100
from (
  select f1 from foo
  union all
  select f1 + 3 from foo
)
as ss
where
  bar.f1 = ss.f1;

select
  cast(cast(tableoid as regclass) as text)
  as relname,
  bar.*
from
  bar
order by 1,
  2;

create table some_tab (a int);

insert into some_tab values (0);

create table some_tab_child ()
inherits (some_tab);

insert into some_tab_child values (1);

create table parted_tab (
  a int,
  b char(1)
)
partition by LIST(a);

create table parted_tab_part1 partition of parted_tab for values in (1);

create table parted_tab_part2 partition of parted_tab for values in (2);

create table parted_tab_part3 partition of parted_tab for values in (3);

insert into parted_tab values (1, 'a'), (2, 'a'), (3, 'a');

update parted_tab
set b = 'b'
from (
  select a from some_tab
  union all
  select a + 1 from some_tab
)
as ss (a)
where
  parted_tab.a = ss.a;

select
  cast(cast(tableoid as regclass) as text)
  as relname,
  parted_tab.*
from
  parted_tab
order by 1,
  2;

truncate parted_tab;

insert into parted_tab values (1, 'a'), (2, 'a'), (3, 'a');

update parted_tab
set b = 'b'
from (
  select 0 from parted_tab
  union all
  select 1 from parted_tab
)
as ss (a)
where
  parted_tab.a = ss.a;

select
  cast(cast(tableoid as regclass) as text)
  as relname,
  parted_tab.*
from
  parted_tab
order by 1,
  2;

update parted_tab set a = 2 where false;

drop table parted_tab;

create table mlparted_tab (
  a int,
  b char(1),
  c text
)
partition by LIST(a);

create table mlparted_tab_part1 partition of mlparted_tab for values in (1);

create table mlparted_tab_part2
partition of mlparted_tab
for values in (2)
partition by LIST(b);

create table mlparted_tab_part3 partition of mlparted_tab for values in (3);

create table mlparted_tab_part2a
partition of mlparted_tab_part2
for values in ('a');

create table mlparted_tab_part2b
partition of mlparted_tab_part2
for values in ('b');

insert into mlparted_tab values (1, 'a'), (2, 'a'), (2, 'b'), (3, 'a');

update mlparted_tab as mlp
set c = 'xxx'
from (
  select a from some_tab
  union all
  select a + 1 from some_tab
)
as ss (a)
where
  mlp.a = ss.a and mlp.b = 'b' or
  mlp.a = 3;

select
  cast(cast(tableoid as regclass) as text)
  as relname,
  mlparted_tab.*
from
  mlparted_tab
order by 1,
  2;

drop table mlparted_tab;

drop table some_tab cascade;

create table firstparent (tomorrow date default (cast(NOW() as date) + 1));

create table secondparent (tomorrow date default (cast(NOW() as date) + 1));

create table jointchild ()
inherits (firstparent,
secondparent);

create table thirdparent (tomorrow date default (cast(NOW() as date) - 1));

create table otherchild ()
inherits (firstparent,
thirdparent);

create table otherchild (tomorrow date default NOW())
inherits (firstparent,
thirdparent);

drop table firstparent, secondparent, jointchild, thirdparent, otherchild;

insert into d values ('test', 'one', 'two', 'three');

alter table a
  alter column aa type int using bit_length(aa);

select * from d;

create temporary table parent1 (
  f1 int,
  f2 int
);

create temporary table parent2 (
  f1 int,
  f3 bigint
);

create temporary table childtab (f4 int)
inherits (parent1,
parent2);

alter table parent1
  alter column f1 type bigint;

alter table parent1
  alter column f2 type bigint;

create table p1 (ff1 int);

alter table p1
  add constraint "p1chk" check (ff1 > 0) no inherit;

alter table p1
  add constraint "p2chk" check (ff1 > 10);

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pgc.connoinherit
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname = 'p1'
order by 1,
  2;

create table c1 ()
inherits (p1);

create table c2 (constraint "p2chk" check (ff1 > 10) no inherit)
inherits (p1);

drop table p1 cascade;

create table base (i int);

create table derived ()
inherits (base);

create table more_derived (
  like derived,
  b int
)
inherits (derived);

insert into derived (i) values (0);

select cast(derived as base) from derived;

select cast(cast(null as derived) as base);

select
  cast(cast(cast(row(i, b) as more_derived)
  as derived)
  as base)
from
  more_derived;

select cast(cast(cast((1, 2) as more_derived) as derived) as base);

drop table more_derived;

drop table derived;

drop table base;

create table p1 (ff1 int);

create table p2 (f1 text);

create function p2text(p2)
returns text
as $function$select $1.f1$function$
language sql;

create table c1 (f3 int)
inherits (p1,
p2);

insert into c1 values (123456789, 'hi', 42);

select p2text(c1.*) from c1;

drop function p2text(p2);

drop table c1;

drop table p2;

drop table p1;

create table ac (aa text);

alter table ac
  add constraint "ac_check" check (aa is not null);

create table bc (bb text)
inherits (ac);

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc')
order by 1,
  2;

insert into ac (aa) values (null);

insert into bc (aa) values (null);

alter table bc
  drop constraint ac_check;

alter table ac
  drop constraint ac_check;

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc')
order by 1,
  2;

alter table ac
  add check (aa is not null);

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc')
order by 1,
  2;

insert into ac (aa) values (null);

insert into bc (aa) values (null);

alter table bc
  drop constraint ac_aa_check;

alter table ac
  drop constraint ac_aa_check;

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc')
order by 1,
  2;

alter table ac
  add constraint "ac_check" check (aa is not null);

alter table bc
  no inherit ac;

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc')
order by 1,
  2;

alter table bc
  drop constraint ac_check;

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc')
order by 1,
  2;

alter table ac
  drop constraint ac_check;

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc')
order by 1,
  2;

drop table bc;

drop table ac;

create table ac (a int constraint "check_a" check (a <> 0));

create table bc (
  a int
  constraint "check_a" check (a <> 0),
  b int
  constraint "check_b" check (b <> 0)
)
inherits (ac);

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc')
order by 1,
  2;

drop table bc;

drop table ac;

create table ac (a int constraint "check_a" check (a <> 0));

create table bc (b int constraint "check_b" check (b <> 0));

create table cc (c int constraint "check_c" check (c <> 0))
inherits (ac,
bc);

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc', 'cc')
order by 1,
  2;

alter table cc
  no inherit bc;

select
  pc.relname,
  pgc.conname,
  pgc.contype,
  pgc.conislocal,
  pgc.coninhcount,
  pg_get_expr(pgc.conbin, pc.oid)
  as consrc
from
  pg_class as pc
  inner join
    pg_constraint as pgc
  on pgc.conrelid = pc.oid
where
  pc.relname in ('ac', 'bc', 'cc')
order by 1,
  2;

drop table cc;

drop table bc;

drop table ac;

create table p1 (f1 int);

create table p2 (f2 int);

create table c1 (f3 int)
inherits (p1,
p2);

insert into c1 values (1, -1, 2);

alter table p2
  add constraint "cc" check (f2 > 0);

alter table p2
  add check (f2 > 0);

delete from c1;

insert into c1 values (1, 1, 2);

alter table p2
  add check (f2 > 0);

insert into c1 values (1, -1, 2);

create table c2 (f3 int)
inherits (p1,
p2);

create table c3 (f4 int)
inherits (c1,
c2);

drop table p1 cascade;

drop table p2 cascade;

create table pp1 (f1 int);

create table cc1 (
  f2 text,
  f3 int
)
inherits (pp1);

alter table pp1
  add column a1 int check (a1 > 0);

create table cc2 (f4 double precision)
inherits (pp1,
cc1);

alter table pp1
  add column a2 int check (a2 > 0);

drop table pp1 cascade;

create table inht1 (
  a int,
  b int
);

create table inhs1 (
  b int,
  c int
);

create table inhts (d int)
inherits (inht1,
inhs1);

alter table inht1 rename column a to aa;

alter table inht1 rename column b to bb;

alter table inhts rename column aa to aaa;

alter table inhts rename column d to dd;

drop table inhts;

create table inhta ();

create table inhtb ()
inherits (inhta);

create table inhtc ()
inherits (inhtb);

create table inhtd ()
inherits (inhta,
inhtb,
inhtc);

alter table inhta
  add column i int,
  add column j bigint default 1;

drop table inhta, inhtb, inhtc, inhtd;

create table inht2 (x int)
inherits (inht1);

create table inht3 (y int)
inherits (inht1);

create table inht4 (z int)
inherits (inht2,
inht3);

alter table inht1 rename column aa to aaa;

create table inhts (d int)
inherits (inht2,
inhs1);

alter table inht1 rename column aaa to aaaa;

alter table inht1 rename column b to bb;

with recursive
r
as (
  select
    cast('inht1' as regclass) as inhrelid
  union all
  select
    c.inhrelid
  from
    pg_inherits as c,
    r
  where
    r.inhrelid = c.inhparent
)
select
  cast(a.attrelid as regclass),
  a.attname,
  a.attinhcount,
  e.expected
from
  (
    select
      inhrelid,
      COUNT(*) as expected
    from
      pg_inherits
    where
      inhparent in (select inhrelid from r)
    group by inhrelid
  )
  as e
  inner join
    pg_attribute as a
  on e.inhrelid = a.attrelid
where
  not attislocal
order by cast(cast(a.attrelid as regclass)
  as name),
  a.attnum;

drop table inht1, inhs1 cascade;

create table test_constraints (
  id int,
  val1 varchar,
  val2 int,
  unique (val1, val2)
);

create table test_constraints_inh ()
inherits (test_constraints);

alter table only test_constraints
  drop constraint test_constraints_val1_val2_key;

drop table test_constraints_inh;

drop table test_constraints;

create table test_ex_constraints (
  c circle,
  exclude using gist (c with &&)
);

create table test_ex_constraints_inh ()
inherits (test_ex_constraints);

alter table test_ex_constraints
  drop constraint test_ex_constraints_c_excl;

drop table test_ex_constraints_inh;

drop table test_ex_constraints;

create table test_primary_constraints (id int primary key);

create table test_foreign_constraints (
  id1 int
  references test_primary_constraints (id)
);

create table test_foreign_constraints_inh ()
inherits (test_foreign_constraints);

alter table test_foreign_constraints
  drop constraint test_foreign_constraints_id1_fkey;

drop table test_foreign_constraints_inh;

drop table test_foreign_constraints;

drop table test_primary_constraints;

create table inh_fk_1 (a int primary key);

insert into inh_fk_1 values (1), (2), (3);

create table inh_fk_2 (
  x int primary key,
  y int
  references inh_fk_1 on DELETE cascade
);

insert into inh_fk_2 values (11, 1), (22, 2), (33, 3);

create table inh_fk_2_child ()
inherits (inh_fk_2);

insert into inh_fk_2_child values (111, 1), (222, 2);

delete from inh_fk_1 where a = 1;

select * from inh_fk_1 order by 1;

select * from inh_fk_2 order by 1, 2;

drop table inh_fk_1, inh_fk_2, inh_fk_2_child;

create table p1 (f1 int);

create table p1_c1 ()
inherits (p1);

alter table p1
  add constraint "inh_check_constraint1" check (f1 > 0);

alter table p1_c1
  add constraint "inh_check_constraint1" check (f1 > 0);

alter table p1_c1
  add constraint "inh_check_constraint2" check (f1 < 10);

alter table p1
  add constraint "inh_check_constraint2" check (f1 < 10);

create table p1_c2 (f1 int constraint "inh_check_constraint4" check (f1 < 10))
inherits (p1);

create table p1_c3 ()
inherits (p1,
p1_c1);

select
  cast(cast(conrelid as regclass) as text)
  as relname,
  conname,
  conislocal,
  coninhcount,
  conenforced,
  convalidated
from
  pg_constraint
where
  conname like 'inh\_check\_constraint%'
order by 1,
  2;

drop table p1 cascade;

alter table p1_c1
  inherit p1;

drop table p1 cascade;

alter table p1_c1
  inherit p1;

drop table p1, p1_c1;

create table p1 (f1 int constraint "f1_pos" check (f1 > 0));

create table p1_c1 (f1 int constraint "f1_pos" check (f1 > 0))
inherits (p1);

alter table p1_c1
  drop constraint f1_pos;

alter table p1
  drop constraint f1_pos;

drop table p1 cascade;

create table p1 (f1 int constraint "f1_pos" check (f1 > 0));

create table p2 (f1 int constraint "f1_pos" check (f1 > 0));

create table p1p2_c1 (f1 int)
inherits (p1,
p2);

create table p1p2_c2 (f1 int constraint "f1_pos" check (f1 > 0))
inherits (p1,
p2);

alter table p2
  drop constraint f1_pos;

alter table p1
  drop constraint f1_pos;

drop table p1, p2 cascade;

create table p1 (f1 int constraint "f1_pos" check (f1 > 0));

create table p1_c1 ()
inherits (p1);

create table p1_c2 ()
inherits (p1);

create table p1_c1c2 ()
inherits (p1_c1,
p1_c2);

alter table p1
  drop constraint f1_pos;

drop table p1 cascade;

create table p1 (f1 int constraint "f1_pos" check (f1 > 0));

create table p1_c1 ()
inherits (p1);

create table p1_c2 (constraint "f1_pos" check (f1 > 0))
inherits (p1);

create table p1_c1c2 ()
inherits (p1_c1,
p1_c2,
p1);

alter table p1_c2
  drop constraint f1_pos;

alter table p1
  drop constraint f1_pos;

alter table p1_c1c2
  drop constraint f1_pos;

alter table p1_c2
  drop constraint f1_pos;

drop table p1 cascade;

create table invalid_check_con (f1 int);

create table invalid_check_con_child ()
inherits (invalid_check_con);

alter table invalid_check_con_child
  add constraint "inh_check_constraint" check (f1 > 0) not valid;

alter table invalid_check_con
  add constraint "inh_check_constraint" check (f1 > 0);

alter table invalid_check_con_child
  drop constraint inh_check_constraint;

insert into invalid_check_con values (0);

alter table invalid_check_con_child
  add constraint "inh_check_constraint" check (f1 > 0);

alter table invalid_check_con
  add constraint "inh_check_constraint" check (f1 > 0) not valid;

insert into invalid_check_con values (0);

insert into invalid_check_con_child values (0);

select
  cast(cast(conrelid as regclass) as text)
  as relname,
  conname,
  convalidated,
  conislocal,
  coninhcount,
  connoinherit
from
  pg_constraint
where
  conname like 'inh\_check\_constraint%'
order by 1,
  2;

create temporary table patest0 (id,
x)
as
  select
    x,
    x
  from
    generate_series(0, 1000) as x;

create temporary table patest1 ()
inherits (patest0);

insert into patest1 select x, x from generate_series(0, 1000) as x;

create temporary table patest2 ()
inherits (patest0);

insert into patest2 select x, x from generate_series(0, 1000) as x;

create index "patest0i" on patest0 using btree (id);

create index "patest1i" on patest1 using btree (id);

create index "patest2i" on patest2 using btree (id);

analyze patest0;

analyze patest1;

analyze patest2;

select
  *
from
  patest0
  inner join
    (select f1 from int4_tbl limit 1) as ss
  on id = f1;

select
  *
from
  patest0
  inner join
    (select f1 from int4_tbl limit 1) as ss
  on id = f1;

drop index patest2i;

select
  *
from
  patest0
  inner join
    (select f1 from int4_tbl limit 1) as ss
  on id = f1;

select
  *
from
  patest0
  inner join
    (select f1 from int4_tbl limit 1) as ss
  on id = f1;

drop table patest0 cascade;

create table matest0 (
  id serial primary key,
  name text
);

create table matest1 (id int primary key)
inherits (matest0);

create table matest2 (id int primary key)
inherits (matest0);

create table matest3 (id int primary key)
inherits (matest0);

create index "matest0i" on matest0 using btree ((1 - id));

create index "matest1i" on matest1 using btree ((1 - id));

create index "matest3i" on matest3 using btree ((1 - id));

insert into matest1 (name) values ('Test 1');

insert into matest1 (name) values ('Test 2');

insert into matest2 (name) values ('Test 3');

insert into matest2 (name) values ('Test 4');

insert into matest3 (name) values ('Test 5');

insert into matest3 (name) values ('Test 6');

set enable_indexscan = off;

select * from matest0 order by 1 - id;

select * from matest0 order by 1 - id;

select MIN(1 - id) from matest0;

select MIN(1 - id) from matest0;

reset enable_indexscan;

set enable_seqscan = off;

set enable_parallel_append = off;

select * from matest0 order by 1 - id;

select * from matest0 order by 1 - id;

select MIN(1 - id) from matest0;

select MIN(1 - id) from matest0;

reset enable_seqscan;

reset enable_parallel_append;

select
  1 - id as c
from
  (
    select id from matest3 as t1
    union all
    select id * 2 from matest3 as t2
  )
  as ss
order by c;

select
  1 - id as c
from
  (
    select id from matest3 as t1
    union all
    select id * 2 from matest3 as t2
  )
  as ss
order by c;

drop table matest0 cascade;

create table matest0 (
  a int,
  b int,
  c int,
  d int
);

create table matest1 ()
inherits (matest0);

create index "matest0i" on matest0 using btree (b, c);

create index "matest1i" on matest1 using btree (b, c);

set enable_nestloop = off;

select
  t1.*
from
  matest0 as t1,
  matest0 as t2
where
  t1.b = t2.b and t2.c = t2.d
order by t1.b
limit 10;

reset enable_nestloop;

drop table matest0 cascade;

create table matest0 (a int primary key);

create table matest1 ()
inherits (matest0);

insert into matest0 select generate_series(1, 400);

insert into matest1 select generate_series(1, 200);

analyze matest0;

analyze matest1;

select * from matest0 where a < 100 order by a;

drop table matest0 cascade;

set enable_seqscan = off;

set enable_indexscan = 'on';

set enable_bitmapscan = off;

select thousand, tenthous from tenk1
union all
select thousand, thousand from tenk1
order by thousand,
  tenthous;

select
  thousand,
  tenthous,
  thousand + tenthous as x
from
  tenk1
union all
select 42, 42, hundred from tenk1
order by thousand,
  tenthous;

select thousand, tenthous from tenk1
union all
select
  thousand,
  cast(random() as int)
from
  tenk1
order by thousand,
  tenthous;

select
  MIN(x)
from
  (
    select unique1 as x from tenk1 as a
    union all
    select unique2 as x from tenk1 as b
  )
  as s;

select
  MIN(y)
from
  (
    select
      unique1 as x,
      unique1 as y
    from
      tenk1 as a
    union all
    select
      unique2 as x,
      unique2 as y
    from
      tenk1 as b
  )
  as s;

select
  x,
  y
from
  (
    select
      thousand as x,
      tenthous as y
    from
      tenk1 as a
    union all
    select
      unique2 as x,
      unique2 as y
    from
      tenk1 as b
  )
  as s
order by x,
  y;

select
  array(
    select
      f.i
    from
      (
        (select
          d + g.i
        from
          generate_series(4, 30, 3) as d
        order by 1)
        union all
        (select
          d + g.i
        from
          generate_series(0, 30, 5) as d
        order by 1)
      )
      as f (i)
    order by f.i
    limit 10
  )
from
  generate_series(1, 3) as g (i);

select
  array(
    select
      f.i
    from
      (
        (select
          d + g.i
        from
          generate_series(4, 30, 3) as d
        order by 1)
        union all
        (select
          d + g.i
        from
          generate_series(0, 30, 5) as d
        order by 1)
      )
      as f (i)
    order by f.i
    limit 10
  )
from
  generate_series(1, 3) as g (i);

reset enable_seqscan;

reset enable_indexscan;

reset enable_bitmapscan;

create table inhpar (
  f1 int,
  f2 name
);

create table inhcld (
  f2 name,
  f1 int
);

alter table inhcld
  inherit inhpar;

insert into inhpar select x, cast(x as text) from generate_series(1, 5) as x;

insert into inhcld select cast(x as text), x from generate_series(6, 10) as x;

update inhpar as i
set (f1, f2) = (
  select
    i.f1,
    i.f2 || '-'
  from
    int4_tbl
  limit 1
);

update inhpar as i
set (f1, f2) = (
  select
    i.f1,
    i.f2 || '-'
  from
    int4_tbl
  limit 1
);

select * from inhpar;

drop table inhpar cascade;

create table inhpar (
  f1 int primary key,
  f2 name
)
partition by range(f1);

create table inhcld1 (
  f2 name,
  f1 int primary key
);

create table inhcld2 (
  f1 int primary key,
  f2 name
);

alter table inhpar
  attach partition
  inhcld1 for values from (1) to (5);

alter table inhpar
  attach partition
  inhcld2 for values from (5) to (100);

insert into inhpar select x, cast(x as text) from generate_series(1, 10) as x;

update inhpar as i
set (f1, f2) = (
  select
    i.f1,
    i.f2 || '-'
  from
    int4_tbl
  limit 1
);

update inhpar as i
set (f1, f2) = (
  select
    i.f1,
    i.f2 || '-'
  from
    int4_tbl
  limit 1
);

select * from inhpar;

insert into inhpar as i
values (3), (7)
on conflict
(f1)
do
update
set (f1, f2) = (select i.f1, i.f2 || '+');

select * from inhpar order by f1;

drop table inhpar cascade;

create table cnullparent (f1 int);

create table cnullchild (check (f1 = 1 or f1 = null))
inherits (cnullparent);

insert into cnullchild values (1);

insert into cnullchild values (2);

insert into cnullchild values (null);

select * from cnullparent;

select * from cnullparent where f1 = 2;

drop table cnullparent cascade;

create table pp1 (f1 int);

create table cc1 (
  f2 text,
  f3 int
)
inherits (pp1);

create table cc2 (f4 double precision)
inherits (pp1,
cc1);

create table cc3 ()
inherits (pp1,
cc1,
cc2);

alter table pp1
  alter column f1 set not null;

alter table cc3
  no inherit pp1;

alter table cc3
  no inherit cc1;

alter table cc3
  no inherit cc2;

drop table cc3;

alter table cc1
  add column a2 int constraint "nn" not null;

alter table pp1
  alter column f1 set not null;

alter table cc2
  alter column a2 drop not null;

alter table cc1
  alter column a2 drop not null;

alter table cc2
  alter column f1 drop not null;

alter table cc1
  alter column f1 drop not null;

alter table pp1
  alter column f1 drop not null;

alter table pp1
  add primary key (f1);

alter table inh_child
  inherit inh_parent;

alter table inh_child
  no inherit inh_parent;

drop table inh_parent, inh_child;

create table inh_pp1 (f1 int);

create table inh_cc1 (
  f2 text,
  f3 int
)
inherits (inh_pp1);

create table inh_cc2 (f4 double precision)
inherits (inh_pp1,
inh_cc1);

alter table inh_pp1
  alter column f1 set not null;

alter table inh_cc2
  no inherit inh_pp1;

alter table inh_cc2
  no inherit inh_cc1;

drop table inh_pp1, inh_cc1, inh_cc2;

create table inh_pp1 (f1 int not null);

create table inh_cc1 (
  f2 text,
  f3 int
)
inherits (inh_pp1);

create table inh_cc2 (f4 double precision)
inherits (inh_pp1,
inh_cc1);

alter table inh_pp1
  alter column f1 drop not null;

drop table inh_pp1, inh_cc1, inh_cc2;

create table inh_parent ();

create table inh_child (i int)
inherits (inh_parent);

create table inh_grandchild ()
inherits (inh_parent,
inh_child);

alter table inh_parent
  add column i int not null;

drop table inh_parent, inh_child, inh_grandchild;

create table inh_parent1 (a int constraint "nn" not null);

create table inh_parent2 (b int constraint "nn" not null);

create table inh_child1 ()
inherits (inh_parent1,
inh_parent2);

alter table inh_child2
  no inherit inh_parent2;

drop table inh_parent1, inh_parent2, inh_child1, inh_child2;

create table inh_parent1 (
  a int,
  b int,
  c int,
  primary key (a, b)
);

create table inh_parent2 (
  d int,
  e int,
  b int,
  primary key (d, b)
);

create table inh_child ()
inherits (inh_parent1,
inh_parent2);

select
  cast(conrelid as regclass),
  conname,
  contype,
  conkey,
  coninhcount,
  conislocal,
  connoinherit
from
  pg_constraint
where
  contype in ('n', 'p') and
  cast(cast(conrelid as regclass) as text)
  in (
    'inh_child',
    'inh_parent1',
    'inh_parent2'
  )
order by 1,
  2;

drop table inh_parent1, inh_parent2, inh_child;

create table inh_nn_parent (a int);

create table inh_nn_child ()
inherits (inh_nn_parent);

create table inh_nn_child2 ()
inherits (inh_nn_parent);

select
  cast(conrelid as regclass),
  conname,
  contype,
  conkey,
  (
    select
      attname
    from
      pg_attribute
    where
      attrelid = conrelid and
      attnum = conkey[1]
  ),
  coninhcount,
  conislocal,
  connoinherit
from
  pg_constraint
where
  contype = 'n' and
  cast(cast(conrelid as regclass) as text) like 'inh\_nn\_%'
order by 2,
  1;

drop table inh_nn_parent, inh_nn_child, inh_nn_child2;

create table inh_nn_child ()
inherits (inh_nn_parent);

alter table inh_nn_parent
  alter column a set not null;

drop table inh_nn_parent cascade;

create table inh_nn_lvl1 (a int);

create table inh_nn_lvl2 ()
inherits (inh_nn_lvl1);

alter table inh_nn_lvl1
  add primary key (a);

drop table inh_nn_lvl1, inh_nn_lvl2, inh_nn_lvl3;

create table inh_nn1 (a int not null);

drop table if exists inh_nn1, inh_nn2, inh_nn3, inh_nn4;

create table inh_parent (f1 int);

create table inh_child1 (f1 int not null);

create table inh_child2 (f1 int);

alter table inh_child1
  inherit inh_parent;

alter table inh_child2
  inherit inh_child1;

alter table inh_child2
  alter column f1 set not null;

alter table inh_child2
  inherit inh_child1;

alter table inh_parent
  alter column f1 set not null;

select
  cast(conrelid as regclass),
  conname,
  contype,
  coninhcount,
  conislocal
from
  pg_constraint
where
  contype = 'n' and
  conrelid
  in (
    cast('inh_parent' as regclass),
    cast('inh_child1' as regclass),
    cast('inh_child2' as regclass)
  )
order by 2,
  1;

create table inh_child3 ()
inherits (inh_child1);

alter table inh_child1
  no inherit inh_parent;

select
  cast(conrelid as regclass),
  conname,
  contype,
  coninhcount,
  conislocal
from
  pg_constraint
where
  contype = 'n' and
  cast(cast(conrelid as regclass) as text)
  in (
    'inh_parent',
    'inh_child1',
    'inh_child2',
    'inh_child3'
  )
order by 2,
  1;

drop table inh_parent, inh_child1, inh_child2, inh_child3;

create table inh_parent (a int not null);

create table inh_child (a int);

alter table inh_child
  inherit inh_parent;

drop table inh_parent, inh_child;

create table inh_parent (a int not null);

alter table inh_child
  inherit inh_parent;

drop table inh_parent, inh_child;

create table inh_parent (a int primary key);

create table inh_child (a int primary key)
inherits (inh_parent);

alter table inh_parent
  add constraint "inh_parent_excl" exclude using btree ((1) with =);

alter table inh_parent
  add constraint "inh_parent_uq" unique (a);

alter table inh_parent
  add constraint "inh_parent_fk"
  foreign key
  (a)
  references inh_parent (a);

create table inh_child2 ()
inherits (inh_parent);

create table inh_child3 (like inh_parent);

alter table inh_child3
  inherit inh_parent;

select
  cast(conrelid as regclass),
  conname,
  contype,
  coninhcount,
  conislocal
from
  pg_constraint
where
  cast(cast(conrelid as regclass) as text)
  in (
    'inh_parent',
    'inh_child',
    'inh_child2',
    'inh_child3'
  )
order by 2,
  1;

drop table inh_parent, inh_child, inh_child2, inh_child3;

create table inh_parent (f1 int not null);

create table inh_child1 ()
inherits (inh_parent);

create table inh_child2 ()
inherits (inh_parent);

create table inh_child3 ()
inherits (inh_child1,
inh_child2);

select
  cast(conrelid as regclass),
  conname,
  contype,
  coninhcount,
  conislocal
from
  pg_constraint
where
  contype = 'n' and
  conrelid
  in (
    cast('inh_parent' as regclass),
    cast('inh_child1' as regclass),
    cast('inh_child2' as regclass),
    cast('inh_child3' as regclass)
  )
order by 2,
  cast(cast(conrelid as regclass) as text);

drop table inh_parent cascade;

create table inh_parent_1 (f1 int);

create table inh_parent_2 (f2 text);

create table inh_child (
  f1 int not null,
  f2 text not null
)
inherits (inh_parent_1,
inh_parent_2);

select
  cast(conrelid as regclass),
  conname,
  contype,
  coninhcount,
  conislocal
from
  pg_constraint
where
  contype = 'n' and
  conrelid
  in (
    cast('inh_parent_1' as regclass),
    cast('inh_parent_2' as regclass),
    cast('inh_child' as regclass)
  )
order by 2,
  cast(cast(conrelid as regclass) as text);

drop table inh_parent_1 cascade;

drop table inh_parent_2;

create table inh_p1 (f1 int not null);

create table inh_p2 (f1 int not null);

create table inh_p3 (f2 int);

create table inh_p4 (
  f1 int not null,
  f3 text not null
);

create table inh_multiparent ()
inherits (inh_p1,
inh_p2,
inh_p3,
inh_p4);

select
  cast(conrelid as regclass),
  contype,
  conname,
  (
    select
      attname
    from
      pg_attribute
    where
      attrelid = conrelid and
      attnum = conkey[1]
  ),
  coninhcount,
  conislocal
from
  pg_constraint
where
  contype = 'n' and
  cast(conrelid as regclass)
  in (
    'inh_p1',
    'inh_p2',
    'inh_p3',
    'inh_p4',
    'inh_multiparent'
  )
order by cast(cast(conrelid as regclass) as text),
  conname;

create table inh_multiparent2 (
  a int not null,
  f1 int
)
inherits (inh_p3,
inh_multiparent);

select
  cast(conrelid as regclass),
  contype,
  conname,
  (
    select
      attname
    from
      pg_attribute
    where
      attrelid = conrelid and
      attnum = conkey[1]
  ),
  coninhcount,
  conislocal
from
  pg_constraint
where
  contype = 'n' and
  cast(conrelid as regclass)
  in (
    'inh_p3',
    'inh_multiparent',
    'inh_multiparent2'
  )
order by cast(cast(conrelid as regclass) as text),
  conname;

drop table inh_p1, inh_p2, inh_p3, inh_p4 cascade;

create table inh_nn2 (
  f2 text,
  f3 int,
  f1 int
);

alter table inh_nn2
  inherit inh_nn1;

create table inh_nn3 (f4 double precision)
inherits (inh_nn2);

create table inh_nn4 (
  f5 int,
  f4 double precision,
  f2 text,
  f3 int,
  f1 int
);

alter table inh_nn4
  inherit inh_nn2,
  inherit inh_nn1,
  inherit inh_nn3;

select
  cast(conrelid as regclass),
  conname,
  conkey,
  coninhcount,
  conislocal,
  connoinherit
from
  pg_constraint
where
  contype = 'n' and
  cast(cast(conrelid as regclass) as text)
  in (
    'inh_nn1',
    'inh_nn2',
    'inh_nn3',
    'inh_nn4'
  )
order by 2,
  1;

select
  cast(conrelid as regclass),
  conname,
  conkey,
  coninhcount,
  conislocal,
  connoinherit
from
  pg_constraint
where
  contype = 'n' and
  cast(cast(conrelid as regclass) as text)
  in (
    'inh_nn1',
    'inh_nn2',
    'inh_nn3',
    'inh_nn4'
  )
order by 2,
  1;

alter table inh_nn1
  drop constraint inh_nn1_f1_not_null;

select
  cast(conrelid as regclass),
  conname,
  coninhcount,
  conislocal,
  connoinherit
from
  pg_constraint
where
  contype = 'n' and
  cast(cast(conrelid as regclass) as text)
  in (
    'inh_nn1',
    'inh_nn2',
    'inh_nn3',
    'inh_nn4'
  )
order by 2,
  1;

drop table inh_nn1, inh_nn2, inh_nn3, inh_nn4;

create table inh_nn2 (
  f2 text,
  f3 int
)
inherits (inh_nn1);

insert into inh_nn2 values (null, 'sample', 1);

delete from inh_nn2;

create table inh_nn3 ()
inherits (inh_nn2);

create table inh_nn4 ()
inherits (inh_nn1,
inh_nn2);

select
  cast(conrelid as regclass),
  conname,
  coninhcount,
  conislocal,
  connoinherit
from
  pg_constraint
where
  contype = 'n' and
  cast(cast(conrelid as regclass) as text)
  in (
    'inh_nn1',
    'inh_nn2',
    'inh_nn3',
    'inh_nn4'
  )
order by 2,
  1;

drop table inh_nn1, inh_nn2, inh_nn3, inh_nn4;

create table inh_nn2 (
  f2 text,
  f3 int
)
inherits (inh_nn1);

select
  cast(conrelid as regclass),
  conname,
  conkey,
  coninhcount,
  conislocal,
  connoinherit
from
  pg_constraint
where
  contype = 'n' and
  cast(cast(conrelid as regclass) as text)
  in (
    'inh_nn1', 'inh_nn2', 'inh_nn3'
  )
order by 2,
  1;

select
  cast(conrelid as regclass),
  conname,
  conkey,
  coninhcount,
  conislocal,
  connoinherit
from
  pg_constraint
where
  contype = 'n' and
  cast(cast(conrelid as regclass) as text)
  in (
    'inh_nn1', 'inh_nn2', 'inh_nn3'
  )
order by 2,
  1;

drop table inh_nn1, inh_nn2, inh_nn3;

create table inh_nn1 (
  f1 int
  check (f1 > 5)
  primary key
  references inh_nn1,
  f2 int not null
);

create table inh_nn2 ()
inherits (inh_nn1);

drop table inh_nn1, inh_nn2;

create role regress_alice;

create role regress_bob;

grant all on schema public to regress_alice, regress_bob;

grant REGRESS_ALICE to regress_bob;

set session authorization regress_alice;

create table inh_parent (a int not null);

set session authorization regress_bob;

create table inh_child ()
inherits (inh_parent);

set session authorization regress_alice;

alter table inh_parent
  alter column a drop not null;

set session authorization regress_bob;

alter table inh_parent
  alter column a drop not null;

reset session_authorization;

drop table inh_parent, inh_child;

revoke all on schema public from regress_alice, regress_bob;

drop role regress_alice, regress_bob;

create table inh_perm_parent (a1 int);

create temporary table inh_temp_parent (a1 int);

create temporary table inh_temp_child ()
inherits (inh_perm_parent);

create table inh_perm_child ()
inherits (inh_temp_parent);

create temporary table inh_temp_child_2 ()
inherits (inh_temp_parent);

insert into inh_perm_parent values (1);

insert into inh_temp_parent values (2);

insert into inh_temp_child values (3);

insert into inh_temp_child_2 values (4);

select cast(tableoid as regclass), a1 from inh_perm_parent;

select cast(tableoid as regclass), a1 from inh_temp_parent;

drop table inh_perm_parent cascade;

drop table inh_temp_parent cascade;

create table list_parted (a varchar)
partition by LIST(a);

create table part_ab_cd partition of list_parted for values in ('ab', 'cd');

create table part_ef_gh partition of list_parted for values in ('ef', 'gh');

create table part_null_xy partition of list_parted for values in (null, 'xy');

select * from list_parted;

select * from list_parted where a is null;

select * from list_parted where a is not null;

select * from list_parted where a in ('ab', 'cd', 'ef');

select * from list_parted where a = 'ab' or a in (null, 'cd');

select * from list_parted where a = 'ab';

create table range_list_parted (
  a int,
  b char(2)
)
partition by range(a);

create table part_1_10
partition of range_list_parted
for values from (1) to (10)
partition by LIST(b);

create table part_1_10_ab partition of part_1_10 for values in ('ab');

create table part_1_10_cd partition of part_1_10 for values in ('cd');

create table part_10_20
partition of range_list_parted
for values from (10) to (20)
partition by LIST(b);

create table part_10_20_ab partition of part_10_20 for values in ('ab');

create table part_10_20_cd partition of part_10_20 for values in ('cd');

create table part_21_30
partition of range_list_parted
for values from (21) to (30)
partition by LIST(b);

create table part_21_30_ab partition of part_21_30 for values in ('ab');

create table part_21_30_cd partition of part_21_30 for values in ('cd');

create table part_40_inf
partition of range_list_parted
for values from (40) to (maxvalue)
partition by LIST(b);

create table part_40_inf_ab partition of part_40_inf for values in ('ab');

create table part_40_inf_cd partition of part_40_inf for values in ('cd');

create table part_40_inf_null partition of part_40_inf for values in (null);

select * from range_list_parted;

select * from range_list_parted where a = 5;

select * from range_list_parted where b = 'ab';

select * from range_list_parted where a between 3 and 23 and b in ('ab');

select * from range_list_parted where a is null;

select * from range_list_parted where b is null;

select * from range_list_parted where a is not null and a < 67;

select * from range_list_parted where a >= 30;

drop table list_parted;

drop table range_list_parted;

create table mcrparted (
  a int,
  b int,
  c int
)
partition by range(a, (abs(b)), c);

create table mcrparted_def partition of mcrparted default;

create table mcrparted0
partition of mcrparted
for values from (minvalue,
minvalue,
minvalue) to (1,
1,
1);

create table mcrparted1
partition of mcrparted
for values from (1, 1, 1) to (10, 5, 10);

create table mcrparted2
partition of mcrparted
for values from (10,
5,
10) to (10,
10,
10);

create table mcrparted3
partition of mcrparted
for values from (11,
1,
1) to (20,
10,
10);

create table mcrparted4
partition of mcrparted
for values from (20,
10,
10) to (20,
20,
20);

create table mcrparted5
partition of mcrparted
for values from (20,
20,
20) to (maxvalue,
maxvalue,
maxvalue);

select * from mcrparted where a = 0;

select * from mcrparted where a = 10 and abs(b) < 5;

select * from mcrparted where a = 10 and abs(b) = 5;

select * from mcrparted where abs(b) = 5;

select * from mcrparted where a > -1;

select * from mcrparted where a = 20 and abs(b) = 10 and c > 10;

select * from mcrparted where a = 20 and c > 20;

create table parted_minmax (
  a int,
  b varchar(16)
)
partition by range(a);

create table parted_minmax1
partition of parted_minmax
for values from (1) to (10);

create index "parted_minmax1i" on parted_minmax1 using btree (a, b);

insert into parted_minmax values (1, '12345');

select MIN(a), MAX(a) from parted_minmax where b = '12345';

select MIN(a), MAX(a) from parted_minmax where b = '12345';

drop table parted_minmax;

create index "mcrparted_a_abs_c_idx" on mcrparted using btree (a, (abs(b)), c);

select * from mcrparted order by a, abs(b), c;

drop table mcrparted_def;

select * from mcrparted order by a, abs(b), c;

select * from mcrparted order by a desc, abs(b) desc, c desc;

drop table mcrparted5;

create table mcrparted5
partition of mcrparted
for values from (20,
20,
20) to (maxvalue,
maxvalue,
maxvalue)
partition by LIST(a);

create table mcrparted5a partition of mcrparted5 for values in (20);

create table mcrparted5_def partition of mcrparted5 default;

select * from mcrparted order by a, abs(b), c;

drop table mcrparted5_def;

select a, abs(b) from mcrparted order by a, abs(b), c;

select * from mcrparted where a < 20 order by a, abs(b), c;

set enable_bitmapscan = off;

set enable_sort = off;

create table mclparted (a int)
partition by LIST(a);

create table mclparted1 partition of mclparted for values in (1);

create table mclparted2 partition of mclparted for values in (2);

create index on mclparted using btree (a);

select * from mclparted order by a;

create table mclparted3_5 partition of mclparted for values in (3, 5);

create table mclparted4 partition of mclparted for values in (4);

select * from mclparted order by a;

select * from mclparted where a in (3, 4, 5) order by a;

create table mclparted_null partition of mclparted for values in (null);

create table mclparted_def partition of mclparted default;

select * from mclparted where a in (1, 2, 4) order by a;

select * from mclparted where a in (1, 2, 4) or a is null order by a;

drop table mclparted_null;

create table mclparted_0_null partition of mclparted for values in (0, null);

select * from mclparted where a in (1, 2, 4) or a is null order by a;

select * from mclparted where a in (0, 1, 2, 4) order by a;

select * from mclparted where a in (1, 2, 4) order by a;

select * from mclparted where a in (1, 2, 4, 100) order by a;

drop table mclparted;

reset enable_sort;

reset enable_bitmapscan;

drop index mcrparted_a_abs_c_idx;

create index on mcrparted1 using btree (a, (abs(b)), c);

create index on mcrparted2 using btree (a, (abs(b)), c);

create index on mcrparted3 using btree (a, (abs(b)), c);

create index on mcrparted4 using btree (a, (abs(b)), c);

select * from mcrparted where a < 20 order by a, abs(b), c limit 1;

set enable_bitmapscan = 0;

select * from mcrparted where a = 10 order by a, abs(b), c;

reset enable_bitmapscan;

drop table mcrparted;

create table bool_lp (b boolean)
partition by LIST(b);

create table bool_lp_true partition of bool_lp for values in (true);

create table bool_lp_false partition of bool_lp for values in (false);

create index on bool_lp using btree (b);

select * from bool_lp order by b;

drop table bool_lp;

create table bool_rp (
  b boolean,
  a int
)
partition by range(b, a);

create table bool_rp_false_1k
partition of bool_rp
for values from (false,
0) to (false,
1000);

create table bool_rp_true_1k
partition of bool_rp
for values from (true,
0) to (true,
1000);

create table bool_rp_false_2k
partition of bool_rp
for values from (false,
1000) to (false,
2000);

create table bool_rp_true_2k
partition of bool_rp
for values from (true,
1000) to (true,
2000);

create index on bool_rp using btree (b, a);

select * from bool_rp where b = true order by b, a;

select * from bool_rp where b = false order by b, a;

select * from bool_rp where b = true order by a;

select * from bool_rp where b = false order by a;

drop table bool_rp;

create table range_parted (
  a int,
  b int,
  c int
)
partition by range(a, b);

create table range_parted1
partition of range_parted
for values from (0, 0) to (10, 10);

create table range_parted2
partition of range_parted
for values from (10, 10) to (20, 20);

create index on range_parted using btree (a, b, c);

select * from range_parted order by a, b, c;

select * from range_parted order by a desc, b desc, c desc;

drop table range_parted;

create table permtest_parent (
  a int,
  b text,
  c text
)
partition by LIST(a);

create table permtest_child (
  b text,
  c text,
  a int
)
partition by LIST(b);

create table permtest_grandchild (
  c text,
  b text,
  a int
);

alter table permtest_child
  attach partition
  permtest_grandchild for values in ('a');

alter table permtest_parent
  attach partition
  permtest_child for values in (1);

create index on permtest_parent using btree ((left(c, 3)));

insert into permtest_parent
select
  1,
  'a',
  left(fipshash(cast(i as text)), 5)
from
  generate_series(0, 100) as i;

analyze permtest_parent;

create role regress_no_child_access;

revoke all on table permtest_grandchild from regress_no_child_access;

grant SELECT on table permtest_parent to regress_no_child_access;

set session authorization regress_no_child_access;

select
  *
from
  permtest_parent as p1
  inner join
    permtest_parent as p2
  on p1.a = p2.a and p1.c ~ 'a1$';

select
  *
from
  permtest_parent as p1
  inner join
    permtest_parent as p2
  on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';

reset session_authorization;

revoke all on table permtest_parent from regress_no_child_access;

grant SELECT (a, c) on table permtest_parent to regress_no_child_access;

set session authorization regress_no_child_access;

select
  p2.a,
  p1.c
from
  permtest_parent as p1
  inner join
    permtest_parent as p2
  on p1.a = p2.a and p1.c ~ 'a1$';

select
  p2.a,
  p1.c
from
  permtest_parent as p1
  inner join
    permtest_parent as p2
  on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';

reset session_authorization;

revoke all on table permtest_parent from regress_no_child_access;

drop role regress_no_child_access;

drop table permtest_parent;

create table errtst_parent (
  partid int not null,
  shdata int not null,
  data int not null default 0,
  constraint "shdata_small" check (shdata < 3)
)
partition by range(partid);

create table errtst_child_fastdef (
  partid int not null,
  shdata int not null,
  constraint "shdata_small" check (shdata < 3)
);

create table errtst_child_plaindef (
  partid int not null,
  shdata int not null,
  data int not null default 0,
  constraint "shdata_small" check (shdata < 3),
  check (data < 10)
);

create table errtst_child_reorder (
  data int not null default 0,
  shdata int not null,
  partid int not null,
  constraint "shdata_small" check (shdata < 3),
  check (data < 10)
);

alter table errtst_child_fastdef
  add column data int not null default 0;

alter table errtst_child_fastdef
  add constraint "errtest_child_fastdef_data_check" check (data < 10);

alter table errtst_parent
  attach partition
  errtst_child_fastdef
  for values from (0) to (10);

alter table errtst_parent
  attach partition
  errtst_child_plaindef
  for values from (10) to (20);

alter table errtst_parent
  attach partition
  errtst_child_reorder
  for values from (20) to (30);

insert into errtst_parent (partid, shdata, data) values ('0', '1', '5');

insert into errtst_parent (partid, shdata, data) values ('10', '1', '5');

insert into errtst_parent (partid, shdata, data) values ('20', '1', '5');

insert into errtst_parent (partid, shdata, data) values ('0', '1', '10');

insert into errtst_parent (partid, shdata, data) values ('10', '1', '10');

insert into errtst_parent (partid, shdata, data) values ('20', '1', '10');

insert into errtst_parent (partid, shdata, data) values ('0', '1', null);

insert into errtst_parent (partid, shdata, data) values ('10', '1', null);

insert into errtst_parent (partid, shdata, data) values ('20', '1', null);

insert into errtst_parent (partid, shdata, data) values ('0', '5', '5');

insert into errtst_parent (partid, shdata, data) values ('10', '5', '5');

insert into errtst_parent (partid, shdata, data) values ('20', '5', '5');

begin;

update errtst_parent set data = data + 1 where partid = 0;

update errtst_parent set data = data + 1 where partid = 10;

update errtst_parent set data = data + 1 where partid = 20;

rollback;

update errtst_parent set data = data + 10 where partid = 0;

update errtst_parent set data = data + 10 where partid = 10;

update errtst_parent set data = data + 10 where partid = 20;

begin;

update errtst_child_fastdef set partid = 1 where partid = 0;

update errtst_child_plaindef set partid = 11 where partid = 10;

update errtst_child_reorder set partid = 21 where partid = 20;

rollback;

update errtst_child_fastdef set partid = partid + 10 where partid = 0;

update errtst_child_plaindef set partid = partid + 10 where partid = 10;

update errtst_child_reorder set partid = partid + 10 where partid = 20;

begin;

update errtst_parent set partid = 10, data = data + 1 where partid = 0;

update errtst_parent set partid = 20, data = data + 1 where partid = 10;

update errtst_parent set partid = 0, data = data + 1 where partid = 20;

rollback;

update errtst_parent set partid = 10, data = data + 10 where partid = 0;

update errtst_parent set partid = 20, data = data + 10 where partid = 10;

update errtst_parent set partid = 0, data = data + 10 where partid = 20;

update errtst_parent set partid = 30, data = data + 10 where partid = 20;

drop table errtst_parent;

create table tuplesest_parted (
  a int,
  b int,
  c double precision
)
partition by range(a);

create table tuplesest_parted1
partition of tuplesest_parted
for values from (0) to (100);

create table tuplesest_parted2
partition of tuplesest_parted
for values from (100) to (200);

create table tuplesest_tab (
  a int,
  b int
);

insert into tuplesest_parted
select
  i % 200,
  i % 300,
  i % 400
from
  generate_series(1, 1000) as i;

insert into tuplesest_tab select i, i from generate_series(1, 100) as i;

analyze tuplesest_parted;

analyze tuplesest_tab;

select
  *
from
  tuplesest_tab
  inner join
    (
      select
        b
      from
        tuplesest_parted
      where
        c < 100
      group by b
    )
    as sub
  on tuplesest_tab.a = sub.b;

drop table tuplesest_parted;

drop table tuplesest_tab;
