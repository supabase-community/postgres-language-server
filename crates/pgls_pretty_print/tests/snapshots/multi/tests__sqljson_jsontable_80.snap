---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/sqljson_jsontable.sql
snapshot_kind: text
---
select
  *
from
  JSON_TABLE(
    '[]',
    'strict $.a'
    COLUMNS (
      js2 INT PATH '$'
    )
    default 1 on ERROR
  );

select
  *
from
  JSON_TABLE(
    '[]',
    'strict $.a'
    COLUMNS (
      js2 INT PATH '$'
    )
    null on ERROR
  );

select
  *
from
  JSON_TABLE(
    '[]',
    'strict $.a'
    COLUMNS (
      js2 INT PATH '$'
    )
    EMPTY array on ERROR
  );

select
  *
from
  JSON_TABLE(
    '[]',
    'strict $.a'
    COLUMNS (
      js2 INT PATH '$'
    )
    ERROR on ERROR
  );

select
  *
from
  JSON_TABLE(
    cast('"1.23"' as JSONB),
    '$.a' as js2
    COLUMNS (
      js2 INT PATH '$'
    )
  );

select
  *
from
  JSON_TABLE(
    cast(null as JSONB),
    '$'
    COLUMNS (
      v1 TIMESTAMP
    )
  ) as f (v1, v2);

select
  *
from
  JSON_TABLE(
    cast('"1.23"' as JSONB),
    '$.a'
    COLUMNS (
      js2 INT PATH '$',
      js2 INT PATH '$'
    )
  );

create type comp as (a INT, b INT);

select
  *
from
  JSON_TABLE(
    cast('{"rec": "(1,2)"}' as JSONB),
    '$'
    COLUMNS (
      id for ORDINALITY,
      comp comp PATH '$.rec' OMIT QUOTES
    )
  ) as jt;

drop TYPE comp;

select * from JSON_TABLE( cast(null as JSONB), '$' COLUMNS (foo INT ) ) as bar;

select
  *
from
  JSON_TABLE(
    cast('"1.23"' as JSONB),
    'strict $.a'
    COLUMNS (
      js2 INT PATH '$'
    )
  );

select
  *
from
  JSON_TABLE(
    cast('123' as JSONB),
    '$'
    COLUMNS (
      item INT PATH '$',
      foo INT
    )
  ) as bar;

create domain jsonb_test_domain as TEXT check (value <> 'foo');

create temporary table json_table_test (js)
as
  values
    ('1'),
    ('[]'),
    ('{}'),
    (
      '[1, 1.23, "2", "aaaaaaa", "foo", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""]'
    );

select
  *
from
  json_table_test as vals
  left outer join
    JSON_TABLE(
      cast(vals.js as JSONB),
      'lax $[*]'
      COLUMNS (
        id for ORDINALITY,
        int INT PATH '$',
        text text PATH '$',
        "char(4)" CHAR(4) PATH '$',
        bool bool PATH '$',
        numeric NUMERIC PATH '$',
        domain jsonb_test_domain PATH '$',
        js JSON PATH '$',
        jb jsonb PATH '$'
      )
    ) as jt
  on true;

select
  *
from
  json_table_test as vals
  left outer join
    JSON_TABLE(
      cast(vals.js as JSONB),
      'lax $[*]'
      COLUMNS (
        id for ORDINALITY,
        jst text format json PATH '$',
        jsc CHAR(4) format json PATH '$',
        jsv VARCHAR(4) format json PATH '$',
        jsb jsonb format json PATH '$',
        jsbq jsonb format json PATH '$' OMIT QUOTES
      )
    ) as jt
  on true;

select
  *
from
  json_table_test as vals
  left outer join
    JSON_TABLE(
      cast(vals.js as JSONB),
      'lax $[*]'
      COLUMNS (
        id for ORDINALITY,
        exists1 bool EXISTS PATH '$.aaa',
        exists2 INT EXISTS PATH '$.aaa',
        exists3 INT EXISTS PATH 'strict $.aaa' unknown on ERROR,
        exists4 text EXISTS PATH 'strict $.aaa' false on ERROR
      )
    ) as jt
  on true;

select
  *
from
  json_table_test as vals
  left outer join
    JSON_TABLE(
      cast(vals.js as JSONB),
      'lax $[*]'
      COLUMNS (
        id for ORDINALITY,
        aaa INT,
        aaa1 INT PATH '$.aaa',
        js2 JSON PATH '$',
        jsb2w jsonb PATH '$' with UNCONDITIONAL wrapper,
        jsb2q jsonb PATH '$' OMIT QUOTES,
        ia INT[] PATH '$',
        ta TEXT[] PATH '$',
        jba JSONB[] PATH '$'
      )
    ) as jt
  on true;

select
  *
from
  JSON_TABLE(
    cast('{"d1": "H"}' as JSONB),
    '$'
    COLUMNS (
      js1 jsonb_test_domain PATH '$.a2' default cast(cast('"foo1"' as JSONB)
      as TEXT) on EMPTY
    )
  );

select
  *
from
  JSON_TABLE(
    cast('{"d1": "H"}' as JSONB),
    '$'
    COLUMNS (
      js1 jsonb_test_domain PATH '$.a2' default cast('foo' as jsonb_test_domain) on EMPTY
    )
  );

select
  *
from
  JSON_TABLE(
    cast('{"d1": "H"}' as JSONB),
    '$'
    COLUMNS (
      js1 jsonb_test_domain PATH '$.a2' default cast('foo1'
      as jsonb_test_domain) on EMPTY
    )
  );

select
  *
from
  JSON_TABLE(
    cast('{"d1": "foo"}' as JSONB),
    '$'
    COLUMNS (
      js1 jsonb_test_domain PATH '$.d1' default cast('foo2'
      as jsonb_test_domain) on ERROR
    )
  );

select
  *
from
  JSON_TABLE(
    cast('{"d1": "foo"}' as JSONB),
    '$'
    COLUMNS (
      js1 OID[] PATH '$.d2' default cast(cast('{1}' as INT[]) as OID[]) on EMPTY
    )
  );

create view jsonb_table_view2
as select
  *
from
  JSON_TABLE(
    cast('null' as JSONB),
    'lax $[*]'
    PASSING 1 + 2 as a,
    cast('"foo"' as JSON) as "b c"
    COLUMNS (
      int INT PATH '$',
      text text PATH '$',
      "char(4)" CHAR(4) PATH '$',
      bool bool PATH '$',
      numeric NUMERIC PATH '$',
      domain jsonb_test_domain PATH '$'
    )
  );

create view jsonb_table_view3
as select
  *
from
  JSON_TABLE(
    cast('null' as JSONB),
    'lax $[*]'
    PASSING 1 + 2 as a,
    cast('"foo"' as JSON) as "b c"
    COLUMNS (
      js JSON PATH '$',
      jb jsonb PATH '$',
      jst text format json PATH '$',
      jsc CHAR(4) format json PATH '$',
      jsv VARCHAR(4) format json PATH '$'
    )
  );

create view jsonb_table_view4
as select
  *
from
  JSON_TABLE(
    cast('null' as JSONB),
    'lax $[*]'
    PASSING 1 + 2 as a,
    cast('"foo"' as JSON) as "b c"
    COLUMNS (
      jsb jsonb format json PATH '$',
      jsbq jsonb format json PATH '$' OMIT QUOTES,
      aaa INT,
      aaa1 INT PATH '$.aaa'
    )
  );

create view jsonb_table_view5
as select
  *
from
  JSON_TABLE(
    cast('null' as JSONB),
    'lax $[*]'
    PASSING 1 + 2 as a,
    cast('"foo"' as JSON) as "b c"
    COLUMNS (
      exists1 bool EXISTS PATH '$.aaa',
      exists2 INT EXISTS PATH '$.aaa' true on ERROR,
      exists3 text EXISTS PATH 'strict $.aaa' unknown on ERROR
    )
  );

create view jsonb_table_view6
as select
  *
from
  JSON_TABLE(
    cast('null' as JSONB),
    'lax $[*]'
    PASSING 1 + 2 as a,
    cast('"foo"' as JSON) as "b c"
    COLUMNS (
      js2 JSON PATH '$',
      jsb2w jsonb PATH '$' with UNCONDITIONAL wrapper,
      jsb2q jsonb PATH '$' OMIT QUOTES,
      ia INT[] PATH '$',
      ta TEXT[] PATH '$',
      jba JSONB[] PATH '$'
    )
  );

select * from jsonb_table_view2;

select * from jsonb_table_view3;

select * from jsonb_table_view4;

select * from jsonb_table_view5;

select * from jsonb_table_view6;

select
  *
from
  JSON_TABLE(
    cast('null' as JSONB),
    'lax $[*]'
    PASSING 1 + 2 as a,
    cast('"foo"' as JSON) as "b c"
    COLUMNS (
      id for ORDINALITY,
      int INT PATH '$',
      text text PATH '$'
    )
  ) as json_table_func;

select
  *
from
  JSON_TABLE(
    cast('null' as JSONB),
    'lax $[*]'
    PASSING 1 + 2 as a,
    cast('"foo"' as JSON) as "b c"
    COLUMNS (
      id for ORDINALITY,
      int INT PATH '$',
      text text PATH '$'
    )
  ) as json_table_func;

drop VIEW "jsonb_table_view2";

drop VIEW "jsonb_table_view3";

drop VIEW "jsonb_table_view4";

drop VIEW "jsonb_table_view5";

drop VIEW "jsonb_table_view6";

drop DOMAIN jsonb_test_domain;

select
  *
from
  JSON_TABLE(
    cast('1' as JSONB),
    '$'
    COLUMNS (
      id for ORDINALITY,
      id2 for ORDINALITY,
      a INT PATH '$.a' ERROR on EMPTY
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('1' as JSONB),
    '$'
    COLUMNS (
      id for ORDINALITY,
      a INT PATH '$' ERROR on EMPTY
    )
  ) as jt;

select
  *
from
  (values ('1'), ('"err"')) as vals (js),
  JSON_TABLE(
    cast(vals.js as JSONB),
    '$'
    COLUMNS (
      a INT PATH '$'
    )
  ) as jt;

select
  *
from
  (values ('1'), ('"err"')) as vals (js)
  left outer join
    JSON_TABLE(
      cast(vals.js as JSONB),
      '$'
      COLUMNS (
        a INT PATH '$' ERROR on ERROR
      )
    ) as jt
  on true;

select
  *
from
  (values ('1'), ('"err"')) as vals (js)
  left outer join
    JSON_TABLE(
      cast(vals.js as JSONB),
      '$'
      COLUMNS (
        a INT PATH '$' ERROR on ERROR
      )
    ) as jt
  on true;

select
  *
from
  JSON_TABLE(
    cast('1' as JSONB),
    '$'
    COLUMNS (
      a INT PATH '$.a' ERROR on EMPTY
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('1' as JSONB),
    '$'
    COLUMNS (
      a INT PATH 'strict $.a' ERROR on ERROR
    )
    ERROR on ERROR
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('1' as JSONB),
    '$'
    COLUMNS (
      a INT PATH 'lax $.a' ERROR on EMPTY
    )
    ERROR on ERROR
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a INT PATH '$' default 1 on EMPTY default 2 on ERROR
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a INT PATH 'strict $.a' default 1 on EMPTY default 2 on ERROR
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a INT PATH 'lax $.a' default 1 on EMPTY default 2 on ERROR
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a int4 EXISTS PATH '$.a' ERROR on ERROR
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a int4 EXISTS PATH '$' ERROR on ERROR
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a int2 EXISTS PATH '$.a'
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a int8 EXISTS PATH '$.a'
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a float4 EXISTS PATH '$.a'
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a CHAR(3) EXISTS PATH '$.a'
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a CHAR(3) EXISTS PATH '$.a' ERROR on ERROR
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a CHAR(5) EXISTS PATH '$.a' ERROR on ERROR
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a JSON EXISTS PATH '$.a'
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a jsonb EXISTS PATH '$.a'
    )
  );

create domain dint4 as INT;

create domain dint4_0 as INT check (value <> 0);

select
  a,
  cast(a as BOOLEAN)
from
  JSON_TABLE(
    cast('"a"' as JSONB),
    '$'
    COLUMNS (
      a dint4 EXISTS PATH '$.a'
    )
  );

select
  a,
  cast(a as BOOLEAN)
from
  JSON_TABLE(
    cast('{"a":1}' as JSONB),
    '$'
    COLUMNS (
      a dint4_0 EXISTS PATH '$.b'
    )
  );

select
  a,
  cast(a as BOOLEAN)
from
  JSON_TABLE(
    cast('{"a":1}' as JSONB),
    '$'
    COLUMNS (
      a dint4_0 EXISTS PATH '$.b' ERROR on ERROR
    )
  );

select
  a,
  cast(a as BOOLEAN)
from
  JSON_TABLE(
    cast('{"a":1}' as JSONB),
    '$'
    COLUMNS (
      a dint4_0 EXISTS PATH '$.b' false on ERROR
    )
  );

select
  a,
  cast(a as BOOLEAN)
from
  JSON_TABLE(
    cast('{"a":1}' as JSONB),
    '$'
    COLUMNS (
      a dint4_0 EXISTS PATH '$.b' true on ERROR
    )
  );

drop DOMAIN dint4, dint4_0;

select
  *
from
  JSON_TABLE(
    cast('"world"' as JSONB),
    '$'
    COLUMNS (
      item text PATH '$' KEEP QUOTES
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"world"' as JSONB),
    '$'
    COLUMNS (
      item text PATH '$' OMIT QUOTES
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"world"' as JSONB),
    '$'
    COLUMNS (
      item text format json PATH '$' KEEP QUOTES
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"world"' as JSONB),
    '$'
    COLUMNS (
      item text format json PATH '$' OMIT QUOTES
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"world"' as JSONB),
    '$'
    COLUMNS (
      item text format json PATH '$' without wrapper KEEP QUOTES
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"world"' as JSONB),
    '$'
    COLUMNS (
      item text PATH '$' without wrapper OMIT QUOTES
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"world"' as JSONB),
    '$'
    COLUMNS (
      item text format json PATH '$' with UNCONDITIONAL wrapper
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"world"' as JSONB),
    '$'
    COLUMNS (
      item text PATH '$' with UNCONDITIONAL wrapper OMIT QUOTES
    )
  );

select
  *
from
  JSON_TABLE(
    cast('"world"' as JSONB),
    '$'
    COLUMNS (
      item text format json PATH '$' with UNCONDITIONAL wrapper KEEP QUOTES
    )
  );

select
  *
from
  JSON_TABLE(
    cast('[1,2,3]' as JSONB),
    '$[*] ? (@ < $x)'
    PASSING 3 as x
    COLUMNS (
      y text format json PATH '$'
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('[1,2,3]' as JSONB),
    '$[*] ? (@ < $x)'
    PASSING 10 as x,
    3 as y
    COLUMNS (
      a text format json PATH '$ ? (@ < $y)'
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    '{"a": [{"b": "1"}, {"b": "2"}]}',
    '$'
    COLUMNS (
      b JSON PATH '$.a[*].b' ERROR on ERROR
    )
  );

select
  *
from
  JSON_TABLE(
    cast('[]' as JSONB),
    '$' as a
    COLUMNS (
      b INT,
      NESTED PATH '$' as a COLUMNS (c INT )
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('[]' as JSONB),
    '$' as a
    COLUMNS (
      b INT,
      NESTED PATH '$' as n_a COLUMNS (c INT )
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('[]' as JSONB),
    '$'
    COLUMNS (
      b INT,
      NESTED PATH '$' as b COLUMNS (c INT )
    )
  ) as jt;

select
  *
from
  JSON_TABLE(
    cast('[]' as JSONB),
    '$'
    COLUMNS (
      NESTED PATH '$' as a COLUMNS (b INT ),
      NESTED PATH '$'
      COLUMNS (
        NESTED PATH '$' as a COLUMNS (c INT )
      )
    )
  ) as jt;

create temporary table jsonb_table_test (js JSONB);

insert into jsonb_table_test
values
  (
    '[
		{"a":  1,  "b": [], "c": []},
		{"a":  2,  "b": [1, 2, 3], "c": [10, null, 20]},
		{"a":  3,  "b": [1, 2], "c": []},
		{"x": "4", "b": [1, 2], "c": 123}
	 ]'
  );

select
  jt.*
from
  jsonb_table_test as jtt,
  JSON_TABLE(
    jtt.js,
    'strict $[*]' as p
    COLUMNS (
      n for ORDINALITY,
      a INT PATH 'lax $.a' default -1 on EMPTY,
      NESTED PATH 'strict $.b[*]' as pb
      COLUMNS (
        b_id for ORDINALITY,
        b INT PATH '$'
      ),
      NESTED PATH 'strict $.c[*]' as pc
      COLUMNS (
        c_id for ORDINALITY,
        c INT PATH '$'
      )
    )
  ) as jt;

select
  *
from
  generate_series(1, 3) as x,
  generate_series(1, 3) as y,
  JSON_TABLE(
    cast('[[1,2,3],[2,3,4,5],[3,4,5,6]]'
    as JSONB),
    'strict $[*] ? (@[*] <= $x)'
    PASSING x as x,
    y as y
    COLUMNS (
      y text format json PATH '$',
      NESTED PATH 'strict $[*] ? (@ == $y)'
      COLUMNS (
        z INT PATH '$'
      )
    )
  ) as jt;

create view jsonb_table_view_nested
as select
  *
from
  JSON_TABLE(
    cast('null' as JSONB),
    'lax $[*]'
    PASSING 1 + 2 as a,
    cast('"foo"' as JSON) as "b c"
    COLUMNS (
      id for ORDINALITY,
      NESTED PATH '$[1]' as p1
      COLUMNS (
        a1 INT,
        NESTED PATH '$[*]' as "p1 1"
        COLUMNS (
          a11 text
        ),
        b1 text
      ),
      NESTED PATH '$[2]' as p2
      COLUMNS (
        NESTED PATH '$[*]' as "p2:1"
        COLUMNS (
          a21 text
        ),
        NESTED PATH '$[*]' as p22
        COLUMNS (
          a22 text
        )
      )
    )
  );

drop VIEW "jsonb_table_view_nested";

create table s (js JSONB);

insert into s
values
  (
    '{"a":{"za":[{"z1": [11,2222]},{"z21": [22, 234,2345]},{"z22": [32, 204,145]}]},"c": 3}'
  ),
  (
    '{"a":{"za":[{"z1": [21,4222]},{"z21": [32, 134,1345]}]},"c": 10}'
  );

select
  sub.*
from
  s,
  JSON_TABLE(
    js,
    '$'
    PASSING 32 as x,
    13 as y
    COLUMNS (
      xx INT PATH '$.c',
      NESTED PATH '$.a.za[1]'
      COLUMNS (
        NESTED PATH '$.z21[*]'
        COLUMNS (
          z21 INT PATH '$?(@ >= $"x")' ERROR on ERROR
        )
      )
    )
  ) as sub;

select
  sub.*
from
  s,
  (values (23)) as x (x),
  generate_series(13, 13) as y,
  JSON_TABLE(
    js,
    '$' as c1
    PASSING x as x,
    y as y
    COLUMNS (
      NESTED PATH '$.a.za[2]'
      COLUMNS (
        NESTED PATH '$.z22[*]' as z22
        COLUMNS (
          c INT PATH '$'
        )
      ),
      NESTED PATH '$.a.za[1]'
      COLUMNS (
        d INT[] PATH '$.z21'
      ),
      NESTED PATH '$.a.za[0]'
      COLUMNS (
        NESTED PATH '$.z1[*]' as z1
        COLUMNS (
          a INT PATH '$'
        )
      ),
      xx1 INT PATH '$.c',
      NESTED PATH '$.a.za[1]'
      COLUMNS (
        NESTED PATH '$.z21[*]' as z21
        COLUMNS (
          b INT PATH '$'
        )
      ),
      xx INT PATH '$.c'
    )
  ) as sub;

select
  sub.*
from
  s,
  (values (23)) as x (x),
  generate_series(13, 13) as y,
  JSON_TABLE(
    js,
    '$' as c1
    PASSING x as x,
    y as y
    COLUMNS (
      xx1 INT PATH '$.c',
      NESTED PATH '$.a.za[0].z1[*]'
      COLUMNS (
        NESTED PATH '$ ?(@ >= ($"x" -2))'
        COLUMNS (
          a INT PATH '$'
        )
      ),
      NESTED PATH '$.a.za[0]'
      COLUMNS (
        NESTED PATH '$.z1[*] ? (@ >= ($"x" -2))'
        COLUMNS (
          b INT PATH '$'
        )
      )
    )
  ) as sub;

select
  sub.*
from
  s,
  (values (23)) as x (x),
  generate_series(13, 13) as y,
  JSON_TABLE(
    js,
    '$' as c1
    PASSING x as x,
    y as y
    COLUMNS (
      xx1 INT PATH '$.c',
      NESTED PATH '$.a.za[1]'
      COLUMNS (
        NESTED PATH '$.z21[*]'
        COLUMNS (
          b INT PATH '$'
        )
      ),
      NESTED PATH '$.a.za[1] ? (@.z21[*] >= ($"x"-1))'
      COLUMNS (
        NESTED PATH '$.z21[*] ? (@ >= ($"y" + 3))' as z22
        COLUMNS (
          a INT PATH '$ ? (@ >= ($"y" + 12))'
        )
      ),
      NESTED PATH '$.a.za[1]'
      COLUMNS (
        NESTED PATH '$.z21[*] ? (@ >= ($"y" +121))' as z21
        COLUMNS (
          c INT PATH '$ ? (@ > ($"x" +111))'
        )
      )
    )
  ) as sub;

select
  sub.*
from
  s,
  (values (23)) as x (x),
  generate_series(13, 13) as y,
  JSON_TABLE(
    js,
    '$' as c1
    PASSING x as x,
    y as y
    COLUMNS (
      xx1 INT PATH '$.c',
      NESTED PATH '$.a.za[2]'
      COLUMNS (
        NESTED PATH '$.z22[*]' as z22
        COLUMNS (
          c INT PATH '$'
        )
      ),
      NESTED PATH '$.a.za[1]'
      COLUMNS (
        d JSON PATH '$ ? (@.z21[*] == ($"x" -1))'
      ),
      NESTED PATH '$.a.za[0]'
      COLUMNS (
        NESTED PATH '$.z1[*] ? (@ >= ($"x" -2))' as z1
        COLUMNS (
          a INT PATH '$'
        )
      ),
      NESTED PATH '$.a.za[1]'
      COLUMNS (
        NESTED PATH '$.z21[*] ? (@ >= ($"y" +121))' as z21
        COLUMNS (
          b INT PATH '$ ? (@ > ($"x" +111))' default 0 on EMPTY
        )
      )
    )
  ) as sub;

create or replace view jsonb_table_view7
as select
  sub.*
from
  s,
  (values (23)) as x (x),
  generate_series(13, 13) as y,
  JSON_TABLE(
    js,
    '$' as c1
    PASSING x as x,
    y as y
    COLUMNS (
      xx1 INT PATH '$.c',
      NESTED PATH '$.a.za[2]'
      COLUMNS (
        NESTED PATH '$.z22[*]' as z22
        COLUMNS (
          c INT PATH '$' without wrapper OMIT QUOTES
        )
      ),
      NESTED PATH '$.a.za[1]'
      COLUMNS (
        d JSON PATH '$ ? (@.z21[*] == ($"x" -1))' with UNCONDITIONAL wrapper
      ),
      NESTED PATH '$.a.za[0]'
      COLUMNS (
        NESTED PATH '$.z1[*] ? (@ >= ($"x" -2))' as z1
        COLUMNS (
          a INT PATH '$' KEEP QUOTES
        )
      ),
      NESTED PATH '$.a.za[1]'
      COLUMNS (
        NESTED PATH '$.z21[*] ? (@ >= ($"y" +121))' as z21
        COLUMNS (
          b INT PATH '$ ? (@ > ($"x" +111))' default 0 on EMPTY
        )
      )
    )
  ) as sub;

drop VIEW "jsonb_table_view7";

drop TABLE "s";

select
  *
from
  JSON_TABLE(
    cast('1' as JSONB),
    '$'
    COLUMNS (
      a INT
    )
    null on ERROR
  );

select
  *
from
  JSON_TABLE(
    cast('1' as JSONB),
    '$'
    COLUMNS (
      a INT true on EMPTY
    )
  );

select
  *
from
  JSON_TABLE(
    cast('1' as JSONB),
    '$'
    COLUMNS (
      a INT OMIT QUOTES true on ERROR
    )
  );

select
  *
from
  JSON_TABLE(
    cast('1' as JSONB),
    '$'
    COLUMNS (
      a INT EXISTS EMPTY object on ERROR
    )
  );

create view json_table_view8
as select
  *
from
  JSON_TABLE(
    '"a"',
    '$'
    COLUMNS (
      a text PATH '$'
    )
  );

create view json_table_view9
as select
  *
from
  JSON_TABLE(
    '"a"',
    '$'
    COLUMNS (
      a text PATH '$'
    )
    ERROR on ERROR
  );

drop VIEW "json_table_view8", "json_table_view9";

create view json_table_view8
as select
  *
from
  JSON_TABLE(
    '"a"',
    '$'
    COLUMNS (
      a text PATH '$'
    )
    EMPTY array on ERROR
  );

create view json_table_view9
as select
  *
from
  JSON_TABLE(
    '"a"',
    '$'
    COLUMNS (
      a text PATH '$'
    )
    EMPTY array on ERROR
  );

drop VIEW "json_table_view8", "json_table_view9";
