---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/domain.sql
snapshot_kind: text
---
create domain domaindroptest as INT;

comment on domain domaindroptest is 'About to drop this..';

create domain dependenttypetest as domaindroptest;

drop DOMAIN domaindroptest;

drop DOMAIN domaindroptest cascade;

drop DOMAIN domaindroptest cascade;

create domain d_fail as no_such_type;

create domain d_fail as INT constraint "cc" references this_table_not_exists (i);

create domain d_fail as INT not null null;

create domain d_fail as INT not null default 3 default 3;

create domain d_fail as INT default (3 + 'h');

create domain d_fail as INT collate "C";

create domain d_fail as ANYELEMENT;

create domain d_fail as INT unique;

create domain d_fail as INT primary key;

create domain d_fail as INT constraint "cc" generated by default as identity;

create domain d_fail as INT constraint "cc" check (values > 1) no inherit;

create domain d_fail as INT constraint "cc" check (values > 1) deferrable;

create domain domainvarchar as VARCHAR(5);

create domain domainnumeric as NUMERIC(8, 2);

create domain domainint4 as INT;

create domain domaintext as TEXT;

select cast('123456' as domainvarchar);

select cast('12345' as domainvarchar);

create table basictest (
  testint4 domainint4,
  testtext domaintext,
  testvarchar domainvarchar,
  testnumeric domainnumeric
);

insert into basictest values ('88', 'haha', 'short', '123.12');

insert into basictest values ('88', 'haha', 'short text', '123.12');

insert into basictest values ('88', 'haha', 'short', '123.1212');

select * from basictest;

select testtext || testvarchar as concat, testnumeric + 42 as sum from basictest;

select pg_typeof(coalesce(cast(4 as domainint4), 7));

select pg_typeof(coalesce(cast(4 as domainint4), cast(7 as domainint4)));

drop TABLE "basictest";

drop DOMAIN domainvarchar;

drop DOMAIN domainnumeric;

drop DOMAIN domainint4;

drop DOMAIN domaintext;

create domain positiveint as INT check (value > 0);

create domain weirdfloat as DOUBLE PRECISION check (1 / value < 10);

select pg_input_is_valid('1', 'positiveint');

select pg_input_is_valid('junk', 'positiveint');

select pg_input_is_valid('-1', 'positiveint');

select * from pg_input_error_info('junk', 'positiveint');

select * from pg_input_error_info('-1', 'positiveint');

select * from pg_input_error_info('junk', 'weirdfloat');

select * from pg_input_error_info('0.01', 'weirdfloat');

select * from pg_input_error_info('0', 'weirdfloat');

drop DOMAIN positiveint;

drop DOMAIN weirdfloat;

create domain domainint4arr as INT[1];

create domain domainchar4arr as VARCHAR(4)[2][3];

create table domarrtest (
  testint4arr domainint4arr,
  testchar4arr domainchar4arr
);

insert into domarrtest values ('{2,2}', '{{"a","b"},{"c","d"}}');

insert into domarrtest values ('{{2,2},{2,2}}', '{{"a","b"}}');

insert into domarrtest values ('{2,2}', '{{"a","b"},{"c","d"},{"e","f"}}');

insert into domarrtest values ('{2,2}', '{{"a"},{"c"}}');

insert into domarrtest values (null, '{{"a","b","c"},{"d","e","f"}}');

insert into domarrtest values (null, '{{"toolong","b","c"},{"d","e","f"}}');

insert into domarrtest (testint4arr[1], testint4arr[3]) values (11, 22);

select * from domarrtest;

select testint4arr[1], testchar4arr[2:2] from domarrtest;

select array_dims(testint4arr), array_dims(testchar4arr) from domarrtest;

select * from domarrtest;

update domarrtest
set testint4arr[1] = testint4arr[1] + 1,
testint4arr[3] = testint4arr[3] - 1
where
  testchar4arr is null;

select * from domarrtest where testchar4arr is null;

drop TABLE "domarrtest";

drop DOMAIN domainint4arr;

drop DOMAIN domainchar4arr;

create domain dia as INT[];

select cast('{1,2,3}' as dia);

select array_dims(cast('{1,2,3}' as dia));

select pg_typeof(cast('{1,2,3}' as dia));

select pg_typeof(cast('{1,2,3}' as dia) || 42);

drop DOMAIN dia;

create type comptype as (r DOUBLE PRECISION, i DOUBLE PRECISION);

create domain dcomptype as comptype;

create table dcomptable (d1 dcomptype unique);

insert into dcomptable values (cast(row(1, 2) as dcomptype));

insert into dcomptable values (cast(row(3, 4) as comptype));

insert into dcomptable values (cast(row(1, 2) as dcomptype));

insert into dcomptable (d1."r") values (11);

select * from dcomptable;

select d1.r, d1.i, d1.* from dcomptable;

update dcomptable set d1."r" = d1.r + 1 where d1.i > 0;

select * from dcomptable;

alter DOMAIN dcomptype add constraint "c1" check (value.r <= value.i);

alter DOMAIN dcomptype add constraint "c2" check (value.r > value.i);

select cast(row(2, 1) as dcomptype);

insert into dcomptable values (cast(row(1, 2) as comptype));

insert into dcomptable values (cast(row(2, 1) as comptype));

insert into dcomptable (d1."r") values (99);

insert into dcomptable (d1."r", d1."i") values (99, 100);

insert into dcomptable (d1."r", d1."i") values (100, 99);

update dcomptable set d1."r" = d1.r + 1 where d1.i > 0;

update dcomptable set d1."r" = d1.r - 1, d1."i" = d1.i + 1 where d1.i > 0;

select * from dcomptable;

update dcomptable set d1."r" = d1.r - 1, d1."i" = d1.i + 1 where d1.i > 0;

create rule silly
as on delete to dcomptable
do instead
  update dcomptable
  set d1."r" = d1.r - 1,
  d1."i" = d1.i + 1
  where
    d1.i > 0;;

create function makedcomp(r DOUBLE PRECISION, i DOUBLE PRECISION)
returns dcomptype
as 'select row(r, i)'
language "sql";

select makedcomp(1, 2);

select makedcomp(2, 1);

select * from makedcomp(1, 2) as m;

select m, m is not null from makedcomp(1, 2) as m;

drop FUNCTION makedcomp(DOUBLE PRECISION, DOUBLE PRECISION);

drop TABLE "dcomptable";

drop TYPE comptype cascade;

create type comptype as (r DOUBLE PRECISION, i DOUBLE PRECISION);

create domain dcomptype as comptype;

alter DOMAIN dcomptype add constraint "c1" check (value.r > 0);

comment on constraint c1 on domain dcomptype is 'random commentary';

select cast(row(0, 1) as dcomptype);

alter type comptype
  alter ATTRIBUTE r type VARCHAR;

alter type comptype
  alter ATTRIBUTE r type BIGINT;

alter type comptype
  drop ATTRIBUTE r;

alter type comptype
  drop ATTRIBUTE i;

select
  conname,
  obj_description(oid, 'pg_constraint')
from
  pg_constraint
where
  contypid = cast('dcomptype' as REGTYPE);

drop TYPE comptype cascade;

create type comptype as (r DOUBLE PRECISION, i DOUBLE PRECISION);

create domain dcomptypea as comptype[];

create table dcomptable (d1 dcomptypea unique);

insert into dcomptable values (cast(array[row(1, 2)] as dcomptypea));

insert into dcomptable values (cast(array[row(3, 4), row(5, 6)] as comptype[]));

insert into dcomptable values (array[cast(row(7, 8) as comptype), cast(row(9, 10) as comptype)]);

insert into dcomptable values (cast(array[row(1, 2)] as dcomptypea));

insert into dcomptable (d1[1]) values (row(9, 10));

insert into dcomptable (d1[1]."r") values (11);

select * from dcomptable;

select d1[2], d1[1].r, d1[1].i from dcomptable;

update dcomptable set d1[2] = row(d1[2].i, d1[2].r);

select * from dcomptable;

update dcomptable set d1[1]."r" = d1[1].r + 1 where d1[1].i > 0;

select * from dcomptable;

alter DOMAIN dcomptypea add constraint "c1" check (value[1].r <= value[1].i);

alter DOMAIN dcomptypea add constraint "c2" check (value[1].r > value[1].i);

select cast(array[row(2, 1)] as dcomptypea);

insert into dcomptable values (cast(array[row(1, 2)] as comptype[]));

insert into dcomptable values (cast(array[row(2, 1)] as comptype[]));

insert into dcomptable (d1[1]."r") values (99);

insert into dcomptable (d1[1]."r", d1[1]."i") values (99, 100);

insert into dcomptable (d1[1]."r", d1[1]."i") values (100, 99);

update dcomptable set d1[1]."r" = d1[1].r + 1 where d1[1].i > 0;

update dcomptable set d1[1]."r" = d1[1].r - 1, d1[1]."i" = d1[1].i + 1 where d1[1].i > 0;

select * from dcomptable;

update dcomptable set d1[1]."r" = d1[1].r - 1, d1[1]."i" = d1[1].i + 1 where d1[1].i > 0;

create rule silly
as on delete to dcomptable
do instead
  update dcomptable
  set d1[1]."r" = d1[1].r - 1,
  d1[1]."i" = d1[1].i + 1
  where
    d1[1].i > 0;;

drop TABLE "dcomptable";

drop TYPE comptype cascade;

create domain posint as INT check (value > 0);

create table pitable (f1 posint[]);

insert into pitable values (array[42]);

insert into pitable values (array[-1]);

insert into pitable values ('{0}');

update pitable set f1[1] = f1[1] + 1;

update pitable set f1[1] = 0;

select * from pitable;

drop TABLE "pitable";

create domain vc4 as VARCHAR(4);

create table vc4table (f1 vc4[]);

insert into vc4table values (array['too long']);

insert into vc4table values (cast(array['too long'] as vc4[]));

select * from vc4table;

drop TABLE "vc4table";

drop TYPE vc4;

create domain dposinta as posint[];

create table dposintatable (f1 dposinta[]);

insert into dposintatable values (array[array[42]]);

insert into dposintatable values (array[cast(array[42] as posint[])]);

insert into dposintatable values (array[cast(array[42] as dposinta)]);

select f1, f1[1], f1[1][1] from dposintatable;

select pg_typeof(f1) from dposintatable;

select pg_typeof(f1[1]) from dposintatable;

select pg_typeof(f1[1][1]) from dposintatable;

select pg_typeof(f1[1][1]) from dposintatable;

update dposintatable set f1[2] = array[99];

select f1, f1[1], f1[2][1] from dposintatable;

update dposintatable set f1[2][1] = array[97];

drop TABLE "dposintatable";

drop DOMAIN posint cascade;

create type comptype as (cf1 INT, cf2 INT);

create domain dcomptype as comptype check (value.cf1 > 0);

create table dcomptable (f1 dcomptype[]);

insert into dcomptable values (null);

update dcomptable set f1[1]."cf2" = 5;

select * from dcomptable;

update dcomptable set f1[1]."cf1" = -1;

update dcomptable set f1[1]."cf1" = 1;

select * from dcomptable;

alter DOMAIN dcomptype drop CONSTRAINT dcomptype_check;

update dcomptable set f1[1]."cf1" = -1;

select * from dcomptable;

drop TABLE "dcomptable";

drop TYPE comptype cascade;

create domain dnotnull as VARCHAR(15) not null;

create domain dnull as VARCHAR(15);

create domain dcheck as VARCHAR(15) not null check (value = 'a' or value = 'c' or value = 'd');

create table nulltest (
  col1 dnotnull,
  col2 dnotnull null,
  col3 dnull not null,
  col4 dnull,
  col5 dcheck check (col5 in ('c', 'd'))
);

insert into nulltest default values;

insert into nulltest values ('a', 'b', 'c', 'd', 'c');

insert into nulltest values ('a', 'b', 'c', 'd', null);

insert into nulltest values ('a', 'b', 'c', 'd', 'a');

insert into nulltest values (null, 'b', 'c', 'd', 'd');

insert into nulltest values ('a', null, 'c', 'd', 'c');

insert into nulltest values ('a', 'b', null, 'd', 'c');

insert into nulltest values ('a', 'b', 'c', null, 'd');

select * from nulltest;

select cast('1' as dnotnull);

select cast(null as dnotnull);

select cast(cast(null as dnull) as dnotnull);

select cast(col4 as dnotnull) from nulltest;

drop TABLE "nulltest";

drop DOMAIN dnotnull;

drop DOMAIN dnull;

drop DOMAIN dcheck;

create domain ddef1 as INT default 3;

create domain ddef2 as OID default '12';

create domain ddef3 as TEXT default 5;

create sequence ddef4_seq;

create domain ddef4 as INT default nextval('ddef4_seq');

create domain ddef5 as NUMERIC(8, 2) not null default '12.12';

create table defaulttest (
  col1 ddef1,
  col2 ddef2,
  col3 ddef3,
  col4 ddef4 primary key,
  col5 ddef1 not null default null,
  col6 ddef2 default '88',
  col7 ddef4 default 8000,
  col8 ddef5
);

insert into defaulttest (col4) values (0);

alter table defaulttest
  alter column col5 drop default;

insert into defaulttest default values;

alter table defaulttest
  alter column col5 set default null;

insert into defaulttest (col4) values (0);

alter table defaulttest
  alter column col5 drop default;

insert into defaulttest default values;

insert into defaulttest default values;

select * from defaulttest;

drop TABLE "defaulttest" cascade;

create domain dnotnulltest as INT;

create table domnotnull (
  col1 dnotnulltest,
  col2 dnotnulltest
);

insert into domnotnull default values;

alter DOMAIN dnotnulltest set not NULL;

update domnotnull set col1 = 5;

alter DOMAIN dnotnulltest set not NULL;

update domnotnull set col2 = 6;

alter DOMAIN dnotnulltest set not NULL;

update domnotnull set col1 = null;

alter DOMAIN dnotnulltest drop not NULL;

update domnotnull set col1 = null;

update domnotnull set col1 = 5;

alter DOMAIN dnotnulltest add constraint "dnotnulltest_notnull" not null;

update domnotnull set col1 = null;

select
  conname,
  pg_get_constraintdef(oid)
from
  pg_constraint
where
  contypid = cast('dnotnulltest' as REGTYPE);

alter DOMAIN dnotnulltest drop CONSTRAINT dnotnulltest_notnull;

update domnotnull set col1 = null;

drop DOMAIN dnotnulltest cascade;

create table domdeftest (col1 ddef1);

insert into domdeftest default values;

select * from domdeftest;

alter DOMAIN ddef1 set default '42';

insert into domdeftest default values;

select * from domdeftest;

alter DOMAIN ddef1 drop default;

insert into domdeftest default values;

select * from domdeftest;

drop TABLE "domdeftest";

create domain con as INT;

create table domcontest (col1 con);

insert into domcontest values (1);

insert into domcontest values (2);

alter DOMAIN con add constraint "t" check (value < 1);

alter DOMAIN con add constraint "t" check (value < 34);

alter DOMAIN con add check (value > 0);

insert into domcontest values (-5);

insert into domcontest values (42);

insert into domcontest values (5);

alter DOMAIN con drop CONSTRAINT t;

insert into domcontest values (-5);

insert into domcontest values (42);

alter DOMAIN con drop CONSTRAINT nonexistent;

alter DOMAIN con drop CONSTRAINT if exists nonexistent;

create domain connotnull as INT;

create table domconnotnulltest (
  col1 connotnull,
  col2 connotnull
);

insert into domconnotnulltest default values;

alter DOMAIN connotnull add not null;

update domconnotnulltest set col1 = 5;

alter DOMAIN connotnull add not null;

update domconnotnulltest set col2 = 6;

alter DOMAIN connotnull add constraint "constr1" not null;

select COUNT(*) from pg_constraint where contypid = cast('connotnull' as REGTYPE) and contype = 'n';

alter DOMAIN connotnull add constraint "constr1bis" not null;

select COUNT(*) from pg_constraint where contypid = cast('connotnull' as REGTYPE) and contype = 'n';

update domconnotnulltest set col1 = null;

alter DOMAIN connotnull drop CONSTRAINT constr1;

update domconnotnulltest set col1 = null;

drop DOMAIN connotnull cascade;

drop TABLE "domconnotnulltest";

create domain things as INT;

create table thethings (stuff things);

insert into thethings (stuff) values (55);

alter DOMAIN things add constraint "meow" check (value < 11);

alter DOMAIN things add constraint "meow" check (value < 11) not valid;

alter DOMAIN things VALIDATE CONSTRAINT meow;

update thethings set stuff = 10;

alter DOMAIN things VALIDATE CONSTRAINT meow;

create table domtab (col1 INT);

create domain dom as INT;

create view domview
as select cast(col1 as dom) from domtab;

insert into domtab (col1) values (null);

insert into domtab (col1) values (5);

select * from domview;

alter DOMAIN dom set not NULL;

select * from domview;

alter DOMAIN dom drop not NULL;

select * from domview;

alter DOMAIN dom add constraint "domchkgt6" check (value > 6);

select * from domview;

alter DOMAIN dom drop CONSTRAINT domchkgt6;

select * from domview;

drop DOMAIN ddef1;

drop DOMAIN ddef2;

drop DOMAIN ddef3;

drop DOMAIN ddef4;

drop DOMAIN ddef5;

drop SEQUENCE "ddef4_seq";

create domain vchar4 as VARCHAR(4);

create domain dinter as vchar4 check (SUBSTRING(value from 1 for 1) = 'x');

create domain dtop as dinter check (SUBSTRING(value from 2 for 1) = '1');

select cast('x123' as dtop);

select cast('x1234' as dtop);

select cast('y1234' as dtop);

select cast('y123' as dtop);

select cast('yz23' as dtop);

select cast('xz23' as dtop);

create temporary table dtest (f1 dtop);

insert into dtest values ('x123');

insert into dtest values ('x1234');

insert into dtest values ('y1234');

insert into dtest values ('y123');

insert into dtest values ('yz23');

insert into dtest values ('xz23');

drop TABLE "dtest";

drop DOMAIN vchar4 cascade;

create domain str_domain as TEXT not null;

create table domain_test (
  a INT,
  b INT
);

insert into domain_test values (1, 2);

insert into domain_test values (1, 2);

alter table domain_test
  add column c str_domain;

create domain int_domain1 as INT constraint "nn1" not null constraint "nn2" not null;

create domain str_domain2 as TEXT check (value <> 'foo') default 'foo';

alter table domain_test
  add column d str_domain2;

create domain pos_int as INT check (value > 0) not null;

prepare s1 as select cast($1 as pos_int) = 10 as is_ten;;

execute s1 (10);

execute s1 (0);

execute s1 (null);

create function doubledecrement(p1 pos_int)
returns pos_int
as '
declare v pos_int;
begin
    return p1;
end'
language "plpgsql";

select doubledecrement(3);

create or replace function doubledecrement(p1 pos_int)
returns pos_int
as '
declare v pos_int := 0;
begin
    return p1;
end'
language "plpgsql";

select doubledecrement(3);

create or replace function doubledecrement(p1 pos_int)
returns pos_int
as '
declare v pos_int := 1;
begin
    v := p1 - 1;
    return v - 1;
end'
language "plpgsql";

select doubledecrement(null);

select doubledecrement(0);

select doubledecrement(1);

select doubledecrement(2);

select doubledecrement(3);

create domain posint as INT;

create type ddtest1 as (f1 posint);

create table ddtest2 (f1 ddtest1);

insert into ddtest2 values (row(-1));

alter DOMAIN posint add constraint "c1" check (value >= 0);

drop TABLE "ddtest2";

create table ddtest2 (f1 ddtest1[]);

insert into ddtest2 values ('{(-1)}');

alter DOMAIN posint add constraint "c1" check (value >= 0);

drop TABLE "ddtest2";

create domain ddtest1d as ddtest1;

create table ddtest2 (f1 ddtest1d);

insert into ddtest2 values ('(-1)');

alter DOMAIN posint add constraint "c1" check (value >= 0);

drop TABLE "ddtest2";

drop DOMAIN ddtest1d;

create domain ddtest1d as ddtest1[];

create table ddtest2 (f1 ddtest1d);

insert into ddtest2 values ('{(-1)}');

alter DOMAIN posint add constraint "c1" check (value >= 0);

drop TABLE "ddtest2";

drop DOMAIN ddtest1d;

create type rposint as RANGE (subtype = posint);

create table ddtest2 (f1 rposint);

insert into ddtest2 values ('(-1,3]');

alter DOMAIN posint add constraint "c1" check (value >= 0);

drop TABLE "ddtest2";

drop TYPE rposint;

alter DOMAIN posint add constraint "c1" check (value >= 0);

create domain posint2 as posint check (value % 2 = 0);

create table ddtest2 (f1 posint2);

insert into ddtest2 values (11);

insert into ddtest2 values (-2);

insert into ddtest2 values (2);

alter DOMAIN posint add constraint "c2" check (value >= 10);

alter DOMAIN posint add constraint "c2" check (value > 0);

drop TABLE "ddtest2";

drop TYPE ddtest1;

drop DOMAIN posint cascade;

create or replace function array_elem_check(NUMERIC)
returns NUMERIC
as '
declare
  x numeric(4,2)[1];
begin
  x[1] := $1;
  return x[1];
end'
language "plpgsql";

select array_elem_check(121.00);

select array_elem_check(1.23456);

create domain mynums as NUMERIC(4, 2)[1];

create or replace function array_elem_check(NUMERIC)
returns NUMERIC
as '
declare
  x mynums;
begin
  x[1] := $1;
  return x[1];
end'
language "plpgsql";

select array_elem_check(121.00);

select array_elem_check(1.23456);

create domain mynums2 as mynums;

create or replace function array_elem_check(NUMERIC)
returns NUMERIC
as '
declare
  x mynums2;
begin
  x[1] := $1;
  return x[1];
end'
language "plpgsql";

select array_elem_check(121.00);

select array_elem_check(1.23456);

drop FUNCTION array_elem_check(NUMERIC);

create domain orderedpair as INT[2] check (value[1] < value[2]);

select cast(array[1, 2] as orderedpair);

select cast(array[2, 1] as orderedpair);

create temporary table op (f1 orderedpair);

insert into op values (array[1, 2]);

insert into op values (array[2, 1]);

update op set f1[2] = 3;

update op set f1[2] = 0;

select * from op;

create or replace function array_elem_check(INT)
returns INT
as '
declare
  x orderedpair := ''{1,2}'';
begin
  x[2] := $1;
  return x[2];
end'
language "plpgsql";

select array_elem_check(3);

select array_elem_check(-1);

drop FUNCTION array_elem_check(INT);

create domain di as INT;

create function dom_check(INT)
returns di
as '
declare d di;
begin
  d := $1::di;
  return d;
end
'
language "plpgsql"
immutable;

select dom_check(0);

alter DOMAIN di add constraint "pos" check (value > 0);

select dom_check(0);

alter DOMAIN di drop CONSTRAINT pos;

select dom_check(0);

create or replace function dom_check(INT)
returns di
as '
declare d di;
begin
  d := $1;
  return d;
end
'
language "plpgsql"
immutable;

select dom_check(0);

alter DOMAIN di add constraint "pos" check (value > 0);

select dom_check(0);

alter DOMAIN di drop CONSTRAINT pos;

select dom_check(0);

drop FUNCTION dom_check(INT);

drop DOMAIN di;

create function sql_is_distinct_from(ANYELEMENT, ANYELEMENT)
returns BOOLEAN
language "sql"
as 'select $1 is distinct from $2 limit 1';

create domain inotnull as INT check (sql_is_distinct_from(value, null));

select cast(1 as inotnull);

select cast(null as inotnull);

create table dom_table (x inotnull);

insert into dom_table values ('1');

insert into dom_table values (1);

insert into dom_table values (null);

drop TABLE "dom_table";

drop DOMAIN inotnull;

drop FUNCTION sql_is_distinct_from(ANYELEMENT, ANYELEMENT);

create domain testdomain1 as INT;

alter domain testdomain1 rename to testdomain2;

alter type testdomain2 rename to testdomain3;

drop DOMAIN testdomain3;

create domain testdomain1 as INT constraint "unsigned" check (value > 0);

alter domain testdomain1 rename constraint unsigned to unsigned_foo;

alter DOMAIN testdomain1 drop CONSTRAINT unsigned_foo;

drop DOMAIN testdomain1;

create domain mytext as TEXT;

create domain mytext_child_1 as mytext;

select pg_basetype(cast('mytext' as REGTYPE));

select pg_basetype(cast('mytext_child_1' as REGTYPE));

select pg_basetype(1);

drop DOMAIN mytext cascade;

create domain constraint_enforced_dom as INT;

drop DOMAIN constraint_enforced_dom;

select
  *
from
  information_schema.column_domain_usage
where
  domain_name in ('con', 'dom', 'pos_int', 'things')
order by domain_name;

select
  *
from
  information_schema.domain_constraints
where
  domain_name in ('con', 'dom', 'pos_int', 'things')
order by constraint_name;

select
  *
from
  information_schema.domains
where
  domain_name in ('con', 'dom', 'pos_int', 'things')
order by domain_name;

select
  *
from
  information_schema.check_constraints
where
  (constraint_schema, constraint_name) in
  (
    select
      constraint_schema,
      constraint_name
    from
      information_schema.domain_constraints
    where
      domain_name in ('con', 'dom', 'pos_int', 'things')
  )
order by constraint_name;
