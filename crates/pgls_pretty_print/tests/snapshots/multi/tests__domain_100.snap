---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/domain.sql
---
create domain domaindroptest as int;

comment on domain domaindroptest is 'About to drop this..';

create domain dependenttypetest as domaindroptest;

drop domain domaindroptest;

drop domain domaindroptest cascade;

drop domain domaindroptest cascade;

create domain d_fail as no_such_type;

create domain d_fail as int constraint "cc" references this_table_not_exists (i);

create domain d_fail as int not null null;

create domain d_fail as int not null default 3 default 3;

create domain d_fail as int default (3 + 'h');

create domain d_fail as int collate "C";

create domain d_fail as anyelement;

create domain d_fail as int unique;

create domain d_fail as int primary key;

create domain d_fail as int constraint "cc" generated by default as identity;

create domain d_fail as int constraint "cc" check (values > 1) no inherit;

create domain d_fail as int constraint "cc" check (values > 1) deferrable;

create domain domainvarchar as varchar(5);

create domain domainnumeric as numeric(8, 2);

create domain domainint4 as int;

create domain domaintext as text;

select cast('123456' as domainvarchar);

select cast('12345' as domainvarchar);

create table basictest (
  testint4 domainint4,
  testtext domaintext,
  testvarchar domainvarchar,
  testnumeric domainnumeric
);

insert into basictest values ('88', 'haha', 'short', '123.12');

insert into basictest values ('88', 'haha', 'short text', '123.12');

insert into basictest values ('88', 'haha', 'short', '123.1212');

select * from basictest;

select testtext || testvarchar as concat, testnumeric + 42 as sum from basictest;

select pg_typeof(coalesce(cast(4 as domainint4), 7));

select pg_typeof(coalesce(cast(4 as domainint4), cast(7 as domainint4)));

drop table basictest;

drop domain domainvarchar;

drop domain domainnumeric;

drop domain domainint4;

drop domain domaintext;

create domain positiveint as int check (value > 0);

create domain weirdfloat as double precision check (1 / value < 10);

select pg_input_is_valid('1', 'positiveint');

select pg_input_is_valid('junk', 'positiveint');

select pg_input_is_valid('-1', 'positiveint');

select * from pg_input_error_info('junk', 'positiveint');

select * from pg_input_error_info('-1', 'positiveint');

select * from pg_input_error_info('junk', 'weirdfloat');

select * from pg_input_error_info('0.01', 'weirdfloat');

select * from pg_input_error_info('0', 'weirdfloat');

drop domain positiveint;

drop domain weirdfloat;

create domain domainint4arr as int[1];

create domain domainchar4arr as varchar(4)[2][3];

create table domarrtest (
  testint4arr domainint4arr,
  testchar4arr domainchar4arr
);

insert into domarrtest values ('{2,2}', '{{"a","b"},{"c","d"}}');

insert into domarrtest values ('{{2,2},{2,2}}', '{{"a","b"}}');

insert into domarrtest values ('{2,2}', '{{"a","b"},{"c","d"},{"e","f"}}');

insert into domarrtest values ('{2,2}', '{{"a"},{"c"}}');

insert into domarrtest values (null, '{{"a","b","c"},{"d","e","f"}}');

insert into domarrtest values (null, '{{"toolong","b","c"},{"d","e","f"}}');

insert into domarrtest (testint4arr[1], testint4arr[3]) values (11, 22);

select * from domarrtest;

select testint4arr[1], testchar4arr[2:2] from domarrtest;

select array_dims(testint4arr), array_dims(testchar4arr) from domarrtest;

select * from domarrtest;

update domarrtest
set testint4arr[1] = testint4arr[1] + 1,
testint4arr[3] = testint4arr[3] - 1
where
  testchar4arr is null;

select * from domarrtest where testchar4arr is null;

drop table domarrtest;

drop domain domainint4arr;

drop domain domainchar4arr;

create domain dia as int[];

select cast('{1,2,3}' as dia);

select array_dims(cast('{1,2,3}' as dia));

select pg_typeof(cast('{1,2,3}' as dia));

select pg_typeof(cast('{1,2,3}' as dia) || 42);

drop domain dia;

create type comptype as (r double precision, i double precision);

create domain dcomptype as comptype;

create table dcomptable (d1 dcomptype unique);

insert into dcomptable values (cast(row(1, 2) as dcomptype));

insert into dcomptable values (cast(row(3, 4) as comptype));

insert into dcomptable values (cast(row(1, 2) as dcomptype));

insert into dcomptable (d1."r") values (11);

select * from dcomptable;

select d1.r, d1.i, d1.* from dcomptable;

update dcomptable set d1."r" = d1.r + 1 where d1.i > 0;

select * from dcomptable;

alter domain dcomptype add constraint "c1" check (value.r <= value.i);

alter domain dcomptype add constraint "c2" check (value.r > value.i);

select cast(row(2, 1) as dcomptype);

insert into dcomptable values (cast(row(1, 2) as comptype));

insert into dcomptable values (cast(row(2, 1) as comptype));

insert into dcomptable (d1."r") values (99);

insert into dcomptable (d1."r", d1."i") values (99, 100);

insert into dcomptable (d1."r", d1."i") values (100, 99);

update dcomptable set d1."r" = d1.r + 1 where d1.i > 0;

update dcomptable set d1."r" = d1.r - 1, d1."i" = d1.i + 1 where d1.i > 0;

select * from dcomptable;

update dcomptable set d1."r" = d1.r - 1, d1."i" = d1.i + 1 where d1.i > 0;

create rule silly
as on delete to dcomptable
do instead
  update dcomptable
  set d1."r" = d1.r - 1,
  d1."i" = d1.i + 1
  where
    d1.i > 0;;

create function makedcomp(r double precision, i double precision)
returns dcomptype
as $function$
select row(r, i)
$function$
language sql;

select makedcomp(1, 2);

select makedcomp(2, 1);

select * from makedcomp(1, 2) as m;

select m, m is not null from makedcomp(1, 2) as m;

drop function makedcomp(double precision, double precision);

drop table dcomptable;

drop type comptype cascade;

create type comptype as (r double precision, i double precision);

create domain dcomptype as comptype;

alter domain dcomptype add constraint "c1" check (value.r > 0);

comment on constraint c1 on domain dcomptype is 'random commentary';

select cast(row(0, 1) as dcomptype);

alter type comptype
  alter attribute r type varchar;

alter type comptype
  alter attribute r type bigint;

alter type comptype
  drop attribute r;

alter type comptype
  drop attribute i;

select
  conname,
  obj_description(oid, 'pg_constraint')
from
  pg_constraint
where
  contypid = cast('dcomptype' as regtype);

drop type comptype cascade;

create type comptype as (r double precision, i double precision);

create domain dcomptypea as comptype[];

create table dcomptable (d1 dcomptypea unique);

insert into dcomptable values (cast(array[row(1, 2)] as dcomptypea));

insert into dcomptable values (cast(array[row(3, 4), row(5, 6)] as comptype[]));

insert into dcomptable values (array[cast(row(7, 8) as comptype), cast(row(9, 10) as comptype)]);

insert into dcomptable values (cast(array[row(1, 2)] as dcomptypea));

insert into dcomptable (d1[1]) values (row(9, 10));

insert into dcomptable (d1[1]."r") values (11);

select * from dcomptable;

select d1[2], d1[1].r, d1[1].i from dcomptable;

update dcomptable set d1[2] = row(d1[2].i, d1[2].r);

select * from dcomptable;

update dcomptable set d1[1]."r" = d1[1].r + 1 where d1[1].i > 0;

select * from dcomptable;

alter domain dcomptypea add constraint "c1" check (value[1].r <= value[1].i);

alter domain dcomptypea add constraint "c2" check (value[1].r > value[1].i);

select cast(array[row(2, 1)] as dcomptypea);

insert into dcomptable values (cast(array[row(1, 2)] as comptype[]));

insert into dcomptable values (cast(array[row(2, 1)] as comptype[]));

insert into dcomptable (d1[1]."r") values (99);

insert into dcomptable (d1[1]."r", d1[1]."i") values (99, 100);

insert into dcomptable (d1[1]."r", d1[1]."i") values (100, 99);

update dcomptable set d1[1]."r" = d1[1].r + 1 where d1[1].i > 0;

update dcomptable set d1[1]."r" = d1[1].r - 1, d1[1]."i" = d1[1].i + 1 where d1[1].i > 0;

select * from dcomptable;

update dcomptable set d1[1]."r" = d1[1].r - 1, d1[1]."i" = d1[1].i + 1 where d1[1].i > 0;

create rule silly
as on delete to dcomptable
do instead
  update dcomptable
  set d1[1]."r" = d1[1].r - 1,
  d1[1]."i" = d1[1].i + 1
  where
    d1[1].i > 0;;

drop table dcomptable;

drop type comptype cascade;

create domain posint as int check (value > 0);

create table pitable (f1 posint[]);

insert into pitable values (array[42]);

insert into pitable values (array[-1]);

insert into pitable values ('{0}');

update pitable set f1[1] = f1[1] + 1;

update pitable set f1[1] = 0;

select * from pitable;

drop table pitable;

create domain vc4 as varchar(4);

create table vc4table (f1 vc4[]);

insert into vc4table values (array['too long']);

insert into vc4table values (cast(array['too long'] as vc4[]));

select * from vc4table;

drop table vc4table;

drop type vc4;

create domain dposinta as posint[];

create table dposintatable (f1 dposinta[]);

insert into dposintatable values (array[array[42]]);

insert into dposintatable values (array[cast(array[42] as posint[])]);

insert into dposintatable values (array[cast(array[42] as dposinta)]);

select f1, f1[1], f1[1][1] from dposintatable;

select pg_typeof(f1) from dposintatable;

select pg_typeof(f1[1]) from dposintatable;

select pg_typeof(f1[1][1]) from dposintatable;

select pg_typeof(f1[1][1]) from dposintatable;

update dposintatable set f1[2] = array[99];

select f1, f1[1], f1[2][1] from dposintatable;

update dposintatable set f1[2][1] = array[97];

drop table dposintatable;

drop domain posint cascade;

create type comptype as (cf1 int, cf2 int);

create domain dcomptype as comptype check (value.cf1 > 0);

create table dcomptable (f1 dcomptype[]);

insert into dcomptable values (null);

update dcomptable set f1[1]."cf2" = 5;

select * from dcomptable;

update dcomptable set f1[1]."cf1" = -1;

update dcomptable set f1[1]."cf1" = 1;

select * from dcomptable;

alter domain dcomptype drop constraint dcomptype_check;

update dcomptable set f1[1]."cf1" = -1;

select * from dcomptable;

drop table dcomptable;

drop type comptype cascade;

create domain dnotnull as varchar(15) not null;

create domain dnull as varchar(15);

create domain dcheck as varchar(15) not null check (value = 'a' or value = 'c' or value = 'd');

create table nulltest (
  col1 dnotnull,
  col2 dnotnull null,
  col3 dnull not null,
  col4 dnull,
  col5 dcheck check (col5 in ('c', 'd'))
);

insert into nulltest default values;

insert into nulltest values ('a', 'b', 'c', 'd', 'c');

insert into nulltest values ('a', 'b', 'c', 'd', null);

insert into nulltest values ('a', 'b', 'c', 'd', 'a');

insert into nulltest values (null, 'b', 'c', 'd', 'd');

insert into nulltest values ('a', null, 'c', 'd', 'c');

insert into nulltest values ('a', 'b', null, 'd', 'c');

insert into nulltest values ('a', 'b', 'c', null, 'd');

select * from nulltest;

select cast('1' as dnotnull);

select cast(null as dnotnull);

select cast(cast(null as dnull) as dnotnull);

select cast(col4 as dnotnull) from nulltest;

drop table nulltest;

drop domain dnotnull;

drop domain dnull;

drop domain dcheck;

create domain ddef1 as int default 3;

create domain ddef2 as oid default '12';

create domain ddef3 as text default 5;

create sequence ddef4_seq;

create domain ddef4 as int default nextval('ddef4_seq');

create domain ddef5 as numeric(8, 2) not null default '12.12';

create table defaulttest (
  col1 ddef1,
  col2 ddef2,
  col3 ddef3,
  col4 ddef4 primary key,
  col5 ddef1 not null default null,
  col6 ddef2 default '88',
  col7 ddef4 default 8000,
  col8 ddef5
);

insert into defaulttest (col4) values (0);

alter table defaulttest
  alter column col5 drop default;

insert into defaulttest default values;

alter table defaulttest
  alter column col5 set default null;

insert into defaulttest (col4) values (0);

alter table defaulttest
  alter column col5 drop default;

insert into defaulttest default values;

insert into defaulttest default values;

select * from defaulttest;

drop table defaulttest cascade;

create domain dnotnulltest as int;

create table domnotnull (
  col1 dnotnulltest,
  col2 dnotnulltest
);

insert into domnotnull default values;

alter domain dnotnulltest set not null;

update domnotnull set col1 = 5;

alter domain dnotnulltest set not null;

update domnotnull set col2 = 6;

alter domain dnotnulltest set not null;

update domnotnull set col1 = null;

alter domain dnotnulltest drop not null;

update domnotnull set col1 = null;

update domnotnull set col1 = 5;

alter domain dnotnulltest add constraint "dnotnulltest_notnull" not null;

update domnotnull set col1 = null;

select
  conname,
  pg_get_constraintdef(oid)
from
  pg_constraint
where
  contypid = cast('dnotnulltest' as regtype);

alter domain dnotnulltest drop constraint dnotnulltest_notnull;

update domnotnull set col1 = null;

drop domain dnotnulltest cascade;

create table domdeftest (col1 ddef1);

insert into domdeftest default values;

select * from domdeftest;

alter domain ddef1 set default '42';

insert into domdeftest default values;

select * from domdeftest;

alter domain ddef1 drop default;

insert into domdeftest default values;

select * from domdeftest;

drop table domdeftest;

create domain con as int;

create table domcontest (col1 con);

insert into domcontest values (1);

insert into domcontest values (2);

alter domain con add constraint "t" check (value < 1);

alter domain con add constraint "t" check (value < 34);

alter domain con add check (value > 0);

insert into domcontest values (-5);

insert into domcontest values (42);

insert into domcontest values (5);

alter domain con drop constraint t;

insert into domcontest values (-5);

insert into domcontest values (42);

alter domain con drop constraint nonexistent;

alter domain con drop constraint if exists nonexistent;

create domain connotnull as int;

create table domconnotnulltest (
  col1 connotnull,
  col2 connotnull
);

insert into domconnotnulltest default values;

alter domain connotnull add not null;

update domconnotnulltest set col1 = 5;

alter domain connotnull add not null;

update domconnotnulltest set col2 = 6;

alter domain connotnull add constraint "constr1" not null;

select COUNT(*) from pg_constraint where contypid = cast('connotnull' as regtype) and contype = 'n';

alter domain connotnull add constraint "constr1bis" not null;

select COUNT(*) from pg_constraint where contypid = cast('connotnull' as regtype) and contype = 'n';

update domconnotnulltest set col1 = null;

alter domain connotnull drop constraint constr1;

update domconnotnulltest set col1 = null;

drop domain connotnull cascade;

drop table domconnotnulltest;

create domain things as int;

create table thethings (stuff things);

insert into thethings (stuff) values (55);

alter domain things add constraint "meow" check (value < 11);

alter domain things add constraint "meow" check (value < 11) not valid;

alter domain things validate constraint meow;

update thethings set stuff = 10;

alter domain things validate constraint meow;

create table domtab (col1 int);

create domain dom as int;

create view domview
as select cast(col1 as dom) from domtab;

insert into domtab (col1) values (null);

insert into domtab (col1) values (5);

select * from domview;

alter domain dom set not null;

select * from domview;

alter domain dom drop not null;

select * from domview;

alter domain dom add constraint "domchkgt6" check (value > 6);

select * from domview;

alter domain dom drop constraint domchkgt6;

select * from domview;

drop domain ddef1;

drop domain ddef2;

drop domain ddef3;

drop domain ddef4;

drop domain ddef5;

drop sequence ddef4_seq;

create domain vchar4 as varchar(4);

create domain dinter as vchar4 check (SUBSTRING(value from 1 for 1) = 'x');

create domain dtop as dinter check (SUBSTRING(value from 2 for 1) = '1');

select cast('x123' as dtop);

select cast('x1234' as dtop);

select cast('y1234' as dtop);

select cast('y123' as dtop);

select cast('yz23' as dtop);

select cast('xz23' as dtop);

create temporary table dtest (f1 dtop);

insert into dtest values ('x123');

insert into dtest values ('x1234');

insert into dtest values ('y1234');

insert into dtest values ('y123');

insert into dtest values ('yz23');

insert into dtest values ('xz23');

drop table dtest;

drop domain vchar4 cascade;

create domain str_domain as text not null;

create table domain_test (
  a int,
  b int
);

insert into domain_test values (1, 2);

insert into domain_test values (1, 2);

alter table domain_test
  add column c str_domain;

create domain int_domain1 as int constraint "nn1" not null constraint "nn2" not null;

create domain str_domain2 as text check (value <> 'foo') default 'foo';

alter table domain_test
  add column d str_domain2;

create domain pos_int as int check (value > 0) not null;

prepare s1 as select cast($1 as pos_int) = 10 as is_ten;;

execute s1 (10);

execute s1 (0);

execute s1 (null);

create function doubledecrement(p1 pos_int)
returns pos_int
as $function$
declare v pos_int;
begin
    return p1;
end
$function$
language plpgsql;

select doubledecrement(3);

create or replace function doubledecrement(p1 pos_int)
returns pos_int
as $function$
declare v pos_int := 0;
begin
    return p1;
end
$function$
language plpgsql;

select doubledecrement(3);

create or replace function doubledecrement(p1 pos_int)
returns pos_int
as $function$
declare v pos_int := 1;
begin
    v := p1 - 1;
    return v - 1;
end
$function$
language plpgsql;

select doubledecrement(null);

select doubledecrement(0);

select doubledecrement(1);

select doubledecrement(2);

select doubledecrement(3);

create domain posint as int;

create type ddtest1 as (f1 posint);

create table ddtest2 (f1 ddtest1);

insert into ddtest2 values (row(-1));

alter domain posint add constraint "c1" check (value >= 0);

drop table ddtest2;

create table ddtest2 (f1 ddtest1[]);

insert into ddtest2 values ('{(-1)}');

alter domain posint add constraint "c1" check (value >= 0);

drop table ddtest2;

create domain ddtest1d as ddtest1;

create table ddtest2 (f1 ddtest1d);

insert into ddtest2 values ('(-1)');

alter domain posint add constraint "c1" check (value >= 0);

drop table ddtest2;

drop domain ddtest1d;

create domain ddtest1d as ddtest1[];

create table ddtest2 (f1 ddtest1d);

insert into ddtest2 values ('{(-1)}');

alter domain posint add constraint "c1" check (value >= 0);

drop table ddtest2;

drop domain ddtest1d;

create type rposint as range (subtype = posint);

create table ddtest2 (f1 rposint);

insert into ddtest2 values ('(-1,3]');

alter domain posint add constraint "c1" check (value >= 0);

drop table ddtest2;

drop type rposint;

alter domain posint add constraint "c1" check (value >= 0);

create domain posint2 as posint check (value % 2 = 0);

create table ddtest2 (f1 posint2);

insert into ddtest2 values (11);

insert into ddtest2 values (-2);

insert into ddtest2 values (2);

alter domain posint add constraint "c2" check (value >= 10);

alter domain posint add constraint "c2" check (value > 0);

drop table ddtest2;

drop type ddtest1;

drop domain posint cascade;

create or replace function array_elem_check(numeric)
returns numeric
as $function$
declare
  x numeric(4,2)[1];
begin
  x[1] := $1;
  return x[1];
end
$function$
language plpgsql;

select array_elem_check(121.00);

select array_elem_check(1.23456);

create domain mynums as numeric(4, 2)[1];

create or replace function array_elem_check(numeric)
returns numeric
as $function$
declare
  x mynums;
begin
  x[1] := $1;
  return x[1];
end
$function$
language plpgsql;

select array_elem_check(121.00);

select array_elem_check(1.23456);

create domain mynums2 as mynums;

create or replace function array_elem_check(numeric)
returns numeric
as $function$
declare
  x mynums2;
begin
  x[1] := $1;
  return x[1];
end
$function$
language plpgsql;

select array_elem_check(121.00);

select array_elem_check(1.23456);

drop function array_elem_check(numeric);

create domain orderedpair as int[2] check (value[1] < value[2]);

select cast(array[1, 2] as orderedpair);

select cast(array[2, 1] as orderedpair);

create temporary table op (f1 orderedpair);

insert into op values (array[1, 2]);

insert into op values (array[2, 1]);

update op set f1[2] = 3;

update op set f1[2] = 0;

select * from op;

create or replace function array_elem_check(int)
returns int
as $function$
declare
  x orderedpair := '{1,2}';
begin
  x[2] := $1;
  return x[2];
end
$function$
language plpgsql;

select array_elem_check(3);

select array_elem_check(-1);

drop function array_elem_check(int);

create domain di as int;

create function dom_check(int)
returns di
as $function$
declare d di;
begin
  d := $1::di;
  return d;
end
$function$
language plpgsql
immutable;

select dom_check(0);

alter domain di add constraint "pos" check (value > 0);

select dom_check(0);

alter domain di drop constraint pos;

select dom_check(0);

create or replace function dom_check(int)
returns di
as $function$
declare d di;
begin
  d := $1;
  return d;
end
$function$
language plpgsql
immutable;

select dom_check(0);

alter domain di add constraint "pos" check (value > 0);

select dom_check(0);

alter domain di drop constraint pos;

select dom_check(0);

drop function dom_check(int);

drop domain di;

create function sql_is_distinct_from(anyelement, anyelement)
returns boolean
language sql
as $function$
select $1 is distinct from $2 limit 1
$function$;

create domain inotnull as int check (sql_is_distinct_from(value, null));

select cast(1 as inotnull);

select cast(null as inotnull);

create table dom_table (x inotnull);

insert into dom_table values ('1');

insert into dom_table values (1);

insert into dom_table values (null);

drop table dom_table;

drop domain inotnull;

drop function sql_is_distinct_from(anyelement, anyelement);

create domain testdomain1 as int;

alter domain testdomain1 rename to testdomain2;

alter type testdomain2 rename to testdomain3;

drop domain testdomain3;

create domain testdomain1 as int constraint "unsigned" check (value > 0);

alter domain testdomain1 rename constraint unsigned to unsigned_foo;

alter domain testdomain1 drop constraint unsigned_foo;

drop domain testdomain1;

create domain mytext as text;

create domain mytext_child_1 as mytext;

select pg_basetype(cast('mytext' as regtype));

select pg_basetype(cast('mytext_child_1' as regtype));

select pg_basetype(1);

drop domain mytext cascade;

create domain constraint_enforced_dom as int;

drop domain constraint_enforced_dom;

select
  *
from
  information_schema.column_domain_usage
where
  domain_name in ('con', 'dom', 'pos_int', 'things')
order by domain_name;

select
  *
from
  information_schema.domain_constraints
where
  domain_name in ('con', 'dom', 'pos_int', 'things')
order by constraint_name;

select
  *
from
  information_schema.domains
where
  domain_name in ('con', 'dom', 'pos_int', 'things')
order by domain_name;

select
  *
from
  information_schema.check_constraints
where
  (constraint_schema, constraint_name) in
  (
    select
      constraint_schema,
      constraint_name
    from
      information_schema.domain_constraints
    where
      domain_name in ('con', 'dom', 'pos_int', 'things')
  )
order by constraint_name;
