---
source: crates/pgls_pretty_print/tests/tests.rs
assertion_line: 160
input_file: crates/pgls_pretty_print/tests/data/multi/insert_conflict_60.sql
---
CREATE TABLE insertconflicttest ( key INT, fruit TEXT );

CREATE VIEW insertconflictview AS
SELECT
  *
FROM
  insertconflicttest;

CREATE UNIQUE
INDEX "op_index_key" ON insertconflicttest USING btree (key,
fruit text_pattern_ops);

CREATE UNIQUE
INDEX "collation_index_key" ON insertconflicttest USING btree (key,
fruit COLLATE "C");

CREATE UNIQUE
INDEX "both_index_key" ON insertconflicttest USING btree (key,
fruit COLLATE "C" text_pattern_ops);

CREATE UNIQUE
INDEX "both_index_expr_key" ON insertconflicttest USING btree (key,
lower(fruit) COLLATE "C" text_pattern_ops);

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (key) DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (fruit) DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (key,
fruit) DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (fruit,
key,
fruit,
key) DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (lower(fruit),
key,
lower(fruit),
key) DO NOTHING;

INSERT INTO insertconflictview
VALUES (0,
'Crowberry')
ON CONFLICT (lower(fruit),
key,
lower(fruit),
key) DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (key,
fruit) DO
UPDATE
SET fruit = excluded.fruit
WHERE
  EXISTS (SELECT
    1
  FROM
    insertconflicttest AS ii
  WHERE
    ii.key =
    excluded.key);

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (key,
fruit text_pattern_ops) DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (key,
fruit COLLATE "C") DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (fruit COLLATE "C" text_pattern_ops,
key) DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (lower(fruit) COLLATE "C",
key,
key) DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (fruit,
key,
fruit text_pattern_ops,
key) DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (lower(fruit) COLLATE "C" text_pattern_ops,
key,
key) DO NOTHING;

DROP INDEX "op_index_key";

DROP INDEX "collation_index_key";

DROP INDEX "both_index_key";

DROP INDEX "both_index_expr_key";

CREATE UNIQUE
INDEX "cross_match" ON insertconflicttest USING btree (lower(fruit) COLLATE "C",
upper(fruit) text_pattern_ops);

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (lower(fruit) text_pattern_ops,
upper(fruit) COLLATE "C") DO NOTHING;

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (lower(fruit) COLLATE "C",
upper(fruit) text_pattern_ops) DO NOTHING;

DROP INDEX "cross_match";

CREATE UNIQUE
INDEX "key_index" ON insertconflicttest USING btree (key);

INSERT INTO insertconflicttest
VALUES (0,
'Bilberry')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (0,
'Bilberry')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit
WHERE
  insertconflicttest.fruit <>
  'Cawesh';

INSERT INTO insertconflicttest
VALUES (0,
'Crowberry')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit
WHERE
  excluded.fruit <>
  'Elderberry';

INSERT INTO insertconflicttest
VALUES (0,
'Bilberry')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit
WHERE
  insertconflicttest.fruit <>
  'Lime'
RETURNING *;

INSERT INTO insertconflicttest
VALUES (1,
'Apple')
ON CONFLICT DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (1,
'Apple')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (2,
'Orange')
ON CONFLICT (key,
key,
key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (1,
'Apple'),
(2,
'Orange')
ON CONFLICT (key) DO
UPDATE
SET (fruit,
key) = (excluded.fruit,
excluded.key);

INSERT INTO insertconflicttest
VALUES (1,
'Apple')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit
RETURNING excluded.fruit;

INSERT INTO insertconflicttest
VALUES (1,
'Apple')
ON CONFLICT (keyy) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (1,
'Apple')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruitt;

INSERT INTO insertconflicttest
VALUES (3,
'Kiwi')
ON CONFLICT (key,
fruit) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (4,
'Mango')
ON CONFLICT (fruit,
key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (5,
'Lemon')
ON CONFLICT (fruit) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (6,
'Passionfruit')
ON CONFLICT (lower(fruit)) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest AS ict
VALUES (6,
'Passionfruit')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest AS ict
VALUES (6,
'Passionfruit')
ON CONFLICT (key) DO
UPDATE
SET fruit = ict.fruit;

INSERT INTO insertconflicttest AS ict
VALUES (6,
'Passionfruit')
ON CONFLICT (key) DO
UPDATE
SET fruit = insertconflicttest.fruit;

INSERT INTO insertconflicttest
VALUES (3,
'Kiwi')
ON CONFLICT (key,
fruit) DO
UPDATE
SET insertconflicttest."fruit" = 'Mango';

DROP INDEX "key_index";

CREATE UNIQUE
INDEX "comp_key_index" ON insertconflicttest USING btree (key,
fruit);

INSERT INTO insertconflicttest
VALUES (7,
'Raspberry')
ON CONFLICT (key,
fruit) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (8,
'Lime')
ON CONFLICT (fruit,
key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (9,
'Banana')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (10,
'Blueberry')
ON CONFLICT (key,
key,
key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (11,
'Cherry')
ON CONFLICT (key,
lower(fruit)) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (12,
'Date')
ON CONFLICT (lower(fruit),
key) DO
UPDATE
SET fruit = excluded.fruit;

DROP INDEX "comp_key_index";

CREATE UNIQUE
INDEX "part_comp_key_index" ON insertconflicttest USING btree (key,
fruit) WHERE
  key <
  5;

CREATE UNIQUE
INDEX "expr_part_comp_key_index" ON insertconflicttest USING btree (key,
lower(fruit)) WHERE
  key <
  5;

INSERT INTO insertconflicttest
VALUES (13,
'Grape')
ON CONFLICT (key,
fruit) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (14,
'Raisin')
ON CONFLICT (fruit,
key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (15,
'Cranberry')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (16,
'Melon')
ON CONFLICT (key,
key,
key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (17,
'Mulberry')
ON CONFLICT (key,
lower(fruit)) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (18,
'Pineapple')
ON CONFLICT (lower(fruit),
key) DO
UPDATE
SET fruit = excluded.fruit;

DROP INDEX "part_comp_key_index";

DROP INDEX "expr_part_comp_key_index";

CREATE UNIQUE
INDEX "expr_key_index" ON insertconflicttest USING btree (lower(fruit));

INSERT INTO insertconflicttest
VALUES (20,
'Quince')
ON CONFLICT (lower(fruit)) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (21,
'Pomegranate')
ON CONFLICT (lower(fruit),
lower(fruit)) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (22,
'Apricot')
ON CONFLICT (upper(fruit)) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (23,
'Blackberry')
ON CONFLICT (fruit) DO
UPDATE
SET fruit = excluded.fruit;

DROP INDEX "expr_key_index";

CREATE UNIQUE
INDEX "expr_comp_key_index" ON insertconflicttest USING btree (key,
lower(fruit));

CREATE UNIQUE
INDEX "tricky_expr_comp_key_index" ON insertconflicttest USING btree (key,
lower(fruit),
upper(fruit));

INSERT INTO insertconflicttest
VALUES (24,
'Plum')
ON CONFLICT (key,
lower(fruit)) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (25,
'Peach')
ON CONFLICT (lower(fruit),
key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (26,
'Fig')
ON CONFLICT (lower(fruit),
key,
lower(fruit),
key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (27,
'Prune')
ON CONFLICT (key,
upper(fruit)) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (28,
'Redcurrant')
ON CONFLICT (fruit,
key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (29,
'Nectarine')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit;

DROP INDEX "expr_comp_key_index";

DROP INDEX "tricky_expr_comp_key_index";

CREATE UNIQUE
INDEX "key_index" ON insertconflicttest USING btree (key);

CREATE UNIQUE
INDEX "fruit_index" ON insertconflicttest USING btree (fruit);

INSERT INTO insertconflicttest
VALUES (26,
'Fig')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (26,
'Peach')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (25,
'Fig')
ON CONFLICT (fruit) DO
UPDATE
SET fruit = excluded.fruit;

DROP INDEX "key_index";

DROP INDEX "fruit_index";

CREATE UNIQUE
INDEX "partial_key_index" ON insertconflicttest USING btree (key) WHERE
  fruit LIKE '%berry';

INSERT INTO insertconflicttest
VALUES (23,
'Blackberry')
ON CONFLICT (key) WHERE
  fruit LIKE '%berry' DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest AS t
VALUES (23,
'Blackberry')
ON CONFLICT (key) WHERE
  fruit LIKE '%berry' AND
  t.fruit =
  'inconsequential' DO NOTHING;

INSERT INTO insertconflictview AS t
VALUES (23,
'Blackberry')
ON CONFLICT (key) WHERE
  fruit LIKE '%berry' AND
  t.fruit =
  'inconsequential' DO NOTHING;

INSERT INTO insertconflicttest
VALUES (23,
'Blackberry')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit;

INSERT INTO insertconflicttest
VALUES (23,
'Blackberry')
ON CONFLICT (key) WHERE
  fruit LIKE '%berry' OR
  fruit =
  'consequential' DO NOTHING;

INSERT INTO insertconflicttest
VALUES (23,
'Blackberry')
ON CONFLICT (fruit) WHERE
  fruit LIKE '%berry' DO
UPDATE
SET fruit = excluded.fruit;

DROP INDEX "partial_key_index";

CREATE UNIQUE
INDEX "plain" ON insertconflicttest USING btree (key);

INSERT INTO insertconflicttest AS i
VALUES (23,
'Jackfruit')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit
WHERE
  i.* <>
  excluded.*
RETURNING *;

INSERT INTO insertconflicttest AS i
VALUES (23,
'Jackfruit')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit
WHERE
  i.* <>
  excluded.*
RETURNING *;

INSERT INTO insertconflicttest AS i
VALUES (23,
'Jackfruit')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit
WHERE
  i.* =
  excluded.*
RETURNING *;

INSERT INTO insertconflicttest AS i
VALUES (23,
'Avocado')
ON CONFLICT (key) DO
UPDATE
SET fruit = CAST(excluded.* AS TEXT)
RETURNING *;

INSERT INTO insertconflicttest AS i
VALUES (23,
'Avocado')
ON CONFLICT (key) DO
UPDATE
SET fruit = excluded.fruit
WHERE
  excluded.* IS NULL;

INSERT INTO insertconflicttest AS i
VALUES (23,
'Avocado')
ON CONFLICT (key) DO
UPDATE
SET fruit = CAST(excluded.* AS TEXT);

DROP INDEX "plain";

DROP VIEW "insertconflictview";

DROP TABLE "insertconflicttest";

CREATE TABLE syscolconflicttest ( key INT, data TEXT );

INSERT INTO syscolconflicttest VALUES (1);

INSERT INTO syscolconflicttest
VALUES (1)
ON CONFLICT (key) DO
UPDATE
SET data = CAST(excluded.ctid AS TEXT);

DROP TABLE "syscolconflicttest";

CREATE TABLE insertconflict ( a BIGINT, b BIGINT );

CREATE UNIQUE
INDEX "insertconflicti1" ON insertconflict USING btree (COALESCE(a,
0));

CREATE UNIQUE
INDEX "insertconflicti2" ON insertconflict USING btree (b) WHERE
  COALESCE(a,
  1) >
  0;

INSERT INTO insertconflict
VALUES (1,
2)
ON CONFLICT (COALESCE(a,
0)) DO NOTHING;

INSERT INTO insertconflict
VALUES (1,
2)
ON CONFLICT (b) WHERE
  COALESCE(a,
  1) >
  0 DO NOTHING;

INSERT INTO insertconflict
VALUES (1,
2)
ON CONFLICT (b) WHERE
  COALESCE(a,
  1) >
  1 DO NOTHING;

DROP TABLE "insertconflict";

CREATE TABLE insertconflict ( f1 INT PRIMARY KEY, f2 TEXT );

CREATE VIEW insertconflictv AS
SELECT
  *
FROM
  insertconflict WITH CASCADED CHECK OPTION;

INSERT INTO insertconflictv
VALUES (1,
'foo')
ON CONFLICT (f1) DO
UPDATE
SET f2 = excluded.f2;

SELECT * FROM insertconflict;

INSERT INTO insertconflictv
VALUES (1,
'bar')
ON CONFLICT (f1) DO
UPDATE
SET f2 = excluded.f2;

SELECT * FROM insertconflict;

DROP VIEW "insertconflictv";

DROP TABLE "insertconflict";

CREATE TABLE cities (
  name TEXT,
  population DOUBLE PRECISION,
  altitude INT
);

CREATE TABLE capitals ( state CHAR(2) ) INHERITS (cities);

CREATE UNIQUE
INDEX "cities_names_unique" ON cities USING btree (name);

CREATE UNIQUE
INDEX "capitals_names_unique" ON capitals USING btree (name);

INSERT INTO cities VALUES ('San Francisco', 7.24E+5, 63);

INSERT INTO cities VALUES ('Las Vegas', 2.583E+5, 2174);

INSERT INTO cities VALUES ('Mariposa', 1200, 1953);

INSERT INTO capitals
VALUES ('Sacramento',
3.694E+5,
30,
'CA');

INSERT INTO capitals
VALUES ('Madison',
1.913E+5,
845,
'WI');

SELECT * FROM capitals;

INSERT INTO cities
VALUES ('Las Vegas',
2.583E+5,
2174)
ON CONFLICT DO NOTHING;

INSERT INTO capitals
VALUES ('Sacramento',
4664.E+5,
30,
'CA')
ON CONFLICT (name) DO
UPDATE
SET population = excluded.population;

INSERT INTO capitals
VALUES ('Sacramento',
50,
2267,
'NE')
ON CONFLICT (name) DO NOTHING;

SELECT * FROM capitals;

INSERT INTO cities
VALUES ('Las Vegas',
5.83E+5,
2001)
ON CONFLICT (name) DO
UPDATE
SET population = excluded.population,
altitude = excluded.altitude;

SELECT CAST(tableoid AS REGCLASS), * FROM cities;

INSERT INTO capitals
VALUES ('Las Vegas',
5.83E+5,
2222,
'NV')
ON CONFLICT (name) DO
UPDATE
SET population = excluded.population;

SELECT * FROM capitals;

SELECT CAST(tableoid AS REGCLASS), * FROM cities;

INSERT INTO cities
VALUES ('Las Vegas',
5.86E+5,
2223)
ON CONFLICT (name) DO
UPDATE
SET population = excluded.population,
altitude = excluded.altitude;

SELECT CAST(tableoid AS REGCLASS), * FROM cities;

DROP TABLE "capitals";

DROP TABLE "cities";

CREATE TABLE excluded ( key INT PRIMARY KEY, data TEXT );

INSERT INTO excluded VALUES (1, '1');

INSERT INTO excluded
VALUES (1,
'2')
ON CONFLICT (key) DO
UPDATE
SET data = excluded.data
RETURNING *;

INSERT INTO excluded AS target
VALUES (1,
'2')
ON CONFLICT (key) DO
UPDATE
SET data = excluded.data
RETURNING *;

INSERT INTO excluded AS target
VALUES (1,
'2')
ON CONFLICT (key) DO
UPDATE
SET data = target.data
RETURNING *;

INSERT INTO excluded
VALUES (1,
'2')
ON CONFLICT (key) DO
UPDATE
SET data = 3
RETURNING excluded.*;

DROP TABLE "excluded";

CREATE TABLE dropcol (
  key INT PRIMARY KEY,
  drop1 INT,
  keep1 TEXT,
  drop2 NUMERIC,
  keep2 DOUBLE PRECISION
);

INSERT INTO dropcol (key,
drop1,
keep1,
drop2,
keep2)
VALUES (1,
1,
'1',
'1',
1);

INSERT INTO dropcol (key,
drop1,
keep1,
drop2,
keep2)
VALUES (1,
2,
'2',
'2',
2)
ON CONFLICT (key) DO
UPDATE
SET drop1 = excluded.drop1,
keep1 = excluded.keep1,
drop2 = excluded.drop2,
keep2 = excluded.keep2
WHERE
  excluded.drop1 IS NOT NULL AND
  excluded.keep1 IS NOT NULL AND
  excluded.drop2 IS NOT NULL AND
  excluded.keep2 IS NOT NULL AND
  dropcol.drop1 IS NOT NULL AND
  dropcol.keep1 IS NOT NULL AND
  dropcol.drop2 IS NOT NULL AND
  dropcol.keep2 IS NOT NULL
RETURNING *;

INSERT INTO dropcol (key,
drop1,
keep1,
drop2,
keep2)
VALUES (1,
3,
'3',
'3',
3)
ON CONFLICT (key) DO
UPDATE
SET drop1 = dropcol.drop1,
keep1 = dropcol.keep1,
drop2 = dropcol.drop2,
keep2 = dropcol.keep2
RETURNING *;

ALTER TABLE dropcol DROP COLUMN drop1, DROP COLUMN drop2;

INSERT INTO dropcol (key,
keep1,
keep2)
VALUES (1,
'4',
4)
ON CONFLICT (key) DO
UPDATE
SET keep1 = excluded.keep1,
keep2 = excluded.keep2
WHERE
  excluded.keep1 IS NOT NULL AND
  excluded.keep2 IS NOT NULL AND
  dropcol.keep1 IS NOT NULL AND
  dropcol.keep2 IS NOT NULL
RETURNING *;

INSERT INTO dropcol (key,
keep1,
keep2)
VALUES (1,
'5',
5)
ON CONFLICT (key) DO
UPDATE
SET keep1 = dropcol.keep1,
keep2 = dropcol.keep2
RETURNING *;

DROP TABLE "dropcol";

CREATE TABLE twoconstraints (
  f1 INT UNIQUE,
  f2 box,
  EXCLUDE USING gist (f2 WITH &&)
);

INSERT INTO twoconstraints VALUES (1, '((0,0),(1,1))');

INSERT INTO twoconstraints VALUES (1, '((2,2),(3,3))');

INSERT INTO twoconstraints VALUES (2, '((0,0),(1,2))');

INSERT INTO twoconstraints
VALUES (2,
'((0,0),(1,2))')
ON CONFLICT ON CONSTRAINT twoconstraints_f1_key DO NOTHING;

INSERT INTO twoconstraints
VALUES (2,
'((0,0),(1,2))')
ON CONFLICT ON CONSTRAINT twoconstraints_f2_excl DO NOTHING;

SELECT * FROM twoconstraints;

DROP TABLE "twoconstraints";

CREATE TABLE selfconflict ( f1 INT PRIMARY KEY, f2 INT );

BEGIN ISOLATION LEVEL READ COMMITTED;

INSERT INTO selfconflict
VALUES (1,
1),
(1,
2)
ON CONFLICT DO NOTHING;

COMMIT;

BEGIN ISOLATION LEVEL REPEATABLE READ;

INSERT INTO selfconflict
VALUES (2,
1),
(2,
2)
ON CONFLICT DO NOTHING;

COMMIT;

BEGIN ISOLATION LEVEL SERIALIZABLE;

INSERT INTO selfconflict
VALUES (3,
1),
(3,
2)
ON CONFLICT DO NOTHING;

COMMIT;

BEGIN ISOLATION LEVEL READ COMMITTED;

INSERT INTO selfconflict
VALUES (4,
1),
(4,
2)
ON CONFLICT (f1) DO
UPDATE
SET f2 = 0;

COMMIT;

BEGIN ISOLATION LEVEL REPEATABLE READ;

INSERT INTO selfconflict
VALUES (5,
1),
(5,
2)
ON CONFLICT (f1) DO
UPDATE
SET f2 = 0;

COMMIT;

BEGIN ISOLATION LEVEL SERIALIZABLE;

INSERT INTO selfconflict
VALUES (6,
1),
(6,
2)
ON CONFLICT (f1) DO
UPDATE
SET f2 = 0;

COMMIT;

SELECT * FROM selfconflict;

DROP TABLE "selfconflict";

CREATE TABLE parted_conflict_test (
  a INT UNIQUE,
  b CHAR(1)
)
PARTITION
BY LIST
(a);

CREATE TABLE parted_conflict_test_1
PARTITION OF parted_conflict_test
(
  b UNIQUE
)
FOR VALUES IN (1,
2);

INSERT INTO parted_conflict_test
VALUES (1,
'a')
ON CONFLICT DO NOTHING;

INSERT INTO parted_conflict_test
VALUES (1,
'a')
ON CONFLICT (a) DO NOTHING;

INSERT INTO parted_conflict_test
VALUES (1,
'a')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b;

INSERT INTO parted_conflict_test_1
VALUES (1,
'a')
ON CONFLICT (a) DO NOTHING;

INSERT INTO parted_conflict_test_1
VALUES (1,
'b')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b;

INSERT INTO parted_conflict_test
VALUES (2,
'b')
ON CONFLICT (b) DO
UPDATE
SET a = excluded.a;

INSERT INTO parted_conflict_test_1
VALUES (2,
'b')
ON CONFLICT (b) DO
UPDATE
SET a = excluded.a;

SELECT * FROM parted_conflict_test ORDER BY a;

CREATE TABLE parted_conflict_test_2 (
  b CHAR(1),
  a INT UNIQUE
);

ALTER TABLE parted_conflict_test
  ATTACH PARTITION
  parted_conflict_test_2
  FOR VALUES IN (3);

TRUNCATE parted_conflict_test;

INSERT INTO parted_conflict_test
VALUES (3,
'a')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b;

INSERT INTO parted_conflict_test
VALUES (3,
'b')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b;

SELECT * FROM parted_conflict_test ORDER BY a;

ALTER TABLE parted_conflict_test
  DROP COLUMN b,
  ADD COLUMN b CHAR(1);

CREATE TABLE parted_conflict_test_3
PARTITION OF parted_conflict_test
FOR VALUES IN (4);

TRUNCATE parted_conflict_test;

INSERT INTO parted_conflict_test (a,
b)
VALUES (4,
'a')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b;

INSERT INTO parted_conflict_test (a,
b)
VALUES (4,
'b')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b
WHERE
  parted_conflict_test.b =
  'a';

SELECT * FROM parted_conflict_test ORDER BY a;

CREATE TABLE parted_conflict_test_4
PARTITION OF parted_conflict_test
FOR VALUES IN (5)
PARTITION
BY LIST
(a);

CREATE TABLE parted_conflict_test_4_1
PARTITION OF parted_conflict_test_4
FOR VALUES IN (5);

TRUNCATE parted_conflict_test;

INSERT INTO parted_conflict_test (a,
b)
VALUES (5,
'a')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b;

INSERT INTO parted_conflict_test (a,
b)
VALUES (5,
'b')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b
WHERE
  parted_conflict_test.b =
  'a';

SELECT * FROM parted_conflict_test ORDER BY a;

TRUNCATE parted_conflict_test;

INSERT INTO parted_conflict_test (a,
b)
VALUES (1,
'a'),
(2,
'a'),
(4,
'a')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b
WHERE
  excluded.b =
  'b';

INSERT INTO parted_conflict_test (a,
b)
VALUES (1,
'b'),
(2,
'c'),
(4,
'b')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b
WHERE
  excluded.b =
  'b';

SELECT * FROM parted_conflict_test ORDER BY a;

DROP TABLE "parted_conflict_test";

CREATE TABLE parted_conflict (
  a INT PRIMARY KEY,
  b TEXT
)
PARTITION
BY RANGE
(a);

CREATE TABLE parted_conflict_1
PARTITION OF parted_conflict
FOR VALUES FROM (0) TO (1000)
PARTITION
BY RANGE
(a);

CREATE TABLE parted_conflict_1_1
PARTITION OF parted_conflict_1
FOR VALUES FROM (0) TO (500);

INSERT INTO parted_conflict VALUES (40, 'forty');

INSERT INTO parted_conflict_1
VALUES (40,
'cuarenta')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b;

DROP TABLE "parted_conflict";

CREATE TABLE parted_conflict (
  a INT,
  b TEXT
)
PARTITION
BY RANGE
(a);

CREATE TABLE parted_conflict_1
PARTITION OF parted_conflict
FOR VALUES FROM (0) TO (1000)
PARTITION
BY RANGE
(a);

CREATE TABLE parted_conflict_1_1
PARTITION OF parted_conflict_1
FOR VALUES FROM (0) TO (500);

CREATE UNIQUE
INDEX ON ONLY parted_conflict_1 USING btree (a);

CREATE UNIQUE INDEX ON ONLY parted_conflict USING btree (a);

ALTER INDEX parted_conflict_a_idx
  ATTACH PARTITION
  parted_conflict_1_a_idx;

INSERT INTO parted_conflict VALUES (40, 'forty');

INSERT INTO parted_conflict_1
VALUES (40,
'cuarenta')
ON CONFLICT (a) DO
UPDATE
SET b = excluded.b;

DROP TABLE "parted_conflict";

CREATE TABLE parted_conflict (
  a INT,
  b TEXT,
  c INT
)
PARTITION
BY RANGE
(a);

CREATE TABLE parted_conflict_1 (
  drp TEXT,
  c INT,
  a INT,
  b TEXT
);

ALTER TABLE parted_conflict_1 DROP COLUMN drp;

CREATE UNIQUE INDEX ON parted_conflict USING btree (a, b);

ALTER TABLE parted_conflict
  ATTACH PARTITION
  parted_conflict_1
  FOR VALUES FROM (0) TO (1000);

TRUNCATE parted_conflict;

INSERT INTO parted_conflict VALUES (50, 'cincuenta', 1);

INSERT INTO parted_conflict
VALUES (50,
'cincuenta',
2)
ON CONFLICT (a,
b) DO
UPDATE
SET (a,
b,
c) = ROW(excluded.*)
WHERE
  parted_conflict =
  (50,
  CAST('cincuenta' AS TEXT),
  1) AND
  excluded =
  (50,
  CAST('cincuenta' AS TEXT),
  2);

SELECT * FROM parted_conflict ORDER BY a;

CREATE OR REPLACE FUNCTION parted_conflict_update_func()
RETURNS trigger
AS '
declare
    r record;
begin
 for r in select * from inserted loop
	raise notice ''a = %, b = %, c = %'', r.a, r.b, r.c;
 end loop;
 return new;
end;
'
LANGUAGE "plpgsql";

CREATE TRIGGER parted_conflict_update
AFTER
UPDATE
ON parted_conflict
REFERENCING NEW TABLE AS inserted
FOR EACH STATEMENT
EXECUTE FUNCTION parted_conflict_update_func();

TRUNCATE parted_conflict;

INSERT INTO parted_conflict VALUES (0, 'cero', 1);

INSERT INTO parted_conflict
VALUES (0,
'cero',
1)
ON CONFLICT (a,
b) DO
UPDATE
SET c = parted_conflict.c + 1;

DROP TABLE "parted_conflict";

DROP FUNCTION parted_conflict_update_func();
