---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/alter_table.sql
snapshot_kind: text
---
set client_min_messages = warning;

drop role if exists regress_alter_table_user1;

reset client_min_messages;

create user regress_alter_table_user1;

create table attmp (initial int);

comment on table attmp_wrong is 'table comment';

comment on table attmp is 'table comment';

comment on table attmp is null;

alter table attmp
  add column xmin int;

alter table attmp
  add column a int default 3;

alter table attmp
  add column b name;

alter table attmp
  add column c text;

alter table attmp
  add column d double precision;

alter table attmp
  add column e real;

alter table attmp
  add column f smallint;

alter table attmp
  add column g polygon;

alter table attmp
  add column i char(1);

alter table attmp
  add column k int;

alter table attmp
  add column l tid;

alter table attmp
  add column m xid;

alter table attmp
  add column n oidvector;

alter table attmp
  add column p boolean;

alter table attmp
  add column q point;

alter table attmp
  add column r lseg;

alter table attmp
  add column s path;

alter table attmp
  add column t box;

alter table attmp
  add column v timestamp;

alter table attmp
  add column w interval;

alter table attmp
  add column x double precision[];

alter table attmp
  add column y real[];

alter table attmp
  add column z smallint[];

insert into attmp (
  a,
  b,
  c,
  d,
  e,
  f,
  g,
  i,
  k,
  l,
  m,
  n,
  p,
  q,
  r,
  s,
  t,
  v,
  w,
  x,
  y,
  z
)
values
  (
    4,
    'name',
    'text',
    4.1,
    4.1,
    2,
    '(4.1,4.1,3.1,3.1)',
    'c',
    314159,
    '(1,1)',
    '512',
    '1 2 3 4 5 6 7 8',
    true,
    '(1.1,1.1)',
    '(4.1,4.1,3.1,3.1)',
    '(0,2,4.1,4.1,3.1,3.1)',
    '(4.1,4.1,3.1,3.1)',
    'epoch',
    '01:00:10',
    '{1.0,2.0,3.0,4.0}',
    '{1.0,2.0,3.0,4.0}',
    '{1,2,3,4}'
  );

select * from attmp;

drop table attmp;

create table attmp (initial int);

alter table attmp
  add column a int;

alter table attmp
  add column b name;

alter table attmp
  add column c text;

alter table attmp
  add column d double precision;

alter table attmp
  add column e real;

alter table attmp
  add column f smallint;

alter table attmp
  add column g polygon;

alter table attmp
  add column i char(1);

alter table attmp
  add column k int;

alter table attmp
  add column l tid;

alter table attmp
  add column m xid;

alter table attmp
  add column n oidvector;

alter table attmp
  add column p boolean;

alter table attmp
  add column q point;

alter table attmp
  add column r lseg;

alter table attmp
  add column s path;

alter table attmp
  add column t box;

alter table attmp
  add column v timestamp;

alter table attmp
  add column w interval;

alter table attmp
  add column x double precision[];

alter table attmp
  add column y real[];

alter table attmp
  add column z smallint[];

insert into attmp (
  a,
  b,
  c,
  d,
  e,
  f,
  g,
  i,
  k,
  l,
  m,
  n,
  p,
  q,
  r,
  s,
  t,
  v,
  w,
  x,
  y,
  z
)
values
  (
    4,
    'name',
    'text',
    4.1,
    4.1,
    2,
    '(4.1,4.1,3.1,3.1)',
    'c',
    314159,
    '(1,1)',
    '512',
    '1 2 3 4 5 6 7 8',
    true,
    '(1.1,1.1)',
    '(4.1,4.1,3.1,3.1)',
    '(0,2,4.1,4.1,3.1,3.1)',
    '(4.1,4.1,3.1,3.1)',
    'epoch',
    '01:00:10',
    '{1.0,2.0,3.0,4.0}',
    '{1.0,2.0,3.0,4.0}',
    '{1,2,3,4}'
  );

select * from attmp;

create index "attmp_idx" on attmp using btree (a, (d + e), b);

alter index attmp_idx
  alter column 1 set statistics 1000;

alter index attmp_idx
  alter column 2 set statistics 1000;

alter index attmp_idx
  alter column 3 set statistics 1000;

alter index attmp_idx
  alter column 4 set statistics 1000;

alter index attmp_idx
  alter column 2 set statistics -1;

drop table attmp;

create table attmp (regtable int);

create temporary table attmp (attmptable int);

alter table attmp rename to attmp_new;

select * from attmp;

select * from attmp_new;

alter table attmp rename to attmp_new2;

select * from attmp;

select * from attmp_new;

select * from attmp_new2;

drop table attmp_new;

drop table attmp_new2;

create table part_attmp (a int primary key)
partition by range(a);

create table part_attmp1 partition of part_attmp for values from (0) to (100);

alter index part_attmp_pkey rename to part_attmp_index;

alter index part_attmp1_pkey rename to part_attmp1_index;

alter table part_attmp rename to part_at2tmp;

alter table part_attmp1 rename to part_at2tmp1;

set role to regress_alter_table_user1;

alter index part_attmp_index rename to fail;

alter index part_attmp1_index rename to fail;

alter table part_at2tmp rename to fail;

alter table part_at2tmp1 rename to fail;

reset role;

drop table part_at2tmp;

create table attmp_array (id int);

create table attmp_array2 (id int);

select typname from pg_type where oid = cast('attmp_array[]' as regtype);

select typname from pg_type where oid = cast('attmp_array2[]' as regtype);

alter table attmp_array2 rename to _attmp_array;

select typname from pg_type where oid = cast('attmp_array[]' as regtype);

select typname from pg_type where oid = cast('_attmp_array[]' as regtype);

drop table _attmp_array;

drop table attmp_array;

create table attmp_array (id int);

select typname from pg_type where oid = cast('attmp_array[]' as regtype);

alter table attmp_array rename to _attmp_array;

select typname from pg_type where oid = cast('_attmp_array[]' as regtype);

drop table _attmp_array;

alter index if exists __onek_unique1 rename to attmp_onek_unique1;

alter index if exists __attmp_onek_unique1 rename to onek_unique1;

alter index onek_unique1 rename to attmp_onek_unique1;

alter index attmp_onek_unique1 rename to onek_unique1;

set role to regress_alter_table_user1;

alter index onek_unique1 rename to fail;

reset role;

create table alter_idx_rename_test (a int);

create index "alter_idx_rename_test_idx" on alter_idx_rename_test using btree (a);

create table alter_idx_rename_test_parted (a int)
partition by LIST(a);

create index "alter_idx_rename_test_parted_idx" on alter_idx_rename_test_parted using btree (a);

begin;

alter index alter_idx_rename_test rename to alter_idx_rename_test_2;

alter index alter_idx_rename_test_parted rename to alter_idx_rename_test_parted_2;

select
  cast(relation as regclass),
  mode
from
  pg_locks
where
  pid = pg_backend_pid() and
  locktype = 'relation' and
  cast(cast(relation as regclass) as text) like 'alter\_idx%'
order by cast(cast(relation as regclass) as text) collate "C";

commit;

begin;

alter index alter_idx_rename_test_idx rename to alter_idx_rename_test_idx_2;

alter index alter_idx_rename_test_parted_idx rename to alter_idx_rename_test_parted_idx_2;

select
  cast(relation as regclass),
  mode
from
  pg_locks
where
  pid = pg_backend_pid() and
  locktype = 'relation' and
  cast(cast(relation as regclass) as text) like 'alter\_idx%'
order by cast(cast(relation as regclass) as text) collate "C";

commit;

begin;

alter table alter_idx_rename_test_idx_2 rename to alter_idx_rename_test_idx_3;

alter table alter_idx_rename_test_parted_idx_2 rename to alter_idx_rename_test_parted_idx_3;

select
  cast(relation as regclass),
  mode
from
  pg_locks
where
  pid = pg_backend_pid() and
  locktype = 'relation' and
  cast(cast(relation as regclass) as text) like 'alter\_idx%'
order by cast(cast(relation as regclass) as text) collate "C";

commit;

drop table alter_idx_rename_test_2;

create view attmp_view
(
  unique1
)
as select unique1 from tenk1;

alter table attmp_view rename to attmp_view_new;

set role to regress_alter_table_user1;

alter view attmp_view_new rename to fail;

reset role;

set enable_seqscan = off;

set enable_bitmapscan = off;

select unique1 from tenk1 where unique1 < 5;

reset enable_seqscan;

reset enable_bitmapscan;

drop view attmp_view_new;

alter table stud_emp rename to pg_toast_stud_emp;

alter table pg_toast_stud_emp rename to stud_emp;

alter table onek
  add constraint "onek_unique1_constraint" unique (unique1);

alter index onek_unique1_constraint rename to onek_unique1_constraint_foo;

alter table onek
  drop constraint onek_unique1_constraint_foo;

alter table onek
  add constraint "onek_check_constraint" check (unique1 >= 0);

alter table onek rename constraint onek_check_constraint to onek_check_constraint_foo;

alter table onek
  drop constraint onek_check_constraint_foo;

alter table onek
  add constraint "onek_unique1_constraint" unique (unique1);

drop index onek_unique1_constraint;

alter table onek rename constraint onek_unique1_constraint to onek_unique1_constraint_foo;

drop index onek_unique1_constraint_foo;

alter table onek
  drop constraint onek_unique1_constraint_foo;

create table constraint_rename_test (
  a int constraint "con1" check (a > 0),
  b int,
  c int
);

create table constraint_rename_test2 (
  a int constraint "con1" check (a > 0),
  d int
)
inherits (constraint_rename_test);

alter table constraint_rename_test2 rename constraint con1 to con1foo;

alter table only constraint_rename_test rename constraint con1 to con1foo;

alter table constraint_rename_test rename constraint con1 to con1foo;

alter table constraint_rename_test
  add constraint "con2" check (b > 0) no inherit;

alter table only constraint_rename_test rename constraint con2 to con2foo;

alter table constraint_rename_test rename constraint con2foo to con2bar;

alter table constraint_rename_test
  add constraint "con3" primary key (a);

alter table constraint_rename_test rename constraint con3 to con3foo;

drop table constraint_rename_test2;

drop table constraint_rename_test;

alter table if exists constraint_not_exist rename constraint con3 to con3foo;

alter table if exists constraint_rename_test
  add constraint "con4" unique (a);

create table constraint_rename_cache (
  a int,
  constraint "chk_a" check (a > 0),
  primary key (a)
);

alter table constraint_rename_cache rename constraint chk_a to chk_a_new;

alter table constraint_rename_cache
rename constraint constraint_rename_cache_pkey
to constraint_rename_pkey_new;

create table like_constraint_rename_cache (like constraint_rename_cache including all);

drop table constraint_rename_cache;

drop table like_constraint_rename_cache;

create table attmp2 (a int primary key);

create table attmp3 (
  a int,
  b int
);

create table attmp4 (
  a int,
  b int,
  unique (a, b)
);

create table attmp5 (
  a int,
  b int
);

insert into attmp2 values (1);

insert into attmp2 values (2);

insert into attmp2 values (3);

insert into attmp2 values (4);

insert into attmp3 values (1, 10);

insert into attmp3 values (1, 20);

insert into attmp3 values (5, 50);

alter table attmp3
  add constraint "attmpconstr"
  foreign key
  (c)
  references attmp2
  match full;

alter table attmp3
  add constraint "attmpconstr"
  foreign key
  (a)
  references attmp2 (b)
  match full;

alter table attmp3
  add constraint "attmpconstr"
  foreign key
  (a)
  references attmp2
  match full;

delete from attmp3 where a = 5;

alter table attmp3
  add constraint "attmpconstr"
  foreign key
  (a)
  references attmp2
  match full;

alter table attmp3
  drop constraint attmpconstr;

insert into attmp3 values (5, 50);

alter table attmp3
  add constraint "attmpconstr"
  foreign key
  (a)
  references attmp2
  match full
  not valid;

alter table attmp3
  validate constraint attmpconstr;

delete from attmp3 where a = 5;

alter table attmp3
  validate constraint attmpconstr;

alter table attmp3
  validate constraint attmpconstr;

alter table attmp3
  add constraint "b_greater_than_ten" check (b > 10);

alter table attmp3
  add constraint "b_greater_than_ten" check (b > 10) not valid;

alter table attmp3
  validate constraint b_greater_than_ten;

delete from attmp3 where not b > 10;

alter table attmp3
  validate constraint b_greater_than_ten;

alter table attmp3
  validate constraint b_greater_than_ten;

alter table attmp3
  validate constraint b_greater_than_ten_not_enforced;

select * from attmp3;

create table attmp6 ()
inherits (attmp3);

create table attmp7 ()
inherits (attmp3);

insert into attmp6 values (6, 30), (7, 16);

alter table attmp3
  add constraint "b_le_20" check (b <= 20) not valid;

alter table attmp3
  validate constraint b_le_20;

delete from attmp6 where b > 20;

alter table attmp3
  validate constraint b_le_20;

create function boo(int)
returns int
immutable
strict
language plpgsql
as $function$ BEGIN RAISE NOTICE 'boo: %', $1; RETURN $1; END; $function$;

insert into attmp7 values (8, 18);

alter table attmp7
  add constraint "identity" check (b = boo(b));

alter table attmp3
  add constraint "identity" check (b = boo(b)) not valid;

alter table attmp3
  validate constraint identity;

create table parent_noinh_convalid (a int);

create table child_noinh_convalid ()
inherits (parent_noinh_convalid);

insert into parent_noinh_convalid values (1);

insert into child_noinh_convalid values (1);

alter table parent_noinh_convalid
  add constraint "check_a_is_2" check (a = 2) no inherit not valid;

alter table parent_noinh_convalid
  validate constraint check_a_is_2;

delete from only parent_noinh_convalid;

alter table parent_noinh_convalid
  validate constraint check_a_is_2;

select
  convalidated
from
  pg_constraint
where
  conrelid =
  cast('parent_noinh_convalid' as regclass) and
  conname = 'check_a_is_2';

drop table parent_noinh_convalid, child_noinh_convalid;

alter table attmp5
  add constraint "attmpconstr"
  foreign key
  (a)
  references attmp4 (a)
  match full;

drop table attmp7;

drop table attmp6;

drop table attmp5;

drop table attmp4;

drop table attmp3;

drop table attmp2;

set constraint_exclusion = partition;

create table nv_parent (
  d date,
  check (false) no inherit not valid
);

create table nv_child_2010 ()
inherits (nv_parent);

create table nv_child_2011 ()
inherits (nv_parent);

alter table nv_child_2010
  add check (d
  between cast('2010-01-01' as date)
  and cast('2010-12-31' as date)) not valid;

alter table nv_child_2011
  add check (d
  between cast('2011-01-01' as date)
  and cast('2011-12-31' as date)) not valid;

select * from nv_parent where d between '2011-08-01' and '2011-08-31';

create table nv_child_2009 (
  check (d
  between cast('2009-01-01' as date)
  and cast('2009-12-31' as date))
)
inherits (nv_parent);

select * from nv_parent where d between cast('2011-08-01' as date) and cast('2011-08-31' as date);

select * from nv_parent where d between cast('2009-08-01' as date) and cast('2009-08-31' as date);

alter table nv_child_2011
  validate constraint nv_child_2011_d_check;

select * from nv_parent where d between cast('2009-08-01' as date) and cast('2009-08-31' as date);

alter table nv_parent
  add check (d
  between cast('2001-01-01' as date)
  and cast('2099-12-31' as date)) not valid;

create temporary table pktable (ptest1 int primary key);

insert into pktable values (42);

create temporary table fktable (ftest1 inet);

alter table fktable
  add foreign key (ftest1) references pktable;

alter table fktable
  add foreign key (ftest1) references pktable (ptest1);

drop table fktable;

create temporary table fktable (ftest1 bigint);

alter table fktable
  add foreign key (ftest1) references pktable;

insert into fktable values (42);

insert into fktable values (43);

drop table fktable;

create temporary table fktable (ftest1 numeric);

alter table fktable
  add foreign key (ftest1) references pktable;

drop table fktable;

drop table pktable;

create temporary table pktable (ptest1 numeric primary key);

insert into pktable values (42);

create temporary table fktable (ftest1 int);

alter table fktable
  add foreign key (ftest1) references pktable;

insert into fktable values (42);

insert into fktable values (43);

drop table fktable;

drop table pktable;

create temporary table pktable (
  ptest1 int,
  ptest2 inet,
  primary key (ptest1, ptest2)
);

create temporary table fktable (
  ftest1 cidr,
  ftest2 timestamp
);

alter table fktable
  add foreign key (ftest1, ftest2) references pktable;

drop table fktable;

create temporary table fktable (
  ftest1 cidr,
  ftest2 timestamp
);

alter table fktable
  add foreign key
  (ftest1,
  ftest2)
  references pktable (ptest1,
  ptest2);

drop table fktable;

create temporary table fktable (
  ftest1 int,
  ftest2 inet
);

alter table fktable
  add foreign key
  (ftest1,
  ftest2)
  references pktable (ptest2,
  ptest1);

alter table fktable
  add foreign key
  (ftest2,
  ftest1)
  references pktable (ptest1,
  ptest2);

drop table fktable;

drop table pktable;

create temporary table pktable (ptest1 int primary key);

create temporary table fktable (ftest1 int);

alter table fktable
  add constraint "fknd"
  foreign key
  (ftest1)
  references pktable
  on DELETE cascade;

alter table fktable
  add constraint "fkdd"
  foreign key
  (ftest1)
  references pktable
  on DELETE cascade
  deferrable initially deferred;

alter table fktable
  add constraint "fkdi"
  foreign key
  (ftest1)
  references pktable
  on DELETE cascade
  deferrable initially immediate;

alter table fktable
  add constraint "fknd2"
  foreign key
  (ftest1)
  references pktable
  on DELETE cascade
  deferrable initially deferred;

alter table fktable
  alter constraint "fknd2" not deferrable initially immediate;

alter table fktable
  add constraint "fkdd2"
  foreign key
  (ftest1)
  references pktable
  on DELETE cascade;

alter table fktable
  alter constraint "fkdd2" deferrable initially deferred;

alter table fktable
  add constraint "fkdi2"
  foreign key
  (ftest1)
  references pktable
  on DELETE cascade;

alter table fktable
  alter constraint "fkdi2" deferrable initially immediate;

select
  conname,
  cast(tgfoid as regproc),
  tgtype,
  tgdeferrable,
  tginitdeferred
from
  pg_trigger
  inner join
    pg_constraint as con
  on con.oid = tgconstraint
where
  tgrelid = cast('pktable' as regclass)
order by 1,
  2,
  3;

select
  conname,
  cast(tgfoid as regproc),
  tgtype,
  tgdeferrable,
  tginitdeferred
from
  pg_trigger
  inner join
    pg_constraint as con
  on con.oid = tgconstraint
where
  tgrelid = cast('fktable' as regclass)
order by 1,
  2,
  3;

create table atacc1 (test int);

alter table atacc1
  add constraint "atacc_test1" check (test > 3);

insert into atacc1 (test) values (2);

insert into atacc1 (test) values (4);

drop table atacc1;

create table atacc1 (test int);

insert into atacc1 (test) values (2);

alter table atacc1
  add constraint "atacc_test1" check (test > 3);

insert into atacc1 (test) values (4);

drop table atacc1;

create table atacc1 (test int);

alter table atacc1
  add constraint "atacc_test1" check (test1 > 3);

drop table atacc1;

create table atacc1 (
  test int,
  test2 int,
  test3 int
);

alter table atacc1
  add constraint "atacc_test1" check (test + test2 < test3 * 4);

insert into atacc1 (test, test2, test3) values (4, 4, 2);

insert into atacc1 (test, test2, test3) values (4, 4, 5);

drop table atacc1;

create table atacc1 (
  test int check (test > 3),
  test2 int
);

alter table atacc1
  add check (test2 > test);

insert into atacc1 (test2, test) values (3, 4);

drop table atacc1;

create table atacc1 (test int);

create table atacc2 (test2 int);

create table atacc3 (test3 int)
inherits (atacc1,
atacc2);

alter table atacc2
  add constraint "foo" check (test2 > 0);

insert into atacc2 (test2) values (-3);

insert into atacc2 (test2) values (3);

insert into atacc3 (test2) values (-3);

insert into atacc3 (test2) values (3);

drop table atacc3;

drop table atacc2;

drop table atacc1;

create table atacc1 (test int);

create table atacc2 (test2 int);

create table atacc3 (test3 int)
inherits (atacc1,
atacc2);

alter table atacc3
  no inherit atacc2;

alter table atacc3
  no inherit atacc2;

insert into atacc3 (test2) values (3);

select test2 from atacc2;

alter table atacc2
  add constraint "foo" check (test2 > 0);

alter table atacc3
  inherit atacc2;

alter table atacc3 rename column test2 to testx;

alter table atacc3
  inherit atacc2;

alter table atacc3
  add column test2 boolean;

alter table atacc3
  inherit atacc2;

alter table atacc3
  drop column test2;

alter table atacc3
  add column test2 int;

update atacc3 set test2 = 4 where test2 is null;

alter table atacc3
  add constraint "foo" check (test2 > 0);

alter table atacc3
  inherit atacc2;

alter table atacc3
  inherit atacc2;

alter table atacc2
  inherit atacc3;

alter table atacc2
  inherit atacc2;

select test2 from atacc2;

drop table atacc2 cascade;

drop table atacc1;

create table atacc1 (test int);

create table atacc2 (test2 int)
inherits (atacc1);

alter table atacc1
  add constraint "foo" check (test > 0) no inherit;

insert into atacc2 (test) values (-3);

insert into atacc1 (test) values (-3);

insert into atacc1 (test) values (3);

alter table atacc2
  add constraint "foo" check (test > 0) no inherit;

drop table atacc2;

drop table atacc1;

create table atacc1 (test int);

alter table atacc1
  add constraint "atacc_test1" unique (test);

insert into atacc1 (test) values (2);

insert into atacc1 (test) values (2);

insert into atacc1 (test) values (4);

alter table atacc1
  alter column test type int using 0;

drop table atacc1;

create table atacc1 (test int);

insert into atacc1 (test) values (2);

insert into atacc1 (test) values (2);

alter table atacc1
  add constraint "atacc_test1" unique (test);

insert into atacc1 (test) values (3);

drop table atacc1;

create table atacc1 (test int);

alter table atacc1
  add constraint "atacc_test1" unique (test1);

drop table atacc1;

create table atacc1 (
  test int,
  test2 int
);

alter table atacc1
  add constraint "atacc_test1" unique (test, test2);

insert into atacc1 (test, test2) values (4, 4);

insert into atacc1 (test, test2) values (4, 4);

insert into atacc1 (test, test2) values (4, 5);

insert into atacc1 (test, test2) values (5, 4);

insert into atacc1 (test, test2) values (5, 5);

drop table atacc1;

create table atacc1 (
  test int,
  test2 int,
  unique (test)
);

alter table atacc1
  add unique (test2);

insert into atacc1 (test2, test) values (3, 3);

insert into atacc1 (test2, test) values (2, 3);

drop table atacc1;

create table atacc1 (
  id serial,
  test int
);

alter table atacc1
  add constraint "atacc_test1" primary key (test);

insert into atacc1 (test) values (2);

insert into atacc1 (test) values (2);

insert into atacc1 (test) values (4);

insert into atacc1 (test) values (null);

alter table atacc1
  add constraint "atacc_oid1" primary key (id);

alter table atacc1
  drop constraint atacc_test1;

alter table atacc1
  add constraint "atacc_oid1" primary key (id);

drop table atacc1;

create table atacc1 (test int);

insert into atacc1 (test) values (2);

insert into atacc1 (test) values (2);

alter table atacc1
  add constraint "atacc_test1" primary key (test);

insert into atacc1 (test) values (3);

drop table atacc1;

create table atacc1 (test int);

insert into atacc1 (test) values (null);

alter table atacc1
  add constraint "atacc_test1" primary key (test);

insert into atacc1 (test) values (3);

drop table atacc1;

create table atacc1 (test int);

alter table atacc1
  add constraint "atacc_test1" primary key (test1);

drop table atacc1;

create table atacc1 (test int);

insert into atacc1 (test) values (0);

alter table atacc1
  add column test2 int primary key;

alter table atacc1
  add column test2 int default 0 primary key;

drop table atacc1;

create table atacc1 (a int);

insert into atacc1 values (1);

alter table atacc1
  add column b double precision not null default random(),
  add primary key (a);

drop table atacc1;

create table atacc1 (a int primary key);

alter table atacc1
  add constraint "atacc1_fkey"
  foreign key
  (a)
  references atacc1 (a)
  not valid;

alter table atacc1
  validate constraint atacc1_fkey,
  alter column a type bigint;

drop table atacc1;

create table atacc1 (
  a bigint,
  b int
);

insert into atacc1 values (1, 1);

alter table atacc1
  add constraint "atacc1_chk" check (b = 1) not valid;

alter table atacc1
  validate constraint atacc1_chk,
  alter column a type int;

drop table atacc1;

create table atacc1 (
  a bigint,
  b int
);

insert into atacc1 values (1, 2);

alter table atacc1
  add constraint "atacc1_chk" check (b = 1) not valid;

alter table atacc1
  validate constraint atacc1_chk,
  alter column a type int;

drop table atacc1;

create table atacc1 (
  test int,
  test2 int
);

alter table atacc1
  add constraint "atacc_test1" primary key (test, test2);

alter table atacc1
  add constraint "atacc_test2" primary key (test);

insert into atacc1 (test, test2) values (4, 4);

insert into atacc1 (test, test2) values (4, 4);

insert into atacc1 (test, test2) values (null, 3);

insert into atacc1 (test, test2) values (3, null);

insert into atacc1 (test, test2) values (null, null);

insert into atacc1 (test, test2) values (4, 5);

insert into atacc1 (test, test2) values (5, 4);

insert into atacc1 (test, test2) values (5, 5);

drop table atacc1;

create table atacc1 (
  test int,
  test2 int,
  primary key (test)
);

insert into atacc1 (test2, test) values (3, 3);

insert into atacc1 (test2, test) values (2, 3);

insert into atacc1 (test2, test) values (1, null);

drop table atacc1;

alter table pg_class
  alter column relname drop not null;

alter table pg_class
  alter column relname set not null;

alter table non_existent
  alter column bar set not null;

alter table non_existent
  alter column bar drop not null;

create table atacc1 (test int not null);

alter table atacc1
  add constraint "atacc1_pkey" primary key (test);

alter table atacc1
  alter column test drop not null;

alter table atacc1
  drop constraint atacc1_pkey;

alter table atacc1
  alter column test drop not null;

insert into atacc1 values (null);

alter table atacc1
  alter column test set not null;

delete from atacc1;

alter table atacc1
  alter column test set not null;

alter table atacc1
  alter column bar set not null;

alter table atacc1
  alter column bar drop not null;

create view myview
as select * from atacc1;

alter table myview
  alter column test drop not null;

alter table myview
  alter column test set not null;

drop view myview;

drop table atacc1;

create table atacc1 (
  test_a int,
  test_b int
);

insert into atacc1 values (null, 1);

alter table atacc1
  add constraint "atacc1_constr_or" check (test_a is not null or test_b < 10);

alter table atacc1
  alter column test_a set not null;

alter table atacc1
  drop constraint atacc1_constr_or;

alter table atacc1
  add constraint "atacc1_constr_invalid" check (test_a is not null) not valid;

alter table atacc1
  alter column test_a set not null;

alter table atacc1
  drop constraint atacc1_constr_invalid;

update atacc1 set test_a = 1;

alter table atacc1
  add constraint "atacc1_constr_a_valid" check (test_a is not null);

alter table atacc1
  alter column test_a set not null;

delete from atacc1;

insert into atacc1 values (2, null);

alter table atacc1
  alter column test_a drop not null;

alter table atacc1
  alter column test_a set not null,
  alter column test_b set not null;

alter table atacc1
  alter column test_b set not null,
  alter column test_a set not null;

update atacc1 set test_b = 1;

alter table atacc1
  alter column test_b set not null,
  alter column test_a set not null;

alter table atacc1
  alter column test_a drop not null,
  alter column test_b drop not null;

alter table atacc1
  add constraint "atacc1_constr_b_valid" check (test_b is not null);

alter table atacc1
  alter column test_b set not null,
  alter column test_a set not null;

drop table atacc1;

create table atnnparted (
  id int,
  col1 int
)
partition by LIST(id);

create table atnnpart1 (
  col1 int,
  id int
);

alter table atnnpart1
  add primary key (id);

alter table atnnparted
  attach partition
  atnnpart1 for values in ('1');

begin;

alter table atnnparted
  validate constraint dummy_constr;

rollback;

create table parent (a int);

create table child (b varchar(255))
inherits (parent);

alter table parent
  alter column a set not null;

insert into parent values (null);

insert into child (a, b) values (null, 'foo');

alter table parent
  alter column a drop not null;

insert into parent values (null);

insert into child (a, b) values (null, 'foo');

alter table only parent
  alter column a set not null;

alter table child
  alter column a set not null;

drop table child;

drop table parent;

create table def_test (
  c1 int default 5,
  c2 text default 'initial_default'
);

insert into def_test default values;

alter table def_test
  alter column c1 drop default;

insert into def_test default values;

alter table def_test
  alter column c2 drop default;

insert into def_test default values;

alter table def_test
  alter column c1 set default 10;

alter table def_test
  alter column c2 set default 'new_default';

insert into def_test default values;

select * from def_test;

alter table def_test
  alter column c1 set default 'wrong_datatype';

alter table def_test
  alter column c2 set default 20;

alter table def_test
  alter column c3 set default 30;

create view def_view_test
as select * from def_test;

select new.*;

insert into def_view_test default values;

alter table def_view_test
  alter column c1 set default 45;

insert into def_view_test default values;

alter table def_view_test
  alter column c2 set default 'view_default';

insert into def_view_test default values;

select * from def_view_test;

drop rule def_view_test_ins on def_view_test;

drop view def_view_test;

drop table def_test;

alter table pg_class
  drop column relname;

alter table nosuchtable
  drop column bar;

create table atacc1 (
  a int not null,
  b int,
  c int not null,
  d int
);

insert into atacc1 values (1, 2, 3, 4);

alter table atacc1
  drop column a;

alter table atacc1
  drop column a;

select * from atacc1;

select * from atacc1 order by a;

select * from atacc1 order by "........pg.dropped.1........";

select * from atacc1 group by a;

select * from atacc1 group by "........pg.dropped.1........";

select atacc1.* from atacc1;

select a from atacc1;

select atacc1.a from atacc1;

select b, c, d from atacc1;

select a, b, c, d from atacc1;

select * from atacc1 where a = 1;

select "........pg.dropped.1........" from atacc1;

select atacc1."........pg.dropped.1........" from atacc1;

select "........pg.dropped.1........", b, c, d from atacc1;

select * from atacc1 where "........pg.dropped.1........" = 1;

update atacc1 set a = 3;

update atacc1 set b = 2 where a = 3;

update atacc1 set "........pg.dropped.1........" = 3;

update atacc1 set b = 2 where "........pg.dropped.1........" = 3;

insert into atacc1 values (10, 11, 12, 13);

insert into atacc1 values (default, 11, 12, 13);

insert into atacc1 values (11, 12, 13);

insert into atacc1 (a) values (10);

insert into atacc1 (a) values (default);

insert into atacc1 (a, b, c, d) values (10, 11, 12, 13);

insert into atacc1 (a, b, c, d) values (default, 11, 12, 13);

insert into atacc1 (b, c, d) values (11, 12, 13);

insert into atacc1 ("........pg.dropped.1........") values (10);

insert into atacc1 ("........pg.dropped.1........") values (default);

insert into atacc1 ("........pg.dropped.1........", b, c, d) values (10, 11, 12, 13);

insert into atacc1 ("........pg.dropped.1........", b, c, d) values (default, 11, 12, 13);

delete from atacc1 where a = 3;

delete from atacc1 where "........pg.dropped.1........" = 3;

delete from atacc1;

alter table atacc1
  drop column bar;

alter table atacc1
  set without oids;
