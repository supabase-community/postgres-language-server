---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/insert_conflict.sql
snapshot_kind: text
---
create table insertconflicttest (
  key INT,
  fruit TEXT
);

create view insertconflictview
as select * from insertconflicttest;

create unique index "op_index_key" on insertconflicttest using btree (key, fruit text_pattern_ops);

create unique index "collation_index_key"
on insertconflicttest
using btree
(
  key,
  fruit collate "C"
);

create unique index "both_index_key"
on insertconflicttest
using btree
(
  key,
  fruit collate "C" text_pattern_ops
);

create unique index "both_index_expr_key"
on insertconflicttest
using btree
(
  key,
  (lower(fruit)) collate "C" text_pattern_ops
);

insert into insertconflicttest values (0, 'Crowberry') on conflict (key) do nothing;

insert into insertconflicttest values (0, 'Crowberry') on conflict (fruit) do nothing;

insert into insertconflicttest values (0, 'Crowberry') on conflict (key, fruit) do nothing;

insert into insertconflicttest
values (0, 'Crowberry')
on conflict (fruit, key, fruit, key) do nothing;

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
((lower(fruit)), key, (lower(fruit)), key)
do nothing;

insert into insertconflictview
values (0, 'Crowberry')
on conflict
((lower(fruit)), key, (lower(fruit)), key)
do nothing;

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
(key, fruit)
do
update
set fruit = excluded.fruit
where
  exists
  (
    select
      1
    from
      insertconflicttest as ii
    where
      ii.key = excluded.key
  );

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
(key, fruit text_pattern_ops)
do nothing;

insert into insertconflicttest
values (0, 'Crowberry')
on conflict (key, fruit collate "C") do nothing;

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
(fruit collate "C" text_pattern_ops, key)
do nothing;

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
((lower(fruit)) collate "C", key, key)
do nothing;

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
(fruit, key, fruit text_pattern_ops, key)
do nothing;

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
((lower(fruit)) collate "C" text_pattern_ops,
key,
key)
do nothing;

drop INDEX "op_index_key";

drop INDEX "collation_index_key";

drop INDEX "both_index_key";

drop INDEX "both_index_expr_key";

create unique index "cross_match"
on insertconflicttest
using btree
(
  (lower(fruit)) collate "C",
  (upper(fruit)) text_pattern_ops
);

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
((lower(fruit)) text_pattern_ops,
(upper(fruit)) collate "C")
do nothing;

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
((lower(fruit)) collate "C",
(upper(fruit)) text_pattern_ops)
do nothing;

drop INDEX "cross_match";

create unique index "key_index" on insertconflicttest using btree (key);

insert into insertconflicttest
values (0, 'Bilberry')
on conflict
(key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (0, 'Bilberry')
on conflict
(key)
do
update
set fruit = excluded.fruit
where
  insertconflicttest.fruit <> 'Cawesh';

insert into insertconflicttest
values (0, 'Crowberry')
on conflict
(key)
do
update
set fruit = excluded.fruit
where
  excluded.fruit <> 'Elderberry';

insert into insertconflicttest
values (0, 'Bilberry')
on conflict
(key)
do
update
set fruit = excluded.fruit
where
  insertconflicttest.fruit <> 'Lime'
returning *;

insert into insertconflicttest values (1, 'Apple') on conflict do update set fruit = excluded.fruit;

insert into insertconflicttest
values (1, 'Apple')
on conflict
(key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (2, 'Orange')
on conflict
(key, key, key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (1, 'Apple'), (2, 'Orange')
on conflict
(key)
do
update
set (fruit, key) = (excluded.fruit, excluded.key);

insert into insertconflicttest
values (1, 'Apple')
on conflict
(key)
do
update
set fruit = excluded.fruit
returning excluded.fruit;

insert into insertconflicttest
values (1, 'Apple')
on conflict
(keyy)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (1, 'Apple')
on conflict
(key)
do
update
set fruit = excluded.fruitt;

insert into insertconflicttest
values (3, 'Kiwi')
on conflict
(key, fruit)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (4, 'Mango')
on conflict
(fruit, key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (5, 'Lemon')
on conflict
(fruit)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (6, 'Passionfruit')
on conflict
((lower(fruit)))
do
update
set fruit = excluded.fruit;

insert into insertconflicttest as ict
values (6, 'Passionfruit')
on conflict
(key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest as ict
values (6, 'Passionfruit')
on conflict (key) do update set fruit = ict.fruit;

insert into insertconflicttest as ict
values (6, 'Passionfruit')
on conflict
(key)
do
update
set fruit = insertconflicttest.fruit;

insert into insertconflicttest
values (3, 'Kiwi')
on conflict
(key, fruit)
do
update
set insertconflicttest."fruit" = 'Mango';

drop INDEX "key_index";

create unique index "comp_key_index" on insertconflicttest using btree (key, fruit);

insert into insertconflicttest
values (7, 'Raspberry')
on conflict
(key, fruit)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (8, 'Lime')
on conflict
(fruit, key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (9, 'Banana')
on conflict
(key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (10, 'Blueberry')
on conflict
(key, key, key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (11, 'Cherry')
on conflict
(key, (lower(fruit)))
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (12, 'Date')
on conflict
((lower(fruit)), key)
do
update
set fruit = excluded.fruit;

drop INDEX "comp_key_index";

create unique index "part_comp_key_index"
on insertconflicttest
using btree
(
  key,
  fruit
)
where
  key < 5;

create unique index "expr_part_comp_key_index"
on insertconflicttest
using btree
(
  key,
  (lower(fruit))
)
where
  key < 5;

insert into insertconflicttest
values (13, 'Grape')
on conflict
(key, fruit)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (14, 'Raisin')
on conflict
(fruit, key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (15, 'Cranberry')
on conflict
(key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (16, 'Melon')
on conflict
(key, key, key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (17, 'Mulberry')
on conflict
(key, (lower(fruit)))
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (18, 'Pineapple')
on conflict
((lower(fruit)), key)
do
update
set fruit = excluded.fruit;

drop INDEX "part_comp_key_index";

drop INDEX "expr_part_comp_key_index";

create unique index "expr_key_index" on insertconflicttest using btree ((lower(fruit)));

insert into insertconflicttest
values (20, 'Quince')
on conflict
((lower(fruit)))
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (21, 'Pomegranate')
on conflict
((lower(fruit)), (lower(fruit)))
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (22, 'Apricot')
on conflict
((upper(fruit)))
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (23, 'Blackberry')
on conflict
(fruit)
do
update
set fruit = excluded.fruit;

drop INDEX "expr_key_index";

create unique index "expr_comp_key_index" on insertconflicttest using btree (key, (lower(fruit)));

create unique index "tricky_expr_comp_key_index"
on insertconflicttest
using btree
(
  key,
  (lower(fruit)),
  (upper(fruit))
);

insert into insertconflicttest
values (24, 'Plum')
on conflict
(key, (lower(fruit)))
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (25, 'Peach')
on conflict
((lower(fruit)), key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (26, 'Fig')
on conflict
((lower(fruit)), key, (lower(fruit)), key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (27, 'Prune')
on conflict
(key, (upper(fruit)))
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (28, 'Redcurrant')
on conflict
(fruit, key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (29, 'Nectarine')
on conflict
(key)
do
update
set fruit = excluded.fruit;

drop INDEX "expr_comp_key_index";

drop INDEX "tricky_expr_comp_key_index";

create unique index "key_index" on insertconflicttest using btree (key);

create unique index "fruit_index" on insertconflicttest using btree (fruit);

insert into insertconflicttest
values (26, 'Fig')
on conflict
(key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (26, 'Peach')
on conflict
(key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (25, 'Fig')
on conflict
(fruit)
do
update
set fruit = excluded.fruit;

drop INDEX "key_index";

drop INDEX "fruit_index";

create unique index "partial_key_index"
on insertconflicttest
using btree
(
  key
)
where
  fruit like '%berry';

insert into insertconflicttest
values (23, 'Blackberry')
on conflict
(key) where fruit like '%berry'
do
update
set fruit = excluded.fruit;

insert into insertconflicttest as t
values (23, 'Blackberry')
on conflict
(key)
where
  fruit like '%berry' and
  t.fruit = 'inconsequential'
do nothing;

insert into insertconflictview as t
values (23, 'Blackberry')
on conflict
(key)
where
  fruit like '%berry' and
  t.fruit = 'inconsequential'
do nothing;

insert into insertconflicttest
values (23, 'Blackberry')
on conflict
(key)
do
update
set fruit = excluded.fruit;

insert into insertconflicttest
values (23, 'Blackberry')
on conflict
(key)
where
  fruit like '%berry' or fruit = 'consequential'
do nothing;

insert into insertconflicttest
values (23, 'Blackberry')
on conflict
(fruit) where fruit like '%berry'
do
update
set fruit = excluded.fruit;

drop INDEX "partial_key_index";

create unique index "plain" on insertconflicttest using btree (key);

insert into insertconflicttest as i
values (23, 'Jackfruit')
on conflict
(key)
do
update
set fruit = excluded.fruit
where
  i.* <> excluded.*
returning *;

insert into insertconflicttest as i
values (23, 'Jackfruit')
on conflict
(key)
do
update
set fruit = excluded.fruit
where
  i.* <> excluded.*
returning *;

insert into insertconflicttest as i
values (23, 'Jackfruit')
on conflict
(key)
do
update
set fruit = excluded.fruit
where
  i.* = excluded.*
returning *;

insert into insertconflicttest as i
values (23, 'Avocado')
on conflict
(key)
do
update
set fruit = cast(excluded.* as TEXT)
returning *;

insert into insertconflicttest as i
values (23, 'Avocado')
on conflict
(key)
do
update
set fruit = excluded.fruit
where
  excluded.* is null;

insert into insertconflicttest as i
values (23, 'Avocado')
on conflict
(key)
do
update
set fruit = cast(excluded.* as TEXT);

drop INDEX "plain";

drop VIEW "insertconflictview";

drop TABLE "insertconflicttest";

create table syscolconflicttest (
  key INT,
  data TEXT
);

insert into syscolconflicttest values (1);

insert into syscolconflicttest
values (1)
on conflict
(key)
do
update
set data = cast(excluded.ctid as TEXT);

drop TABLE "syscolconflicttest";

create table insertconflict (
  a BIGINT,
  b BIGINT
);

create unique index "insertconflicti1" on insertconflict using btree ((coalesce(a, 0)));

create unique index "insertconflicti2"
on insertconflict
using btree
(
  b
)
where
  coalesce(a, 1) > 0;

insert into insertconflict values (1, 2) on conflict ((coalesce(a, 0))) do nothing;

insert into insertconflict values (1, 2) on conflict (b) where coalesce(a, 1) > 0 do nothing;

insert into insertconflict values (1, 2) on conflict (b) where coalesce(a, 1) > 1 do nothing;

drop TABLE "insertconflict";

create table insertconflict (
  f1 INT primary key,
  f2 TEXT
);

create view insertconflictv
as select * from insertconflict
with cascaded check option;

insert into insertconflictv values (1, 'foo') on conflict (f1) do update set f2 = excluded.f2;

select * from insertconflict;

insert into insertconflictv values (1, 'bar') on conflict (f1) do update set f2 = excluded.f2;

select * from insertconflict;

drop VIEW "insertconflictv";

drop TABLE "insertconflict";

create table cities (
  name TEXT,
  population DOUBLE PRECISION,
  altitude INT
);

create table capitals (state CHAR(2))
inherits (cities);

create unique index "cities_names_unique" on cities using btree (name);

create unique index "capitals_names_unique" on capitals using btree (name);

insert into cities values ('San Francisco', 7.24E+5, 63);

insert into cities values ('Las Vegas', 2.583E+5, 2174);

insert into cities values ('Mariposa', 1200, 1953);

insert into capitals values ('Sacramento', 3.694E+5, 30, 'CA');

insert into capitals values ('Madison', 1.913E+5, 845, 'WI');

select * from capitals;

insert into cities values ('Las Vegas', 2.583E+5, 2174) on conflict do nothing;

insert into capitals
values ('Sacramento', 4664.E+5, 30, 'CA')
on conflict
(name)
do
update
set population = excluded.population;

insert into capitals values ('Sacramento', 50, 2267, 'NE') on conflict (name) do nothing;

select * from capitals;

insert into cities
values ('Las Vegas', 5.83E+5, 2001)
on conflict
(name)
do
update
set population = excluded.population,
altitude = excluded.altitude;

select cast(tableoid as REGCLASS), * from cities;

insert into capitals
values ('Las Vegas', 5.83E+5, 2222, 'NV')
on conflict
(name)
do
update
set population = excluded.population;

select * from capitals;

select cast(tableoid as REGCLASS), * from cities;

insert into cities
values ('Las Vegas', 5.86E+5, 2223)
on conflict
(name)
do
update
set population = excluded.population,
altitude = excluded.altitude;

select cast(tableoid as REGCLASS), * from cities;

drop TABLE "capitals";

drop TABLE "cities";

create table excluded (
  key INT primary key,
  data TEXT
);

insert into excluded values (1, '1');

insert into excluded
values (1, '2')
on conflict
(key)
do
update
set data = excluded.data
returning *;

insert into excluded as target
values (1, '2')
on conflict
(key)
do
update
set data = excluded.data
returning *;

insert into excluded as target
values (1, '2')
on conflict (key) do update set data = target.data
returning *;

insert into excluded values (1, '2') on conflict (key) do update set data = 3 returning excluded.*;

drop TABLE "excluded";

create table dropcol (
  key INT primary key,
  drop1 INT,
  keep1 TEXT,
  drop2 NUMERIC,
  keep2 DOUBLE PRECISION
);

insert into dropcol (key, drop1, keep1, drop2, keep2) values (1, 1, '1', '1', 1);

insert into dropcol (key, drop1, keep1, drop2, keep2)
values (1, 2, '2', '2', 2)
on conflict
(key)
do
update
set drop1 = excluded.drop1,
keep1 = excluded.keep1,
drop2 = excluded.drop2,
keep2 = excluded.keep2
where
  excluded.drop1 is not null and
  excluded.keep1 is not null and
  excluded.drop2 is not null and
  excluded.keep2 is not null and
  dropcol.drop1 is not null and
  dropcol.keep1 is not null and
  dropcol.drop2 is not null and
  dropcol.keep2 is not null
returning *;

insert into dropcol (key, drop1, keep1, drop2, keep2)
values (1, 3, '3', '3', 3)
on conflict
(key)
do
update
set drop1 = dropcol.drop1,
keep1 = dropcol.keep1,
drop2 = dropcol.drop2,
keep2 = dropcol.keep2
returning *;

alter table dropcol
  drop column drop1,
  drop column drop2;

insert into dropcol (key, keep1, keep2)
values (1, '4', 4)
on conflict
(key)
do
update
set keep1 = excluded.keep1,
keep2 = excluded.keep2
where
  excluded.keep1 is not null and
  excluded.keep2 is not null and
  dropcol.keep1 is not null and
  dropcol.keep2 is not null
returning *;

insert into dropcol (key, keep1, keep2)
values (1, '5', 5)
on conflict
(key)
do
update
set keep1 = dropcol.keep1,
keep2 = dropcol.keep2
returning *;

drop TABLE "dropcol";

create table twoconstraints (
  f1 INT unique,
  f2 box,
  exclude using gist (f2 with &&)
);

insert into twoconstraints values (1, '((0,0),(1,1))');

insert into twoconstraints values (1, '((2,2),(3,3))');

insert into twoconstraints values (2, '((0,0),(1,2))');

insert into twoconstraints
values (2, '((0,0),(1,2))')
on conflict
on constraint twoconstraints_f1_key
do nothing;

insert into twoconstraints
values (2, '((0,0),(1,2))')
on conflict
on constraint twoconstraints_f2_excl
do nothing;

select * from twoconstraints;

drop TABLE "twoconstraints";

create table selfconflict (
  f1 INT primary key,
  f2 INT
);

begin isolation level read committed;

insert into selfconflict values (1, 1), (1, 2) on conflict do nothing;

commit;

begin isolation level repeatable read;

insert into selfconflict values (2, 1), (2, 2) on conflict do nothing;

commit;

begin isolation level serializable;

insert into selfconflict values (3, 1), (3, 2) on conflict do nothing;

commit;

begin isolation level read committed;

insert into selfconflict values (4, 1), (4, 2) on conflict (f1) do update set f2 = 0;

commit;

begin isolation level repeatable read;

insert into selfconflict values (5, 1), (5, 2) on conflict (f1) do update set f2 = 0;

commit;

begin isolation level serializable;

insert into selfconflict values (6, 1), (6, 2) on conflict (f1) do update set f2 = 0;

commit;

select * from selfconflict;

drop TABLE "selfconflict";

create table parted_conflict_test (
  a INT unique,
  b CHAR(1)
)
partition by LIST(a);

create table parted_conflict_test_1
partition of parted_conflict_test
(
  b unique
)
for values in (1, 2);

insert into parted_conflict_test values (1, 'a') on conflict do nothing;

insert into parted_conflict_test values (1, 'a') on conflict (a) do nothing;

insert into parted_conflict_test values (1, 'a') on conflict (a) do update set b = excluded.b;

insert into parted_conflict_test_1 values (1, 'a') on conflict (a) do nothing;

insert into parted_conflict_test_1 values (1, 'b') on conflict (a) do update set b = excluded.b;

insert into parted_conflict_test values (2, 'b') on conflict (b) do update set a = excluded.a;

insert into parted_conflict_test_1 values (2, 'b') on conflict (b) do update set a = excluded.a;

select * from parted_conflict_test order by a;

create table parted_conflict_test_2 (
  b CHAR(1),
  a INT unique
);

alter table parted_conflict_test
  ATTACH partition
  parted_conflict_test_2 for values in (3);

truncate parted_conflict_test;

insert into parted_conflict_test values (3, 'a') on conflict (a) do update set b = excluded.b;

insert into parted_conflict_test values (3, 'b') on conflict (a) do update set b = excluded.b;

select * from parted_conflict_test order by a;

alter table parted_conflict_test
  drop column b,
  add column b CHAR(1);

create table parted_conflict_test_3 partition of parted_conflict_test for values in (4);

truncate parted_conflict_test;

insert into parted_conflict_test (a, b)
values (4, 'a')
on conflict (a) do update set b = excluded.b;

insert into parted_conflict_test (a, b)
values (4, 'b')
on conflict
(a)
do
update
set b = excluded.b
where
  parted_conflict_test.b = 'a';

select * from parted_conflict_test order by a;

create table parted_conflict_test_4
partition of parted_conflict_test
for values in (5)
partition by LIST(a);

create table parted_conflict_test_4_1 partition of parted_conflict_test_4 for values in (5);

truncate parted_conflict_test;

insert into parted_conflict_test (a, b)
values (5, 'a')
on conflict (a) do update set b = excluded.b;

insert into parted_conflict_test (a, b)
values (5, 'b')
on conflict
(a)
do
update
set b = excluded.b
where
  parted_conflict_test.b = 'a';

select * from parted_conflict_test order by a;

truncate parted_conflict_test;

insert into parted_conflict_test (a, b)
values (1, 'a'), (2, 'a'), (4, 'a')
on conflict
(a)
do
update
set b = excluded.b
where
  excluded.b = 'b';

insert into parted_conflict_test (a, b)
values (1, 'b'), (2, 'c'), (4, 'b')
on conflict
(a)
do
update
set b = excluded.b
where
  excluded.b = 'b';

select * from parted_conflict_test order by a;

drop TABLE "parted_conflict_test";

create table parted_conflict (
  a INT primary key,
  b TEXT
)
partition by range(a);

create table parted_conflict_1
partition of parted_conflict
for values from (0) to (1000)
partition by range(a);

create table parted_conflict_1_1 partition of parted_conflict_1 for values from (0) to (500);

insert into parted_conflict values (40, 'forty');

insert into parted_conflict_1 values (40, 'cuarenta') on conflict (a) do update set b = excluded.b;

drop TABLE "parted_conflict";

create table parted_conflict (
  a INT,
  b TEXT
)
partition by range(a);

create table parted_conflict_1
partition of parted_conflict
for values from (0) to (1000)
partition by range(a);

create table parted_conflict_1_1 partition of parted_conflict_1 for values from (0) to (500);

create unique index on only parted_conflict_1 using btree (a);

create unique index on only parted_conflict using btree (a);

alter index parted_conflict_a_idx
  ATTACH partition
  parted_conflict_1_a_idx;

insert into parted_conflict values (40, 'forty');

insert into parted_conflict_1 values (40, 'cuarenta') on conflict (a) do update set b = excluded.b;

drop TABLE "parted_conflict";

create table parted_conflict (
  a INT,
  b TEXT,
  c INT
)
partition by range(a);

create table parted_conflict_1 (
  drp TEXT,
  c INT,
  a INT,
  b TEXT
);

alter table parted_conflict_1
  drop column drp;

create unique index on parted_conflict using btree (a, b);

alter table parted_conflict
  ATTACH partition
  parted_conflict_1 for values from (0) to (1000);

truncate parted_conflict;

insert into parted_conflict values (50, 'cincuenta', 1);

insert into parted_conflict
values (50, 'cincuenta', 2)
on conflict
(a, b)
do
update
set (a, b, c) = row(excluded.*)
where
  parted_conflict =
  (50, cast('cincuenta' as TEXT), 1) and
  excluded = (50, cast('cincuenta' as TEXT), 2);

select * from parted_conflict order by a;

create or replace function parted_conflict_update_func()
returns trigger
as '
declare
    r record;
begin
 for r in select * from inserted loop
	raise notice ''a = %, b = %, c = %'', r.a, r.b, r.c;
 end loop;
 return new;
end;
'
language "plpgsql";

create TRIGGER parted_conflict_update
  after update
  on parted_conflict
  REFERENCING new table as inserted
  for EACH STATEMENT
  EXECUTE FUNCTION parted_conflict_update_func();

truncate parted_conflict;

insert into parted_conflict values (0, 'cero', 1);

insert into parted_conflict
values (0, 'cero', 1)
on conflict
(a, b)
do
update
set c = parted_conflict.c + 1;

drop TABLE "parted_conflict";

drop FUNCTION parted_conflict_update_func();
