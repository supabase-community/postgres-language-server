---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/type_sanity.sql
snapshot_kind: text
---
select
  t1.oid,
  t1.typname
from
  pg_type as t1
where
  t1.typnamespace = 0 or
  t1.typlen <= 0 and
  t1.typlen <> -1 and
  t1.typlen <> -2 or
  t1.typtype
  not in (
    'b', 'c', 'd', 'e', 'm', 'p', 'r'
  ) or
  not t1.typisdefined or
  t1.typalign not in ('c', 's', 'i', 'd') or
  t1.typstorage not in ('p', 'x', 'e', 'm');

select
  t1.oid,
  t1.typname
from
  pg_type as t1
where
  t1.typbyval and
  (t1.typlen <> 1 or t1.typalign <> 'c') and
  (t1.typlen <> 2 or t1.typalign <> 's') and
  (t1.typlen <> 4 or t1.typalign <> 'i') and
  (t1.typlen <> 8 or t1.typalign <> 'd');

select
  t1.oid,
  t1.typname
from
  pg_type as t1
where
  t1.typstorage <> 'p' and
  (t1.typbyval or t1.typlen <> -1);

select
  t1.oid,
  t1.typname
from
  pg_type as t1
where
  t1.typtype = 'c' and t1.typrelid = 0 or
  t1.typtype <> 'c' and t1.typrelid <> 0;

select
  t1.oid,
  t1.typname
from
  pg_type as t1
where
  t1.typtype not in ('p') and
  t1.typname not like '\_%' and
  not exists
  (
    select
      1
    from
      pg_type as t2
    where
      t2.typname = cast('_' || t1.typname as NAME) and
      t2.typelem = t1.oid and
      t1.typarray = t2.oid
  )
order by t1.oid;

select
  t1.oid,
  t1.typname as basetype,
  t2.typname as arraytype,
  t2.typsubscript
from
  pg_type as t1
  left outer join
    pg_type as t2
  on t1.typarray = t2.oid
where
  t1.typarray <> 0 and
  (t2.oid is null or
  t2.typsubscript <>
  cast('array_subscript_handler' as REGPROC));

select
  t1.oid,
  t1.typname
from
  pg_type as t1
where
  t1.typtype = 'r' and
  not exists
  (
    select
      1
    from
      pg_range as r
    where
      rngtypid = t1.oid
  );

select
  t1.oid,
  t1.typname,
  t1.typalign,
  t2.typname,
  t2.typalign
from
  pg_type as t1
  left outer join
    pg_range as r
  on rngtypid = t1.oid
  left outer join
    pg_type as t2
  on rngsubtype = t2.oid
where
  t1.typtype = 'r' and
  (t1.typalign <>
  case
    when t2.typalign = 'd' then cast('d' as CHAR)
    else cast('i' as CHAR)
  end or
  t2.oid is null);

select t1.oid, t1.typname from pg_type as t1 where t1.typinput = 0 or t1.typoutput = 0;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typinput = p1.oid and
  not (p1.pronargs = 1 and
  p1.proargtypes[0] = cast('cstring' as REGTYPE) or
  p1.pronargs = 2 and
  p1.proargtypes[0] = cast('cstring' as REGTYPE) and
  p1.proargtypes[1] = cast('oid' as REGTYPE) or
  p1.pronargs = 3 and
  p1.proargtypes[0] = cast('cstring' as REGTYPE) and
  p1.proargtypes[1] = cast('oid' as REGTYPE) and
  p1.proargtypes[2] = cast('int4' as REGTYPE));

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typinput = p1.oid and
  t1.typtype in ('b', 'p') and
  not (t1.typelem <> 0 and t1.typlen < 0) and
  not (p1.prorettype = t1.oid and not p1.proretset)
order by 1;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typinput = p1.oid and
  t1.typelem <> 0 and t1.typlen < 0 and
  not p1.oid = cast('array_in' as REGPROC)
order by 1;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typinput = p1.oid and
  p1.provolatile not in ('i', 's');

select distinct typtype, typinput from pg_type as t1 where t1.typtype not in ('b', 'p') order by 1;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typoutput = p1.oid and
  t1.typtype in ('b', 'p') and
  not (p1.pronargs = 1 and
  (p1.proargtypes[0] = t1.oid or
  p1.oid = cast('array_out' as REGPROC) and
  t1.typelem <> 0 and
  t1.typlen = -1))
order by 1;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typoutput = p1.oid and
  not (p1.prorettype = cast('cstring' as REGTYPE) and
  not p1.proretset);

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typoutput = p1.oid and
  p1.provolatile not in ('i', 's');

select distinct
  typtype,
  typoutput
from
  pg_type as t1
where
  t1.typtype not in ('b', 'd', 'p')
order by 1;

select
  t1.oid,
  t1.typname,
  t2.oid,
  t2.typname
from
  pg_type as t1
  left outer join
    pg_type as t2
  on t1.typbasetype = t2.oid
where
  t1.typtype = 'd' and
  t1.typoutput is distinct from t2.typoutput;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typreceive = p1.oid and
  not (p1.pronargs = 1 and
  p1.proargtypes[0] = cast('internal' as REGTYPE) or
  p1.pronargs = 2 and
  p1.proargtypes[0] = cast('internal' as REGTYPE) and
  p1.proargtypes[1] = cast('oid' as REGTYPE) or
  p1.pronargs = 3 and
  p1.proargtypes[0] = cast('internal' as REGTYPE) and
  p1.proargtypes[1] = cast('oid' as REGTYPE) and
  p1.proargtypes[2] = cast('int4' as REGTYPE));

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typreceive = p1.oid and
  t1.typtype in ('b', 'p') and
  not (t1.typelem <> 0 and t1.typlen < 0) and
  not (p1.prorettype = t1.oid and not p1.proretset)
order by 1;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typreceive = p1.oid and
  t1.typelem <> 0 and t1.typlen < 0 and
  not p1.oid = cast('array_recv' as REGPROC)
order by 1;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname,
  p2.oid,
  p2.proname
from
  pg_type as t1,
  pg_proc as p1,
  pg_proc as p2
where
  t1.typinput = p1.oid and
  t1.typreceive = p2.oid and
  p1.pronargs <> p2.pronargs;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typreceive = p1.oid and
  p1.provolatile not in ('i', 's');

select distinct
  typtype,
  typreceive
from
  pg_type as t1
where
  t1.typtype not in ('b', 'p')
order by 1;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typsend = p1.oid and
  t1.typtype in ('b', 'p') and
  not (p1.pronargs = 1 and
  (p1.proargtypes[0] = t1.oid or
  p1.oid = cast('array_send' as REGPROC) and
  t1.typelem <> 0 and
  t1.typlen = -1))
order by 1;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typsend = p1.oid and
  not (p1.prorettype = cast('bytea' as REGTYPE) and
  not p1.proretset);

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typsend = p1.oid and
  p1.provolatile not in ('i', 's');

select distinct
  typtype,
  typsend
from
  pg_type as t1
where
  t1.typtype not in ('b', 'd', 'p')
order by 1;

select
  t1.oid,
  t1.typname,
  t2.oid,
  t2.typname
from
  pg_type as t1
  left outer join
    pg_type as t2
  on t1.typbasetype = t2.oid
where
  t1.typtype = 'd' and
  t1.typsend is distinct from t2.typsend;

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typmodin = p1.oid and
  not (p1.pronargs = 1 and
  p1.proargtypes[0] = cast('cstring[]' as REGTYPE) and
  p1.prorettype = cast('int4' as REGTYPE) and
  not p1.proretset);

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typmodin = p1.oid and
  p1.provolatile not in ('i', 's');

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typmodout = p1.oid and
  not (p1.pronargs = 1 and
  p1.proargtypes[0] = cast('int4' as REGTYPE) and
  p1.prorettype = cast('cstring' as REGTYPE) and
  not p1.proretset);

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typmodout = p1.oid and
  p1.provolatile not in ('i', 's');

select
  t1.oid,
  t1.typname,
  t2.oid,
  t2.typname
from
  pg_type as t1,
  pg_type as t2
where
  t1.typelem = t2.oid and
  not (t1.typmodin = t2.typmodin and
  t1.typmodout = t2.typmodout);

select
  t1.oid,
  t1.typname,
  t2.oid,
  t2.typname
from
  pg_type as t1,
  pg_type as t2
where
  t1.typarray = t2.oid and
  not t1.typdelim = t2.typdelim;

select
  t1.oid,
  t1.typname,
  t1.typalign,
  t2.typname,
  t2.typalign
from
  pg_type as t1,
  pg_type as t2
where
  t1.typarray = t2.oid and
  t2.typalign <>
  case
    when t1.typalign = 'd' then cast('d' as CHAR)
    else cast('i' as CHAR)
  end;

select
  t1.oid,
  t1.typname,
  t1.typelem
from
  pg_type as t1
where
  t1.typelem <> 0 and t1.typsubscript = 0;

select
  t1.oid,
  t1.typname,
  t1.typelem,
  t1.typlen,
  t1.typbyval
from
  pg_type as t1
where
  t1.typsubscript =
  cast('array_subscript_handler' as REGPROC) and
  not (t1.typelem <> 0 and
  t1.typlen = -1 and
  not t1.typbyval);

select
  t1.oid,
  t1.typname,
  t1.typelem,
  t1.typlen,
  t1.typbyval
from
  pg_type as t1
where
  t1.typsubscript =
  cast('raw_array_subscript_handler' as REGPROC) and
  not (t1.typelem <> 0 and
  t1.typlen > 0 and
  not t1.typbyval);

select
  t1.oid,
  t1.typname,
  p1.oid,
  p1.proname
from
  pg_type as t1,
  pg_proc as p1
where
  t1.typanalyze = p1.oid and
  not (p1.pronargs = 1 and
  p1.proargtypes[0] = cast('internal' as REGTYPE) and
  p1.prorettype = cast('bool' as REGTYPE) and
  not p1.proretset);

select
  d.oid,
  d.typname,
  d.typanalyze,
  t.oid,
  t.typname,
  t.typanalyze
from
  pg_type as d
  inner join
    pg_type as t
  on d.typbasetype = t.oid
where
  d.typanalyze <> t.typanalyze;

select
  t.oid,
  t.typname,
  t.typanalyze
from
  pg_type as t
  left outer join
    pg_range as r
  on t.oid = r.rngtypid
where
  t.typbasetype = 0 and
  (t.typanalyze = cast('range_typanalyze' as REGPROC)) <>
  (r.rngtypid is not null);

select
  t.oid,
  t.typname,
  t.typanalyze
from
  pg_type as t
where
  t.typbasetype = 0 and
  (t.typanalyze = cast('array_typanalyze' as REGPROC)) <>
  (t.typsubscript =
  cast('array_subscript_handler' as REGPROC))
order by 1;

select
  c1.oid,
  c1.relname
from
  pg_class as c1
where
  relkind
  not in (
    'r', 'i', 'S', 't', 'v', 'm', 'c', 'f', 'p', 'I'
  ) or
  relpersistence not in ('p', 'u', 't') or
  relreplident not in ('d', 'n', 'f', 'i');

select
  c1.oid,
  c1.relname
from
  pg_class as c1
where
  c1.relkind not in ('S', 'v', 'f', 'c', 'p') and
  c1.relam = 0;

select
  c1.oid,
  c1.relname
from
  pg_class as c1
where
  c1.relkind in ('S', 'v', 'f', 'c', 'p') and
  c1.relam <> 0;

select
  pc.oid,
  pc.relname,
  pa.amname,
  pa.amtype
from
  pg_class as pc
  inner join
    pg_am as pa
  on pc.relam = pa.oid
where
  pc.relkind in ('i', 'I') and pa.amtype <> 'i';

select
  pc.oid,
  pc.relname,
  pa.amname,
  pa.amtype
from
  pg_class as pc
  inner join
    pg_am as pa
  on pc.relam = pa.oid
where
  pc.relkind in ('r', 't', 'm') and pa.amtype <> 't';

select
  a1.attrelid,
  a1.attname
from
  pg_attribute as a1
where
  a1.attrelid = 0 or
  a1.atttypid = 0 or
  a1.attnum = 0 or
  a1.attinhcount < 0 or
  a1.attinhcount = 0 and not a1.attislocal;

select
  a1.attrelid,
  a1.attname,
  c1.oid,
  c1.relname
from
  pg_attribute as a1,
  pg_class as c1
where
  a1.attrelid = c1.oid and a1.attnum > c1.relnatts;

select
  c1.oid,
  c1.relname
from
  pg_class as c1
where
  c1.relnatts <>
  (
    select
      COUNT(*)
    from
      pg_attribute as a1
    where
      a1.attrelid = c1.oid and a1.attnum > 0
  );

select
  a1.attrelid,
  a1.attname,
  t1.oid,
  t1.typname
from
  pg_attribute as a1,
  pg_type as t1
where
  a1.atttypid = t1.oid and
  (a1.attlen <> t1.typlen or
  a1.attalign <> t1.typalign or
  a1.attbyval <> t1.typbyval or
  a1.attstorage <> t1.typstorage and
  a1.attstorage <> 'p');

create function is_catalog_text_unique_index_oid(OID)
returns BOOLEAN
as 'regresslib', 'is_catalog_text_unique_index_oid'
language c
STRICT;

select
  cast(indexrelid as REGCLASS)
from
  pg_index
where
  is_catalog_text_unique_index_oid(indexrelid) <>
  (indisunique and
  indexrelid < 16384 and
  exists
  (
    select
      1
    from
      pg_attribute
    where
      attrelid = indexrelid and
      atttypid = cast('text' as REGTYPE)
  ));

select
  r.rngtypid,
  r.rngsubtype
from
  pg_range as r
where
  r.rngtypid = 0 or
  r.rngsubtype = 0 or
  r.rngsubopc = 0;

select
  r.rngtypid,
  r.rngsubtype,
  r.rngcollation,
  t.typcollation
from
  pg_range as r
  inner join
    pg_type as t
  on t.oid = r.rngsubtype
where
  (rngcollation = 0) <> (typcollation = 0);

select
  r.rngtypid,
  r.rngsubtype,
  o.opcmethod,
  o.opcname
from
  pg_range as r
  inner join
    pg_opclass as o
  on o.oid = r.rngsubopc
where
  o.opcmethod <> 403 or
  o.opcintype <> r.rngsubtype and
  not (o.opcintype =
  cast('pg_catalog.anyarray' as REGTYPE) and
  exists
  (
    select
      1
    from
      pg_catalog.pg_type
    where
      oid = r.rngsubtype and
      typelem <> 0 and
      typsubscript =
      cast('array_subscript_handler' as REGPROC)
  ));

select
  r.rngtypid,
  r.rngsubtype,
  p.proname
from
  pg_range as r
  inner join
    pg_proc as p
  on p.oid = r.rngcanonical
where
  pronargs <> 1 or
  proargtypes[0] <> rngtypid or
  prorettype <> rngtypid;

select
  r.rngtypid,
  r.rngsubtype,
  p.proname
from
  pg_range as r
  inner join
    pg_proc as p
  on p.oid = r.rngsubdiff
where
  pronargs <> 2 or
  proargtypes[0] <> rngsubtype or
  proargtypes[1] <> rngsubtype or
  prorettype <> cast('pg_catalog.float8' as REGTYPE);

select
  r.rngtypid,
  r.rngsubtype,
  r.rngmultitypid
from
  pg_range as r
where
  r.rngmultitypid is null or r.rngmultitypid = 0;

create table tab_core_types
as
  select
    cast('(11,12)' as point),
    cast('(1,1),(2,2)' as line),
    cast('((11,11),(12,12))' as lseg),
    cast('((11,11),(13,13))' as box),
    cast('((11,12),(13,13),(14,14))' as path)
    as openedpath,
    cast('[(11,12),(13,13),(14,14)]' as path)
    as closedpath,
    cast('((11,12),(13,13),(14,14))' as polygon),
    cast('1,1,1' as circle),
    cast('today' as DATE),
    cast('now' as TIME),
    cast('now' as TIMESTAMP),
    cast('now' as time with time ZONE),
    cast('now' as timestamp with time ZONE),
    cast('12 seconds' as INTERVAL),
    cast('{"reason":"because"}' as JSON),
    cast('{"when":"now"}' as JSONB),
    cast('$.a[*] ? (@ > 2)' as jsonpath),
    cast('127.0.0.1' as INET),
    cast('127.0.0.0/8' as CIDR),
    cast('00:01:03:86:1c:ba' as MACADDR8),
    cast('00:01:03:86:1c:ba' as MACADDR),
    cast(2 as SMALLINT),
    cast(4 as INT),
    cast(8 as BIGINT),
    cast(4 as REAL),
    cast('8' as DOUBLE PRECISION),
    cast(pi() as NUMERIC),
    cast('foo' as CHAR),
    cast('c' as CHAR),
    cast('abc' as VARCHAR),
    cast('name' as NAME),
    cast('txt' as TEXT),
    cast(true as BOOLEAN),
    cast('\xDEADBEEF' as BYTEA),
    cast(B'10001' as BIT(1)),
    cast(B'10001' as BIT VARYING) as varbit,
    cast('12.34' as MONEY),
    cast('abc' as refcursor),
    cast('1 2' as int2vector),
    cast('1 2' as oidvector),
    cast(format('%I=UC/%I', user, user) as aclitem)
    as aclitem,
    cast('a fat cat sat on a mat and ate a fat rat'
    as TSVECTOR),
    cast('fat & rat' as TSQUERY),
    cast('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'
    as UUID),
    cast('11' as xid8),
    cast('pg_class' as REGCLASS),
    cast('regtype' as REGTYPE) as type,
    cast('pg_monitor' as regrole),
    cast(cast('pg_class' as REGCLASS) as OID),
    cast('template1' as regdatabase),
    cast('(1,1)' as TID),
    cast('2' as XID),
    cast('3' as CID),
    cast('10:20:10,14,15' as TXID_SNAPSHOT),
    cast('10:20:10,14,15' as pg_snapshot),
    cast('16/B374D848' as PG_LSN),
    cast(1 as information_schema.cardinal_number),
    cast('l' as information_schema.character_data),
    cast('n' as information_schema.sql_identifier),
    cast('now' as information_schema.time_stamp),
    cast('YES' as information_schema.yes_or_no),
    cast('(1,2)' as INT4RANGE),
    cast('{(1,2)}' as int4multirange),
    cast('(3,4)' as INT8RANGE),
    cast('{(3,4)}' as int8multirange),
    cast('(3,4)' as NUMRANGE),
    cast('{(3,4)}' as nummultirange),
    cast('(2020-01-02, 2021-02-03)' as DATERANGE),
    cast('{(2020-01-02, 2021-02-03)}'
    as datemultirange),
    cast('(2020-01-02 03:04:05, 2021-02-03 06:07:08)'
    as TSRANGE),
    cast('{(2020-01-02 03:04:05, 2021-02-03 06:07:08)}'
    as tsmultirange),
    cast('(2020-01-02 03:04:05, 2021-02-03 06:07:08)'
    as TSTZRANGE),
    cast('{(2020-01-02 03:04:05, 2021-02-03 06:07:08)}'
    as tstzmultirange);

select
  oid,
  typname,
  typtype,
  typelem,
  typarray
from
  pg_type as t
where
  oid < 16384 and
  typtype not in ('p', 'c') and
  oid <> all (cast(array['regproc',
  'regprocedure',
  'regoper',
  'regoperator',
  'regconfig',
  'regdictionary',
  'regnamespace',
  'regcollation']
  as REGTYPE[])) and
  oid <> all (cast(array['gtsvector',
  'pg_node_tree',
  'pg_ndistinct',
  'pg_dependencies',
  'pg_mcv_list',
  'pg_brin_bloom_summary',
  'pg_brin_minmax_multi_summary',
  'xml']
  as REGTYPE[])) and
  not exists
  (
    select
      1
    from
      pg_type as u
    where
      u.typarray = t.oid
  ) and
  not exists
  (
    select
      1
    from
      pg_attribute as a
    where
      a.atttypid = t.oid and
      a.attnum > 0 and
      a.attrelid = cast('tab_core_types' as REGCLASS)
  );
