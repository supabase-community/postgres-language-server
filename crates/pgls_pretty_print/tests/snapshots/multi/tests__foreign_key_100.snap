---
source: crates/pgls_pretty_print/tests/tests.rs
input_file: crates/pgls_pretty_print/tests/data/multi/foreign_key.sql
snapshot_kind: text
---
create table pktable (
  ptest1 INT primary key,
  ptest2 TEXT
);

insert into fktable values (1, 2);

insert into fktable values (2, 3);

select * from fktable;

insert into pktable values (1, 'Test1');

insert into pktable values (2, 'Test2');

insert into fktable values (3, 4);

insert into pktable values (3, 'Test3');

insert into pktable values (4, 'Test4');

insert into pktable values (5, 'Test5');

insert into fktable values (3, 4);

insert into fktable values (null, 1);

insert into fktable values (100, 2);

select * from fktable;

delete from pktable where ptest1 = 1;

select * from fktable;

update pktable set ptest1 = 1 where ptest1 = 2;

select * from fktable;

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INT,
  ptest3 TEXT,
  primary key (ptest1, ptest2)
);

create table fktable (
  ftest1 INT,
  ftest2 INT,
  ftest3 INT,
  constraint "constrname"
  foreign key
  (ftest1,
  ftest2)
  references pktable
  match full
  on DELETE set null
  on UPDATE set null
);

comment on constraint constrname_wrong on fktable is 'fk constraint comment';

comment on constraint constrname on fktable is 'fk constraint comment';

comment on constraint constrname on fktable is null;

insert into pktable values (1, 2, 'Test1');

insert into pktable values (1, 3, 'Test1-2');

insert into pktable values (2, 4, 'Test2');

insert into pktable values (3, 6, 'Test3');

insert into pktable values (4, 8, 'Test4');

insert into pktable values (5, 10, 'Test5');

insert into fktable values (1, 2, 4);

insert into fktable values (1, 3, 5);

insert into fktable values (2, 4, 8);

insert into fktable values (3, 6, 12);

insert into fktable values (null, null, 0);

insert into fktable values (100, 2, 4);

insert into fktable values (2, 2, 4);

insert into fktable values (null, 2, 4);

insert into fktable values (1, null, 4);

select * from fktable;

delete from pktable where ptest1 = 1 and ptest2 = 2;

select * from fktable;

delete from pktable where ptest1 = 5 and ptest2 = 10;

select * from fktable;

update pktable set ptest1 = 1 where ptest1 = 2;

select * from fktable;

update fktable set ftest1 = null where ftest1 = 1;

update fktable set ftest1 = 1 where ftest1 = 1;

alter table pktable
  alter column ptest1 type BIGINT;

alter table fktable
  alter column ftest1 type BIGINT;

select * from pktable;

select * from fktable;

drop TABLE "pktable" cascade;

drop TABLE "fktable";

create table pktable (
  ptest1 INT,
  ptest2 INT,
  ptest3 TEXT,
  primary key (ptest1, ptest2)
);

create table fktable (
  ftest1 INT default -1,
  ftest2 INT default -2,
  ftest3 INT,
  constraint "constrname2"
  foreign key
  (ftest1,
  ftest2)
  references pktable
  match full
  on DELETE set default
  on UPDATE set default
);

insert into pktable values (-1, -2, 'The Default!');

insert into pktable values (1, 2, 'Test1');

insert into pktable values (1, 3, 'Test1-2');

insert into pktable values (2, 4, 'Test2');

insert into pktable values (3, 6, 'Test3');

insert into pktable values (4, 8, 'Test4');

insert into pktable values (5, 10, 'Test5');

insert into fktable values (1, 2, 4);

insert into fktable values (1, 3, 5);

insert into fktable values (2, 4, 8);

insert into fktable values (3, 6, 12);

insert into fktable values (null, null, 0);

insert into fktable values (100, 2, 4);

insert into fktable values (2, 2, 4);

insert into fktable values (null, 2, 4);

insert into fktable values (1, null, 4);

select * from fktable;

delete from pktable where ptest1 = 1 and ptest2 = 2;

select * from fktable;

delete from pktable where ptest1 = 5 and ptest2 = 10;

select * from fktable;

update pktable set ptest1 = 1 where ptest1 = 2;

select * from fktable;

drop TABLE "pktable";

drop TABLE "pktable" cascade;

drop TABLE "fktable";

create table pktable (
  ptest1 INT primary key,
  ptest2 TEXT
);

create table fktable (
  ftest1 INT references pktable match full,
  ftest2 INT
);

insert into pktable values (1, 'Test1');

insert into pktable values (2, 'Test2');

insert into pktable values (3, 'Test3');

insert into pktable values (4, 'Test4');

insert into pktable values (5, 'Test5');

insert into fktable values (1, 2);

insert into fktable values (2, 3);

insert into fktable values (3, 4);

insert into fktable values (null, 1);

insert into fktable values (100, 2);

select * from fktable;

select * from pktable;

delete from pktable where ptest1 = 1;

delete from pktable where ptest1 = 5;

select * from pktable;

update pktable set ptest1 = 0 where ptest1 = 2;

update pktable set ptest1 = 0 where ptest1 = 4;

select * from pktable;

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INT,
  primary key (ptest1, ptest2)
);

create table fktable (
  ftest1 INT,
  ftest2 INT
);

insert into pktable values (1, 2);

insert into fktable values (1, null);

alter table fktable
  add foreign key
  (ftest1,
  ftest2)
  references pktable
  match full;

alter table fktable
  alter constraint "fk_con" deferrable initially deferred;

select
  condeferrable,
  condeferred,
  conenforced,
  convalidated
from
  pg_constraint
where
  conname = 'fk_con';

select
  condeferrable,
  condeferred,
  conenforced,
  convalidated
from
  pg_constraint
where
  conname = 'fk_con';

select
  condeferrable,
  condeferred,
  conenforced,
  convalidated
from
  pg_constraint
where
  conname = 'fk_con';

select
  condeferrable,
  condeferred,
  conenforced,
  convalidated
from
  pg_constraint
where
  conname = 'fk_con';

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INT,
  ptest3 INT,
  ptest4 TEXT,
  primary key (ptest1, ptest2, ptest3)
);

create table fktable (
  ftest1 INT,
  ftest2 INT,
  ftest3 INT,
  ftest4 INT,
  constraint "constrname3"
  foreign key
  (ftest1,
  ftest2,
  ftest3)
  references pktable
);

insert into pktable values (1, 2, 3, 'test1');

insert into pktable values (1, 3, 3, 'test2');

insert into pktable values (2, 3, 4, 'test3');

insert into pktable values (2, 4, 5, 'test4');

insert into fktable values (1, 2, 3, 1);

insert into fktable values (null, 2, 3, 2);

insert into fktable values (2, null, 3, 3);

insert into fktable values (null, 2, 7, 4);

insert into fktable values (null, 3, 4, 5);

insert into fktable values (1, 2, 7, 6);

select * from fktable;

update pktable set ptest2 = 5 where ptest2 = 2;

update pktable set ptest1 = 1 where ptest2 = 3;

delete from pktable where ptest1 = 1 and ptest2 = 2 and ptest3 = 3;

delete from pktable where ptest1 = 2;

select * from pktable;

select * from fktable;

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INT,
  ptest3 INT,
  ptest4 TEXT,
  unique (ptest1, ptest2, ptest3)
);

create table fktable (
  ftest1 INT,
  ftest2 INT,
  ftest3 INT,
  ftest4 INT,
  constraint "constrname3"
  foreign key
  (ftest1,
  ftest2,
  ftest3)
  references pktable (ptest1,
  ptest2,
  ptest3)
);

insert into pktable values (1, 2, 3, 'test1');

insert into pktable values (1, 3, null, 'test2');

insert into pktable values (2, null, 4, 'test3');

insert into fktable values (1, 2, 3, 1);

delete from pktable where ptest1 = 2;

select * from pktable;

select * from fktable;

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INT,
  ptest3 INT,
  ptest4 TEXT,
  primary key (ptest1, ptest2, ptest3)
);

create table fktable (
  ftest1 INT,
  ftest2 INT,
  ftest3 INT,
  ftest4 INT,
  constraint "constrname3"
  foreign key
  (ftest1,
  ftest2,
  ftest3)
  references pktable
  on DELETE cascade
  on UPDATE cascade
);

insert into pktable values (1, 2, 3, 'test1');

insert into pktable values (1, 3, 3, 'test2');

insert into pktable values (2, 3, 4, 'test3');

insert into pktable values (2, 4, 5, 'test4');

insert into fktable values (1, 2, 3, 1);

insert into fktable values (null, 2, 3, 2);

insert into fktable values (2, null, 3, 3);

insert into fktable values (null, 2, 7, 4);

insert into fktable values (null, 3, 4, 5);

insert into fktable values (1, 2, 7, 6);

select * from fktable;

update pktable set ptest2 = 5 where ptest2 = 2;

update pktable set ptest1 = 1 where ptest2 = 3;

select * from pktable;

select * from fktable;

delete from pktable where ptest1 = 1 and ptest2 = 5 and ptest3 = 3;

select * from pktable;

select * from fktable;

delete from pktable where ptest1 = 2;

select * from pktable;

select * from fktable;

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INT,
  ptest3 INT,
  ptest4 TEXT,
  primary key (ptest1, ptest2, ptest3)
);

create table fktable (
  ftest1 INT default 0,
  ftest2 INT,
  ftest3 INT,
  ftest4 INT,
  constraint "constrname3"
  foreign key
  (ftest1,
  ftest2,
  ftest3)
  references pktable
  on DELETE set default
  on UPDATE set null
);

insert into pktable values (1, 2, 3, 'test1');

insert into pktable values (1, 3, 3, 'test2');

insert into pktable values (2, 3, 4, 'test3');

insert into pktable values (2, 4, 5, 'test4');

insert into fktable values (1, 2, 3, 1);

insert into fktable values (2, 3, 4, 1);

insert into fktable values (null, 2, 3, 2);

insert into fktable values (2, null, 3, 3);

insert into fktable values (null, 2, 7, 4);

insert into fktable values (null, 3, 4, 5);

insert into fktable values (1, 2, 7, 6);

select * from fktable;

update pktable set ptest2 = 5 where ptest2 = 2;

update pktable set ptest2 = 2 where ptest2 = 3 and ptest1 = 1;

select * from pktable;

select * from fktable;

delete from pktable where ptest1 = 2 and ptest2 = 3 and ptest3 = 4;

select * from pktable;

select * from fktable;

delete from pktable where ptest2 = 5;

select * from pktable;

select * from fktable;

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INT,
  ptest3 INT,
  ptest4 TEXT,
  primary key (ptest1, ptest2, ptest3)
);

create table fktable (
  ftest1 INT default 0,
  ftest2 INT default -1,
  ftest3 INT default -2,
  ftest4 INT,
  constraint "constrname3"
  foreign key
  (ftest1,
  ftest2,
  ftest3)
  references pktable
  on DELETE set null
  on UPDATE set default
);

insert into pktable values (1, 2, 3, 'test1');

insert into pktable values (1, 3, 3, 'test2');

insert into pktable values (2, 3, 4, 'test3');

insert into pktable values (2, 4, 5, 'test4');

insert into pktable values (2, -1, 5, 'test5');

insert into fktable values (1, 2, 3, 1);

insert into fktable values (2, 3, 4, 1);

insert into fktable values (2, 4, 5, 1);

insert into fktable values (null, 2, 3, 2);

insert into fktable values (2, null, 3, 3);

insert into fktable values (null, 2, 7, 4);

insert into fktable values (null, 3, 4, 5);

insert into fktable values (1, 2, 7, 6);

select * from fktable;

update pktable set ptest2 = 5 where ptest2 = 2;

update pktable set ptest1 = 0, ptest2 = -1, ptest3 = -2 where ptest2 = 2;

update pktable set ptest2 = 10 where ptest2 = 4;

update pktable set ptest2 = 2 where ptest2 = 3 and ptest1 = 1;

select * from pktable;

select * from fktable;

delete from pktable where ptest1 = 2 and ptest2 = 3 and ptest3 = 4;

select * from pktable;

select * from fktable;

delete from pktable where ptest2 = -1 and ptest3 = 5;

select * from pktable;

select * from fktable;

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  tid INT,
  id INT,
  primary key (tid, id)
);

create table fktable (
  tid INT,
  id INT,
  foo INT,
  foreign key
  (tid,
  id)
  references pktable
  on DELETE set null (bar)
);

create table fktable (
  tid INT,
  id INT,
  foo INT,
  foreign key
  (tid,
  id)
  references pktable
  on DELETE set null (foo)
);

create table fktable (
  tid INT,
  id INT,
  fk_id_del_set_null INT,
  fk_id_del_set_default INT default 0,
  foreign key
  (tid,
  fk_id_del_set_null)
  references pktable
  on DELETE set null (fk_id_del_set_null),
  foreign key
  (tid,
  fk_id_del_set_default)
  references pktable
  on DELETE set default (fk_id_del_set_default,
  fk_id_del_set_default)
);

select
  pg_get_constraintdef(oid)
from
  pg_constraint
where
  conrelid =
  cast(cast('fktable' as REGCLASS) as OID)
order by oid;

insert into pktable values (1, 0), (1, 1), (1, 2);

insert into fktable values (1, 1, 1, null), (1, 2, null, 2);

delete from pktable where id = 1 or id = 2;

select * from fktable order by id;

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT primary key,
  someoid OID
);

create table fktable_fail1 (
  ftest1 INT,
  constraint "fkfail1"
  foreign key
  (ftest2)
  references pktable
);

create table fktable_fail2 (
  ftest1 INT,
  constraint "fkfail1"
  foreign key
  (ftest1)
  references pktable (ptest2)
);

create table fktable_fail3 (
  ftest1 INT,
  constraint "fkfail1"
  foreign key
  (tableoid)
  references pktable (someoid)
);

create table fktable_fail4 (
  ftest1 OID,
  constraint "fkfail1"
  foreign key
  (ftest1)
  references pktable (tableoid)
);

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INT,
  unique (ptest1, ptest2)
);

create table fktable_fail1 (ftest1 INT references pktable (ptest1));

drop TABLE "fktable_fail1";

drop TABLE "pktable";

create table pktable (ptest1 INT primary key);

insert into pktable values (42);

create table fktable (ftest1 INET references pktable);

create table fktable (ftest1 INET references pktable (ptest1));

create table fktable (ftest1 BIGINT references pktable);

insert into fktable values (42);

insert into fktable values (43);

update fktable set ftest1 = ftest1;

update fktable set ftest1 = ftest1 + 1;

drop TABLE "fktable";

create table fktable (ftest1 NUMERIC references pktable);

drop TABLE "pktable";

create table pktable (ptest1 NUMERIC primary key);

insert into pktable values (42);

create table fktable (ftest1 INT references pktable);

insert into fktable values (42);

insert into fktable values (43);

update fktable set ftest1 = ftest1;

update fktable set ftest1 = ftest1 + 1;

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INET,
  primary key (ptest1, ptest2)
);

create table fktable (
  ftest1 CIDR,
  ftest2 TIMESTAMP,
  foreign key (ftest1, ftest2) references pktable
);

create table fktable (
  ftest1 CIDR,
  ftest2 TIMESTAMP,
  foreign key
  (ftest1,
  ftest2)
  references pktable (ptest1,
  ptest2)
);

create table fktable (
  ftest1 INT,
  ftest2 INET,
  foreign key (ftest2, ftest1) references pktable
);

create table fktable (
  ftest1 INT,
  ftest2 INET,
  foreign key
  (ftest2,
  ftest1)
  references pktable (ptest1,
  ptest2)
);

create table fktable (
  ftest1 INT,
  ftest2 INET,
  foreign key
  (ftest1,
  ftest2)
  references pktable (ptest2,
  ptest1)
);

create table fktable (
  ftest1 INT,
  ftest2 INET,
  foreign key
  (ftest2,
  ftest1)
  references pktable (ptest2,
  ptest1)
);

drop TABLE "fktable";

create table fktable (
  ftest1 INT,
  ftest2 INET,
  foreign key
  (ftest1,
  ftest2)
  references pktable (ptest1,
  ptest2)
);

drop TABLE "fktable";

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INET,
  ptest3 INT,
  ptest4 INET,
  primary key (ptest1, ptest2),
  foreign key
  (ptest3,
  ptest4)
  references pktable (ptest1,
  ptest2)
);

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INET,
  ptest3 INT,
  ptest4 INET,
  primary key (ptest1, ptest2),
  foreign key (ptest3, ptest4) references pktable
);

drop TABLE "pktable";

create table pktable (
  ptest1 INT,
  ptest2 INET,
  ptest3 INT,
  ptest4 INET,
  primary key (ptest1, ptest2),
  foreign key
  (ptest3,
  ptest4)
  references pktable (ptest2,
  ptest1)
);

create table pktable (
  ptest1 INT,
  ptest2 INET,
  ptest3 INT,
  ptest4 INET,
  primary key (ptest1, ptest2),
  foreign key
  (ptest4,
  ptest3)
  references pktable (ptest1,
  ptest2)
);

create table pktable (
  ptest1 INT,
  ptest2 INET,
  ptest3 INT,
  ptest4 INET,
  primary key (ptest1, ptest2),
  foreign key (ptest4, ptest3) references pktable
);

create table pktable_base (base1 INT not null);

create table pktable (
  ptest1 INT,
  primary key (base1),
  unique (base1, ptest1)
)
inherits (pktable_base);

create table fktable (ftest1 INT references pktable (base1));

insert into pktable (base1) values (1);

insert into pktable (base1) values (2);

insert into fktable (ftest1) values (3);

insert into pktable (base1) values (3);

insert into fktable (ftest1) values (3);

delete from pktable where base1 > 2;

update pktable set base1 = base1 * 4;

update pktable set base1 = base1 * 4 where base1 < 3;

delete from pktable where base1 > 3;

drop TABLE "fktable";

delete from pktable;

create table fktable (
  ftest1 INT,
  ftest2 INT,
  foreign key
  (ftest1,
  ftest2)
  references pktable (base1,
  ptest1)
);

insert into pktable (base1, ptest1) values (1, 1);

insert into pktable (base1, ptest1) values (2, 2);

insert into fktable (ftest1, ftest2) values (3, 1);

insert into pktable (base1, ptest1) values (3, 1);

insert into fktable (ftest1, ftest2) values (3, 1);

delete from pktable where base1 > 2;

update pktable set base1 = base1 * 4;

update pktable set base1 = base1 * 4 where base1 < 3;

delete from pktable where base1 > 3;

drop TABLE "fktable";

drop TABLE "pktable";

drop TABLE "pktable_base";

create table pktable_base (
  base1 INT not null,
  base2 INT
);

create table pktable (
  ptest1 INT,
  ptest2 INT,
  primary key (base1, ptest1),
  foreign key
  (base2,
  ptest2)
  references pktable (base1,
  ptest1)
)
inherits (pktable_base);

insert into pktable (base1, ptest1, base2, ptest2) values (1, 1, 1, 1);

insert into pktable (base1, ptest1, base2, ptest2) values (2, 1, 1, 1);

insert into pktable (base1, ptest1, base2, ptest2) values (2, 2, 2, 1);

insert into pktable (base1, ptest1, base2, ptest2) values (1, 3, 2, 2);

insert into pktable (base1, ptest1, base2, ptest2) values (2, 3, 3, 2);

delete from pktable where base1 = 2;

update pktable set base1 = 3 where base1 = 1;

delete from pktable where base2 = 2;

delete from pktable where base1 = 2;

drop TABLE "pktable";

drop TABLE "pktable_base";

create table pktable_base (base1 INT not null);

create table pktable (
  ptest1 INET,
  primary key (base1, ptest1)
)
inherits (pktable_base);

create table fktable (
  ftest1 CIDR,
  ftest2 INT[],
  foreign key (ftest1, ftest2) references pktable
);

create table fktable (
  ftest1 CIDR,
  ftest2 INT[],
  foreign key
  (ftest1,
  ftest2)
  references pktable (base1,
  ptest1)
);

create table fktable (
  ftest1 INT,
  ftest2 INET,
  foreign key (ftest2, ftest1) references pktable
);

create table fktable (
  ftest1 INT,
  ftest2 INET,
  foreign key
  (ftest2,
  ftest1)
  references pktable (base1,
  ptest1)
);

create table fktable (
  ftest1 INT,
  ftest2 INET,
  foreign key
  (ftest1,
  ftest2)
  references pktable (ptest1,
  base1)
);

drop TABLE "pktable";

drop TABLE "pktable_base";

create table pktable_base (
  base1 INT not null,
  base2 INT
);

create table pktable (
  ptest1 INET,
  ptest2 INET[],
  primary key (base1, ptest1),
  foreign key
  (base2,
  ptest2)
  references pktable (base1,
  ptest1)
)
inherits (pktable_base);

create table pktable (
  ptest1 INET,
  ptest2 INET,
  primary key (base1, ptest1),
  foreign key
  (base2,
  ptest2)
  references pktable (ptest1,
  base1)
)
inherits (pktable_base);

create table pktable (
  ptest1 INET,
  ptest2 INET,
  primary key (base1, ptest1),
  foreign key
  (ptest2,
  base2)
  references pktable (base1,
  ptest1)
)
inherits (pktable_base);

create table pktable (
  ptest1 INET,
  ptest2 INET,
  primary key (base1, ptest1),
  foreign key
  (ptest2,
  base2)
  references pktable (base1,
  ptest1)
)
inherits (pktable_base);

drop TABLE "pktable";

drop TABLE "pktable_base";

create table pktable (
  id INT primary key,
  other INT
);

create table fktable (
  id INT primary key,
  fk INT references pktable deferrable
);

insert into fktable values (5, 10);

begin;

set CONSTRAINTS all DEFERRED;

insert into fktable values (10, 15);

insert into pktable values (15, 0);

commit;

drop TABLE "fktable", "pktable";

create table pktable (
  id INT primary key,
  other INT
);

create table fktable (
  id INT primary key,
  fk INT
  references pktable
  deferrable
  initially deferred
);

begin;

insert into fktable values (100, 200);

insert into pktable values (200, 500);

commit;

begin;

set CONSTRAINTS all IMMEDIATE;

insert into fktable values (500, 1000);

commit;

drop TABLE "fktable", "pktable";

create table pktable (
  id INT primary key,
  other INT
);

create table fktable (
  id INT primary key,
  fk INT references pktable deferrable
);

begin;

set CONSTRAINTS all DEFERRED;

insert into fktable values (1000, 2000);

set CONSTRAINTS all IMMEDIATE;

insert into pktable values (2000, 3);

commit;

drop TABLE "fktable", "pktable";

create table pktable (
  id INT primary key,
  other INT
);

create table fktable (
  id INT primary key,
  fk INT
  references pktable
  deferrable
  initially deferred
);

begin;

insert into fktable values (100, 200);

commit;

drop TABLE "pktable", "fktable";

create temporary table pktable (
  id1 INT primary key,
  id2 VARCHAR(4) unique,
  id3 REAL unique,
  unique (id1, id2, id3)
);

create temporary table fktable (
  x1 INT references pktable (id1),
  x2 VARCHAR(4) references pktable (id2),
  x3 REAL references pktable (id3),
  x4 TEXT,
  x5 SMALLINT
);

alter table fktable
  add constraint "fk_2_3"
  foreign key
  (x2)
  references pktable (id3);

alter table fktable
  add constraint "fk_2_1"
  foreign key
  (x2)
  references pktable (id1);

alter table fktable
  add constraint "fk_3_1"
  foreign key
  (x3)
  references pktable (id1);

alter table fktable
  add constraint "fk_1_2"
  foreign key
  (x1)
  references pktable (id2);

alter table fktable
  add constraint "fk_1_3"
  foreign key
  (x1)
  references pktable (id3);

alter table fktable
  add constraint "fk_4_2"
  foreign key
  (x4)
  references pktable (id2);

alter table fktable
  add constraint "fk_5_1"
  foreign key
  (x5)
  references pktable (id1);

alter table fktable
  add constraint "fk_123_123"
  foreign key
  (x1,
  x2,
  x3)
  references pktable (id1,
  id2,
  id3);

alter table fktable
  add constraint "fk_213_213"
  foreign key
  (x2,
  x1,
  x3)
  references pktable (id2,
  id1,
  id3);

alter table fktable
  add constraint "fk_253_213"
  foreign key
  (x2,
  x5,
  x3)
  references pktable (id2,
  id1,
  id3);

alter table fktable
  add constraint "fk_123_231"
  foreign key
  (x1,
  x2,
  x3)
  references pktable (id2,
  id3,
  id1);

alter table fktable
  add constraint "fk_241_132"
  foreign key
  (x2,
  x4,
  x1)
  references pktable (id1,
  id3,
  id2);

drop TABLE "pktable", "fktable";

create temporary table pktable (
  id INT primary key,
  other INT
);

create temporary table fktable (
  id INT primary key,
  fk INT
  references pktable
  deferrable
  initially deferred
);

insert into pktable values (5, 10);

begin;

insert into fktable values (0, 20);

update fktable set id = id + 1;

commit;

begin;

insert into fktable values (0, 20);

savepoint savept1;

update fktable set id = id + 1;

commit;

begin;

savepoint savept1;

insert into fktable values (0, 20);

release savepoint savept1;

update fktable set id = id + 1;

commit;

begin;

insert into fktable values (0, 20);

savepoint savept1;

update fktable set id = id + 1;

rollback to savepoint savept1;

commit;

insert into fktable values (1, 5);

alter table fktable
  alter constraint "fktable_fk_fkey" deferrable initially immediate;

begin;

update pktable set id = 10 where id = 5;

commit;

begin;

insert into fktable values (0, 20);

commit;

begin;

update pktable set id = 10 where id = 5;

insert into fktable values (0, 20);

rollback;

alter table fktable
  alter constraint "fktable_fk_fkey" not deferrable initially immediate;

create temporary table users (
  id INT primary key,
  name VARCHAR not null
);

insert into users values (1, 'Jozko');

insert into users values (2, 'Ferko');

insert into users values (3, 'Samko');

create temporary table tasks (
  id INT primary key,
  owner INT
  references users
  on DELETE set null
  on UPDATE cascade,
  worker INT
  references users
  on DELETE set null
  on UPDATE cascade,
  checked_by INT
  references users
  on DELETE set null
  on UPDATE cascade
);

insert into tasks values (1, 1, null, null);

insert into tasks values (2, 2, 2, null);

insert into tasks values (3, 3, 3, 3);

select * from tasks;

update users set id = 4 where id = 3;

select * from tasks;

delete from users where id = 4;

select * from tasks;

begin;

update tasks set id = id where id = 2;

select * from tasks;

delete from users where id = 2;

select * from tasks;

commit;

create temporary table selfref (
  a INT primary key,
  b INT,
  foreign key
  (b)
  references selfref (a)
  on DELETE cascade
  on UPDATE cascade
);

insert into selfref (a, b) values (0, 0), (1, 1);

begin;

update selfref set a = 123 where a = 0;

select a, b from selfref;

update selfref set a = 456 where a = 123;

select a, b from selfref;

commit;

create temporary table defp (f1 INT primary key);

create temporary table defc (f1 INT default 0 references defp on DELETE set default);

insert into defp values (0), (1), (2);

insert into defc values (2);

select * from defc;

delete from defp where f1 = 2;

select * from defc;

delete from defp where f1 = 0;

alter table defc
  alter column f1 set default 1;

delete from defp where f1 = 0;

select * from defc;

delete from defp where f1 = 1;

create temporary table pp (f1 INT primary key);

create temporary table cc (f1 INT references pp);

insert into pp values (12);

insert into pp values (11);

update pp set f1 = f1 + 1;

insert into cc values (13);

update pp set f1 = f1 + 1;

update pp set f1 = f1 + 1;

delete from pp where f1 = 13;

drop TABLE "pp", "cc";

create temporary table pp (f1 INT primary key);

create temporary table cc (f1 INT references pp on DELETE restrict on UPDATE restrict);

insert into pp values (12);

insert into pp values (11);

update pp set f1 = f1 + 1;

insert into cc values (13);

update pp set f1 = f1 + 1;

delete from pp where f1 = 13;

drop TABLE "pp", "cc";

create temporary table t1 (
  a INT primary key,
  b TEXT
);

create temporary table t2 (
  a INT primary key,
  b INT references t1
);

create rule r1
as on delete to t1
do
  delete from t2 where t2.b = old.a;;

delete from t1 where a = 1;

delete from t1 where a = 1;

create table pktable2 (
  a INT,
  b INT,
  c INT,
  d INT,
  e INT,
  primary key (d, e)
);

create table fktable2 (
  d INT,
  e INT,
  foreign key (d, e) references pktable2
);

insert into pktable2 values (1, 2, 3, 4, 5);

insert into fktable2 values (4, 5);

delete from pktable2;

update pktable2 set d = 5;

drop TABLE "pktable2", "fktable2";

create table pktable1 (a INT primary key);

create table pktable2 (
  a INT,
  b INT,
  primary key (a, b)
);

create table fktable2 (
  a INT,
  b INT,
  very_very_long_column_name_to_exceed_63_characters INT,
  foreign key
  (very_very_long_column_name_to_exceed_63_characters)
  references pktable1,
  foreign key
  (a,
  very_very_long_column_name_to_exceed_63_characters)
  references pktable2,
  foreign key
  (a,
  very_very_long_column_name_to_exceed_63_characters)
  references pktable2
);

select conname from pg_constraint where conrelid = cast('fktable2' as REGCLASS) order by conname;

drop TABLE "pktable1", "pktable2", "fktable2";

create table pktable2 (f1 INT primary key);

create table fktable2 (f1 INT references pktable2 deferrable initially deferred);

insert into pktable2 values (1);

begin;

insert into fktable2 values (1);

savepoint x;

delete from fktable2;

rollback to savepoint x;

commit;

begin;

insert into fktable2 values (2);

savepoint x;

delete from fktable2;

rollback to savepoint x;

commit;

begin;

insert into fktable2 values (2);

alter table fktable2
  drop constraint fktable2_f1_fkey;

commit;

begin;

delete from pktable2 where f1 = 1;

alter table fktable2
  drop constraint fktable2_f1_fkey;

commit;

drop TABLE "pktable2", "fktable2";

create table pktable2 (
  a DOUBLE PRECISION,
  b DOUBLE PRECISION,
  primary key (a, b)
);

create table fktable2 (
  x DOUBLE PRECISION,
  y DOUBLE PRECISION,
  foreign key
  (x,
  y)
  references pktable2 (a,
  b)
  on UPDATE cascade
);

insert into pktable2 values ('-0', '-0');

insert into fktable2 values ('-0', '-0');

select * from pktable2;

select * from fktable2;

update pktable2 set a = '0' where a = '-0';

select * from pktable2;

select * from fktable2;

drop TABLE "pktable2", "fktable2";

create table fk_notpartitioned_pk (
  fdrop1 INT,
  a INT,
  fdrop2 INT,
  b INT,
  primary key (a, b)
);

alter table fk_notpartitioned_pk
  drop column fdrop1,
  drop column fdrop2;

create table fk_partitioned_fk (
  b INT,
  fdrop1 INT,
  a INT
)
partition by range(a, b);

alter table fk_partitioned_fk
  drop column fdrop1;

create table fk_partitioned_fk_1 (
  fdrop1 INT,
  fdrop2 INT,
  a INT,
  fdrop3 INT,
  b INT
);

alter table fk_partitioned_fk_1
  drop column fdrop1,
  drop column fdrop2,
  drop column fdrop3;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_1
  for values from (0, 0) to (1000, 1000);

create table fk_partitioned_fk_2 (
  b INT,
  fdrop1 INT,
  fdrop2 INT,
  a INT
);

alter table fk_partitioned_fk_2
  drop column fdrop1,
  drop column fdrop2;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2
  for values from (1000, 1000) to (2000, 2000);

create table fk_partitioned_fk_3 (
  fdrop1 INT,
  fdrop2 INT,
  fdrop3 INT,
  fdrop4 INT,
  b INT,
  a INT
)
partition by HASH(a);

alter table fk_partitioned_fk_3
  drop column fdrop1,
  drop column fdrop2,
  drop column fdrop3,
  drop column fdrop4;

create table fk_partitioned_fk_3_0
partition of fk_partitioned_fk_3
for values with (MODULUS 5, REMAINDER 0);

create table fk_partitioned_fk_3_1
partition of fk_partitioned_fk_3
for values with (MODULUS 5, REMAINDER 1);

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_3
  for values from (2000, 2000) to (3000, 3000);

alter table only fk_partitioned_fk
  add foreign key (a, b) references fk_notpartitioned_pk;

insert into fk_partitioned_fk (a, b) values (500, 501);

insert into fk_partitioned_fk_1 (a, b) values (500, 501);

insert into fk_partitioned_fk (a, b) values (1500, 1501);

insert into fk_partitioned_fk_2 (a, b) values (1500, 1501);

insert into fk_partitioned_fk (a, b) values (2500, 2502);

insert into fk_partitioned_fk_3 (a, b) values (2500, 2502);

insert into fk_partitioned_fk (a, b) values (2501, 2503);

insert into fk_partitioned_fk_3 (a, b) values (2501, 2503);

insert into fk_notpartitioned_pk values (500, 501), (1500, 1501), (2500, 2502), (2501, 2503);

insert into fk_partitioned_fk (a, b) values (500, 501);

insert into fk_partitioned_fk (a, b) values (1500, 1501);

insert into fk_partitioned_fk (a, b) values (2500, 2502);

insert into fk_partitioned_fk (a, b) values (2501, 2503);

update fk_partitioned_fk set a = a + 1 where a = 2501;

insert into fk_notpartitioned_pk (a, b) values (2502, 2503);

update fk_partitioned_fk set a = a + 1 where a = 2501;

update fk_notpartitioned_pk set b = 502 where a = 500;

update fk_notpartitioned_pk set b = 1502 where a = 1500;

update fk_notpartitioned_pk set b = 2504 where a = 2500;

select
  conname,
  cast(tgrelid as REGCLASS) as tgrel,
  regexp_replace(tgname, '[0-9]+', 'N') as tgname,
  tgtype
from
  pg_trigger as t
  inner join
    pg_constraint as c
  on t.tgconstraint = c.oid
where
  tgrelid in
  (
    select
      relid
    from
      pg_partition_tree(
        cast('fk_partitioned_fk' as REGCLASS)
      )
    union all
    select cast('fk_notpartitioned_pk' as REGCLASS)
  )
order by tgrelid,
  tgtype;

select
  conname,
  cast(tgrelid as REGCLASS) as tgrel,
  regexp_replace(tgname, '[0-9]+', 'N') as tgname,
  tgtype
from
  pg_trigger as t
  inner join
    pg_constraint as c
  on t.tgconstraint = c.oid
where
  tgrelid in
  (
    select
      relid
    from
      pg_partition_tree(
        cast('fk_partitioned_fk' as REGCLASS)
      )
    union all
    select cast('fk_notpartitioned_pk' as REGCLASS)
  )
order by tgrelid,
  tgtype;

select
  conname,
  cast(tgrelid as REGCLASS) as tgrel,
  regexp_replace(tgname, '[0-9]+', 'N') as tgname,
  tgtype
from
  pg_trigger as t
  inner join
    pg_constraint as c
  on t.tgconstraint = c.oid
where
  tgrelid in
  (
    select
      relid
    from
      pg_partition_tree(
        cast('fk_partitioned_fk' as REGCLASS)
      )
    union all
    select cast('fk_notpartitioned_pk' as REGCLASS)
  )
order by tgrelid,
  tgtype;

alter table fk_partitioned_fk
  drop constraint fk_partitioned_fk_a_b_fkey;

drop TABLE "fk_notpartitioned_pk", "fk_partitioned_fk";

create table fk_notpartitioned_pk (
  a INT,
  primary key (a),
  check (a > 0)
);

create table fk_partitioned_fk (a INT references fk_notpartitioned_pk (a) primary key)
partition by range(a);

create table fk_partitioned_fk_1
partition of fk_partitioned_fk
for values from (minvalue) to (maxvalue);

insert into fk_notpartitioned_pk values (1);

insert into fk_partitioned_fk values (1);

alter table fk_notpartitioned_pk
  alter column a type BIGINT;

delete from fk_notpartitioned_pk where a = 1;

drop TABLE "fk_notpartitioned_pk", "fk_partitioned_fk";

create table fk_notpartitioned_pk (
  a INT,
  b INT,
  primary key (a, b)
);

create table fk_partitioned_fk (
  b INT,
  a INT
)
partition by range(a, b);

alter table fk_partitioned_fk
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk
  not valid;

create table fk_partitioned_fk_1 (
  a INT,
  b INT
);

alter table fk_partitioned_fk_1
  add foreign key (a, b) references fk_notpartitioned_pk;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_1
  for values from (0, 0) to (1000, 1000);

select
  conname,
  convalidated,
  cast(conrelid as REGCLASS)
from
  pg_constraint
where
  cast(cast(conrelid as REGCLASS) as TEXT) like 'fk_partitioned_fk%'
order by cast(cast(oid as REGCLASS) as TEXT);

alter table fk_partitioned_fk
  validate constraint fk_partitioned_fk_a_b_fkey;

select
  conname,
  convalidated,
  cast(conrelid as REGCLASS)
from
  pg_constraint
where
  cast(cast(conrelid as REGCLASS) as TEXT) like 'fk_partitioned_fk%'
order by cast(cast(oid as REGCLASS) as TEXT);

create table fk_partitioned_fk_2 (
  a INT,
  b INT
);

insert into fk_partitioned_fk_2 values (1000, 1000);

alter table fk_partitioned_fk_2
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk
  not valid;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2
  for values from (1000, 1000) to (2000, 2000);

truncate fk_partitioned_fk_2;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2
  for values from (1000, 1000) to (2000, 2000);

select
  conname,
  convalidated
from
  pg_constraint
where
  conrelid = cast('fk_partitioned_fk_2' as REGCLASS)
order by cast(cast(oid as REGCLASS) as TEXT);

create table fk_partitioned_fk_3 (
  a INT,
  b INT
)
partition by range(a, b);

alter table fk_partitioned_fk_3
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk
  not valid;

create table fk_partitioned_fk_3_1 (
  a INT,
  b INT
);

alter table fk_partitioned_fk_3_1
  add foreign key (a, b) references fk_notpartitioned_pk;

alter table fk_partitioned_fk_3
  ATTACH partition
  fk_partitioned_fk_3_1
  for values from (2000, 2000) to (3000, 3000);

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_3
  for values from (2000, 2000) to (3000, 3000);

select
  conname,
  convalidated,
  cast(conrelid as REGCLASS)
from
  pg_constraint
where
  cast(cast(conrelid as REGCLASS) as TEXT) like 'fk_partitioned_fk%'
order by cast(cast(oid as REGCLASS) as TEXT);

drop TABLE "fk_partitioned_fk", "fk_notpartitioned_pk";

create table fk_partitioned_pk (
  a INT,
  b INT,
  primary key (a, b)
)
partition by range(a, b);

create table fk_partitioned_pk_1
partition of fk_partitioned_pk
for values from (0, 0) to (1000, 1000);

create table fk_partitioned_pk_2
partition of fk_partitioned_pk
for values from (1000, 1000) to (2000, 2000);

create table fk_notpartitioned_fk (
  b INT,
  a INT
);

insert into fk_partitioned_pk values (100, 100), (1000, 1000);

insert into fk_notpartitioned_fk values (100, 100), (1000, 1000);

alter table fk_notpartitioned_fk
  add constraint "fk_notpartitioned_fk_a_b_fkey"
  foreign key
  (a,
  b)
  references fk_partitioned_pk
  not valid;

select
  conname,
  conenforced,
  convalidated
from
  pg_constraint
where
  conrelid =
  cast('fk_notpartitioned_fk' as REGCLASS)
order by cast(cast(oid as REGCLASS) as TEXT);

alter table fk_notpartitioned_fk
  validate constraint fk_notpartitioned_fk_a_b_fkey;

select
  conname,
  conenforced,
  convalidated
from
  pg_constraint
where
  conrelid =
  cast('fk_notpartitioned_fk' as REGCLASS)
order by cast(cast(oid as REGCLASS) as TEXT);

alter table fk_partitioned_pk
  add constraint "selffk"
  foreign key
  (a,
  b)
  references fk_partitioned_pk
  not valid;

create table fk_partitioned_pk_3
partition of fk_partitioned_pk
for values from (2000, 2000) to (3000, 3000)
partition by range(a);

create table fk_partitioned_pk_3_1
partition of fk_partitioned_pk_3
for values from (2000) to (2100);

select
  conname,
  conenforced,
  convalidated
from
  pg_constraint
where
  conrelid = cast('fk_partitioned_pk' as REGCLASS) and
  contype = 'f'
order by cast(cast(oid as REGCLASS) as TEXT);

alter table fk_partitioned_pk_2
  validate constraint selffk;

alter table fk_partitioned_pk
  validate constraint selffk;

select
  conname,
  conenforced,
  convalidated
from
  pg_constraint
where
  conrelid = cast('fk_partitioned_pk' as REGCLASS) and
  contype = 'f'
order by cast(cast(oid as REGCLASS) as TEXT);

drop TABLE "fk_notpartitioned_fk", "fk_partitioned_pk";

create table fk_notpartitioned_pk (
  a INT,
  b INT,
  primary key (a, b)
);

create table fk_partitioned_fk (
  a INT default 2501,
  b INT default 142857
)
partition by LIST(a);

create table fk_partitioned_fk_1 partition of fk_partitioned_fk for values in (null, 500, 501, 502);

alter table fk_partitioned_fk
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk
  on DELETE set null
  on UPDATE set null;

create table fk_partitioned_fk_2 partition of fk_partitioned_fk for values in (1500, 1502);

create table fk_partitioned_fk_3 (
  a INT,
  b INT
);

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_3
  for values in (2500, 2501, 2502, 2503);

insert into fk_partitioned_fk (a, b) values (2502, 2503);

insert into fk_partitioned_fk_3 (a, b) values (2502, 2503);

insert into fk_partitioned_fk_3 (a, b) values (2502, null);

insert into fk_notpartitioned_pk values (2502, 2503);

insert into fk_partitioned_fk_3 (a, b) values (2502, 2503);

insert into fk_partitioned_fk (a, b) values (null, null);

insert into fk_notpartitioned_pk values (1, 2);

create table fk_partitioned_fk_full (
  x INT,
  y INT
)
partition by range(x);

create table fk_partitioned_fk_full_1 partition of fk_partitioned_fk_full default;

insert into fk_partitioned_fk_full values (1, null);

alter table fk_partitioned_fk_full
  add foreign key
  (x,
  y)
  references fk_notpartitioned_pk
  match full;

truncate fk_partitioned_fk_full;

alter table fk_partitioned_fk_full
  add foreign key
  (x,
  y)
  references fk_notpartitioned_pk
  match full;

insert into fk_partitioned_fk_full values (1, null);

drop TABLE "fk_partitioned_fk_full";

select cast(tableoid as REGCLASS), a, b from fk_partitioned_fk where b is null order by a;

update fk_notpartitioned_pk set a = a + 1 where a = 2502;

select cast(tableoid as REGCLASS), a, b from fk_partitioned_fk where b is null order by a;

insert into fk_partitioned_fk values (2503, 2503);

select COUNT(*) from fk_partitioned_fk where a is null;

delete from fk_notpartitioned_pk;

select COUNT(*) from fk_partitioned_fk where a is null;

alter table fk_partitioned_fk
  drop constraint fk_partitioned_fk_a_b_fkey;

alter table fk_partitioned_fk
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk
  on DELETE set default
  on UPDATE set default;

insert into fk_notpartitioned_pk values (2502, 2503);

insert into fk_partitioned_fk_3 (a, b) values (2502, 2503);

update fk_notpartitioned_pk set a = 1500 where a = 2502;

insert into fk_notpartitioned_pk values (2501, 142857);

update fk_notpartitioned_pk set a = 1500 where a = 2502;

select * from fk_partitioned_fk where b = 142857;

alter table fk_partitioned_fk
  drop constraint fk_partitioned_fk_a_b_fkey;

alter table fk_partitioned_fk
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk
  on DELETE set null (a);

begin;

delete from fk_notpartitioned_pk where b = 142857;

select * from fk_partitioned_fk where a is not null or b is not null order by a nulls last;

rollback;

alter table fk_partitioned_fk
  drop constraint fk_partitioned_fk_a_b_fkey;

alter table fk_partitioned_fk
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk
  on DELETE set default (a);

begin;

delete from fk_partitioned_fk;

delete from fk_notpartitioned_pk;

insert into fk_notpartitioned_pk values (500, 100000), (2501, 100000);

insert into fk_partitioned_fk values (500, 100000);

delete from fk_notpartitioned_pk where a = 500;

select * from fk_partitioned_fk order by a;

rollback;

alter table fk_partitioned_fk
  drop constraint fk_partitioned_fk_a_b_fkey;

alter table fk_partitioned_fk
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk
  on DELETE cascade
  on UPDATE cascade;

update fk_notpartitioned_pk set a = 2502 where a = 2501;

select * from fk_partitioned_fk where b = 142857;

select * from fk_partitioned_fk where b = 142857;

delete from fk_notpartitioned_pk where b = 142857;

select * from fk_partitioned_fk where a = 142857;

drop TABLE "fk_partitioned_fk_2";

create table fk_partitioned_fk_2 partition of fk_partitioned_fk for values in (1500, 1502);

alter table fk_partitioned_fk
  DETACH partition
  fk_partitioned_fk_2;

begin;

drop TABLE "fk_partitioned_fk";

rollback;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2 for values in (1500, 1502);

drop TABLE "fk_partitioned_fk_2";

create table fk_partitioned_fk_2 (
  b INT,
  c TEXT,
  a INT,
  foreign key
  (a,
  b)
  references fk_notpartitioned_pk
  on DELETE cascade
  on UPDATE cascade
);

alter table fk_partitioned_fk_2
  drop column c;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2 for values in (1500, 1502);

drop TABLE "fk_partitioned_fk_2";

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2 for values in (1500, 1502);

begin;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2 for values in (1500, 1502);

rollback;

begin;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2 for values in (1500, 1502);

rollback;

drop TABLE "fk_partitioned_fk_2";

create table fk_partitioned_fk_4 (
  a INT,
  b INT,
  foreign key
  (a,
  b)
  references fk_notpartitioned_pk (a,
  b)
  on DELETE cascade
  on UPDATE cascade
)
partition by range(b, a);

create table fk_partitioned_fk_4_1
partition of fk_partitioned_fk_4
for values from (1, 1) to (100, 100);

create table fk_partitioned_fk_4_2 (
  a INT,
  b INT,
  foreign key
  (a,
  b)
  references fk_notpartitioned_pk (a,
  b)
  on UPDATE set null
);

alter table fk_partitioned_fk_4
  ATTACH partition
  fk_partitioned_fk_4_2
  for values from (100, 100) to (1000, 1000);

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_4 for values in (3500, 3502);

alter table fk_partitioned_fk
  DETACH partition
  fk_partitioned_fk_4;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_4 for values in (3500, 3502);

create table fk_partitioned_fk_5 (
  a INT,
  b INT,
  foreign key
  (a,
  b)
  references fk_notpartitioned_pk (a,
  b)
  on DELETE cascade
  on UPDATE cascade
  deferrable initially immediate,
  foreign key
  (a,
  b)
  references fk_notpartitioned_pk (a,
  b)
  match full
  on DELETE cascade
  on UPDATE cascade
)
partition by range(a);

create table fk_partitioned_fk_5_1 (
  a INT,
  b INT,
  foreign key (a, b) references fk_notpartitioned_pk
);

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_5 for values in (4500);

alter table fk_partitioned_fk_5
  ATTACH partition
  fk_partitioned_fk_5_1 for values from (0) to (10);

alter table fk_partitioned_fk
  DETACH partition
  fk_partitioned_fk_5;

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_5 for values in (4500);

alter table fk_partitioned_fk_5
  DETACH partition
  fk_partitioned_fk_5_1;

alter table fk_partitioned_fk_5
  ATTACH partition
  fk_partitioned_fk_5_1 for values from (0) to (10);

create table fk_partitioned_fk_2 (
  a INT,
  b INT
)
partition by range(b);

create table fk_partitioned_fk_2_1 partition of fk_partitioned_fk_2 for values from (0) to (1000);

create table fk_partitioned_fk_2_2
partition of fk_partitioned_fk_2
for values from (1000) to (2000);

insert into fk_partitioned_fk_2 values (1600, 601), (1600, 1601);

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2 for values in (1600);

insert into fk_notpartitioned_pk values (1600, 601), (1600, 1601);

alter table fk_partitioned_fk
  ATTACH partition
  fk_partitioned_fk_2 for values in (1600);

create table fk_partitioned_pk_6 (a INT primary key);

create table fk_partitioned_fk_6 (a INT references fk_partitioned_pk_6)
partition by LIST(a);

alter table fk_partitioned_fk_6
  ATTACH partition
  fk_partitioned_pk_6 for values in (1);

drop TABLE "fk_partitioned_pk_6", "fk_partitioned_fk_6";

create table fk_partitioned_pk_6 (a INT primary key);

create table fk_partitioned_fk_6 (
  a INT,
  foreign key (a) references fk_partitioned_pk_6,
  foreign key (a) references fk_partitioned_pk_6
)
partition by LIST(a);

create table fk_partitioned_fk_6_1 partition of fk_partitioned_fk_6 for values in (1);

alter table fk_partitioned_fk_6
  DETACH partition
  fk_partitioned_fk_6_1;

alter table fk_partitioned_fk_6
  ATTACH partition
  fk_partitioned_fk_6_1 for values in (1);

drop TABLE "fk_partitioned_pk_6", "fk_partitioned_fk_6";

create table fk_partitioned_pk_6 (a INT primary key)
partition by LIST(a);

create table fk_partitioned_pk_61 partition of fk_partitioned_pk_6 for values in (1);

create table fk_partitioned_fk_6 (a INT references fk_partitioned_pk_61)
partition by LIST(a);

alter table fk_partitioned_fk_6
  ATTACH partition
  fk_partitioned_pk_6 for values in (1);

drop TABLE "fk_partitioned_pk_6", "fk_partitioned_fk_6";

create role regress_other_partitioned_fk_owner;

grant REFERENCES on table fk_notpartitioned_pk to regress_other_partitioned_fk_owner;

set role to regress_other_partitioned_fk_owner;

create table other_partitioned_fk (
  a INT,
  b INT
)
partition by LIST(a);

create table other_partitioned_fk_1 partition of other_partitioned_fk for values in (2048);

insert into other_partitioned_fk select 2048, x from generate_series(1, 10) as x;

alter table other_partitioned_fk
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk (a,
  b);

reset role;

insert into fk_notpartitioned_pk (a, b) select 2048, x from generate_series(1, 10) as x;

set role to regress_other_partitioned_fk_owner;

alter table other_partitioned_fk
  add foreign key
  (a,
  b)
  references fk_notpartitioned_pk (a,
  b);

drop TABLE "other_partitioned_fk";

reset role;

revoke all on table fk_notpartitioned_pk from regress_other_partitioned_fk_owner;

drop role regress_other_partitioned_fk_owner;

create table parted_self_fk (
  id BIGINT not null primary key,
  id_abc BIGINT,
  foreign key
  (id_abc)
  references parted_self_fk (id)
)
partition by range(id);

create table part1_self_fk (
  id BIGINT not null primary key,
  id_abc BIGINT
);

alter table parted_self_fk
  ATTACH partition
  part1_self_fk for values from (0) to (10);

create table part2_self_fk partition of parted_self_fk for values from (10) to (20);

create table part3_self_fk (
  id BIGINT not null primary key,
  id_abc BIGINT
)
partition by range(id);

create table part32_self_fk partition of part3_self_fk for values from (20) to (30);

alter table parted_self_fk
  ATTACH partition
  part3_self_fk for values from (20) to (40);

create table part33_self_fk (
  id BIGINT not null primary key,
  id_abc BIGINT
);

alter table part3_self_fk
  ATTACH partition
  part33_self_fk for values from (30) to (40);

insert into parted_self_fk values (1, null), (2, null), (3, null);

insert into parted_self_fk values (10, 1), (11, 2), (12, 3) returning cast(tableoid as REGCLASS);

insert into parted_self_fk values (4, 5);

delete from parted_self_fk where id = 1 returning *;

select
  cr.relname,
  co.conname,
  co.convalidated,
  p.conname as conparent,
  p.convalidated,
  cf.relname as foreignrel
from
  pg_constraint as co
  inner join
    pg_class as cr
  on cr.oid = co.conrelid
  left outer join
    pg_class as cf
  on cf.oid = co.confrelid
  left outer join
    pg_constraint as p
  on p.oid = co.conparentid
where
  co.contype = 'f' and
  cr.oid in
  (
    select
      relid
    from
      pg_partition_tree('parted_self_fk')
  )
order by cr.relname,
  co.conname,
  p.conname;

alter table parted_self_fk
  DETACH partition
  part2_self_fk;

insert into part2_self_fk values (16, 9);

delete from parted_self_fk where id = 2 returning *;

alter table parted_self_fk
  ATTACH partition
  part2_self_fk for values from (10) to (20);

insert into parted_self_fk values (16, 9);

delete from parted_self_fk where id = 3 returning *;

alter table parted_self_fk
  DETACH partition
  part2_self_fk;

alter table parted_self_fk
  ATTACH partition
  part2_self_fk for values from (10) to (20);

alter table parted_self_fk
  DETACH partition
  part3_self_fk;

alter table parted_self_fk
  ATTACH partition
  part3_self_fk for values from (30) to (40);

alter table part3_self_fk
  DETACH partition
  part33_self_fk;

alter table part3_self_fk
  ATTACH partition
  part33_self_fk for values from (30) to (40);

select
  cr.relname,
  co.conname,
  co.convalidated,
  p.conname as conparent,
  p.convalidated,
  cf.relname as foreignrel
from
  pg_constraint as co
  inner join
    pg_class as cr
  on cr.oid = co.conrelid
  left outer join
    pg_class as cf
  on cf.oid = co.confrelid
  left outer join
    pg_constraint as p
  on p.oid = co.conparentid
where
  co.contype = 'f' and
  cr.oid in
  (
    select
      relid
    from
      pg_partition_tree('parted_self_fk')
  )
order by cr.relname,
  co.conname,
  p.conname;

create schema "fkpart0";

create table pkey (a INT primary key);

create table fk_part (a INT)
partition by LIST(a);

create table fk_part_1
partition of fk_part
(
  foreign key (a) references fkpart0.pkey
)
for values in (1);

create table fk_part_23
partition of fk_part
(
  foreign key (a) references fkpart0.pkey
)
for values in (2, 3)
partition by LIST(a);

create table fk_part_23_2 partition of fk_part_23 for values in (2);

alter table fkpart0.fk_part
  add foreign key (a) references fkpart0.pkey;

alter table fkpart0.fk_part_1
  drop constraint fk_part_1_a_fkey;

alter table fkpart0.fk_part_23
  drop constraint fk_part_23_a_fkey;

alter table fkpart0.fk_part_23_2
  drop constraint fk_part_23_a_fkey;

create table fkpart0.fk_part_4 partition of fkpart0.fk_part for values in (4);

alter table fkpart0.fk_part_4
  drop constraint fk_part_a_fkey;

create table fkpart0.fk_part_56
partition of fkpart0.fk_part
for values in (5, 6)
partition by LIST(a);

create table fkpart0.fk_part_56_5 partition of fkpart0.fk_part_56 for values in (5);

alter table fkpart0.fk_part_56
  drop constraint fk_part_a_fkey;

alter table fkpart0.fk_part_56_5
  drop constraint fk_part_a_fkey;

create schema "fkpart1";

create table pkey (a INT primary key);

create table fk_part (a INT)
partition by LIST(a);

create table fk_part_1 partition of fk_part for values in (1) partition by LIST(a);

create table fk_part_1_1 partition of fk_part_1 for values in (1);

alter table fkpart1.fk_part
  add foreign key (a) references fkpart1.pkey;

insert into fkpart1.fk_part values (1);

insert into fkpart1.pkey values (1);

insert into fkpart1.fk_part values (1);

delete from fkpart1.pkey where a = 1;

alter table fkpart1.fk_part
  DETACH partition
  fkpart1.fk_part_1;

create table fkpart1.fk_part_1_2 partition of fkpart1.fk_part_1 for values in (2);

insert into fkpart1.fk_part_1 values (2);

delete from fkpart1.pkey where a = 1;

create schema "fkpart2";

create table pkey (a INT primary key);

create table fk_part (
  a INT,
  constraint "fkey"
  foreign key
  (a)
  references fkpart2.pkey
)
partition by LIST(a);

create table fk_part_1 partition of fkpart2.fk_part for values in (1) partition by LIST(a);

create table fk_part_1_1 (
  a INT,
  constraint "my_fkey"
  foreign key
  (a)
  references fkpart2.pkey
);

alter table fkpart2.fk_part_1
  ATTACH partition
  fkpart2.fk_part_1_1 for values in (1);

alter table fkpart2.fk_part_1
  drop constraint fkey;

alter table fkpart2.fk_part_1_1
  drop constraint my_fkey;

alter table fkpart2.fk_part
  DETACH partition
  fkpart2.fk_part_1;

alter table fkpart2.fk_part_1
  drop constraint fkey;

alter table fkpart2.fk_part_1_1
  drop constraint my_fkey;

create schema "fkpart3";

create table pkey (a INT primary key);

create table fk_part (
  a INT,
  constraint "fkey"
  foreign key
  (a)
  references fkpart3.pkey
  deferrable initially immediate
)
partition by LIST(a);

create table fk_part_1 partition of fkpart3.fk_part for values in (1) partition by LIST(a);

create table fk_part_1_1 partition of fkpart3.fk_part_1 for values in (1);

create table fk_part_2 partition of fkpart3.fk_part for values in (2);

begin;

set CONSTRAINTS fkpart3.fkey DEFERRED;

insert into fkpart3.fk_part values (1);

insert into fkpart3.pkey values (1);

commit;

begin;

set CONSTRAINTS fkpart3.fkey DEFERRED;

delete from fkpart3.pkey;

delete from fkpart3.fk_part;

commit;

drop SCHEMA fkpart0, fkpart1, fkpart2, fkpart3 cascade;

create schema "fkpart3";

set search_path to fkpart3;

create table pk (a INT primary key)
partition by range(a);

create table pk1 partition of pk for values from (0) to (1000);

create table pk2 (
  b INT,
  a INT
);

alter table pk2
  drop column b;

alter table pk2
  alter column a set not null;

alter table pk
  ATTACH partition
  pk2 for values from (1000) to (2000);

create table fk (a INT)
partition by range(a);

create table fk1 partition of fk for values from (0) to (750);

alter table fk
  add foreign key (a) references pk;

create table fk2 (
  b INT,
  a INT
);

alter table fk2
  drop column b;

alter table fk
  ATTACH partition
  fk2 for values from (750) to (3500);

create table pk3 partition of pk for values from (2000) to (3000);

create table pk4 (like pk);

alter table pk
  ATTACH partition
  pk4 for values from (3000) to (4000);

create table pk5 (
  c INT,
  b INT,
  a INT not null
)
partition by range(a);

alter table pk5
  drop column b,
  drop column c;

create table pk51 partition of pk5 for values from (4000) to (4500);

create table pk52 partition of pk5 for values from (4500) to (5000);

alter table pk
  ATTACH partition
  pk5 for values from (4000) to (5000);

create table fk3 partition of fk for values from (3500) to (5000);

insert into fk values (1);

insert into fk values (1000);

insert into fk values (2000);

insert into fk values (3000);

insert into fk values (4000);

insert into fk values (4500);

insert into pk values (1), (1000), (2000), (3000), (4000), (4500);

insert into fk values (1), (1000), (2000), (3000), (4000), (4500);

delete from pk where a = 1;

delete from pk where a = 1000;

delete from pk where a = 2000;

delete from pk where a = 3000;

delete from pk where a = 4000;

delete from pk where a = 4500;

update pk set a = 2 where a = 1;

update pk set a = 1002 where a = 1000;

update pk set a = 2002 where a = 2000;

update pk set a = 3002 where a = 3000;

update pk set a = 4002 where a = 4000;

update pk set a = 4502 where a = 4500;

delete from fk;

update pk set a = 2 where a = 1;

delete from pk where a = 2;

update pk set a = 1002 where a = 1000;

delete from pk where a = 1002;

update pk set a = 2002 where a = 2000;

delete from pk where a = 2002;

update pk set a = 3002 where a = 3000;

delete from pk where a = 3002;

update pk set a = 4002 where a = 4000;

delete from pk where a = 4002;

update pk set a = 4502 where a = 4500;

delete from pk where a = 4502;

create table ffk (
  a INT,
  b INT references pk
)
partition by LIST(a);

create table ffk1 partition of ffk for values in (1);

alter table ffk1
  add foreign key (a) references pk;

alter table ffk
  DETACH partition
  ffk1;

drop TABLE "ffk", "ffk1";

create schema "fkpart4";

set search_path to fkpart4;

create table droppk (a INT primary key)
partition by range(a);

create table droppk1 partition of droppk for values from (0) to (1000);

create table droppk_d partition of droppk default;

create table droppk2 partition of droppk for values from (1000) to (2000) partition by range(a);

create table droppk21 partition of droppk2 for values from (1000) to (1400);

create table droppk2_d partition of droppk2 default;

insert into droppk values (1), (1000), (1500), (2000);

create table dropfk (a INT references droppk);

insert into dropfk values (1), (1000), (1500), (2000);

alter table droppk
  DETACH partition
  droppk_d;

alter table droppk2
  DETACH partition
  droppk2_d;

alter table droppk
  DETACH partition
  droppk1;

alter table droppk
  DETACH partition
  droppk2;

alter table droppk2
  DETACH partition
  droppk21;

drop TABLE "droppk_d";

drop TABLE "droppk2_d";

drop TABLE "droppk1";

drop TABLE "droppk2";

drop TABLE "droppk21";

delete from dropfk;

drop TABLE "droppk_d";

drop TABLE "droppk2_d";

drop TABLE "droppk1";

alter table droppk2
  DETACH partition
  droppk21;

drop TABLE "droppk2";

create schema "fkpart5";

set search_path to fkpart5;

create table pk (a INT primary key)
partition by LIST(a);

create table pk1 partition of pk for values in (1) partition by LIST(a);

create table pk11 partition of pk1 for values in (1);

create table fk (a INT)
partition by LIST(a);

create table fk1 partition of fk for values in (1) partition by LIST(a);

create table fk11 partition of fk1 for values in (1);

alter table fk
  add foreign key (a) references pk;

create table pk2 partition of pk for values in (2);

create table pk3 (a INT not null)
partition by LIST(a);

create table pk31 partition of pk3 for values in (31);

create table pk32 (
  b INT,
  a INT not null
);

alter table pk32
  drop column b;

alter table pk3
  ATTACH partition
  pk32 for values in (32);

alter table pk
  ATTACH partition
  pk3 for values in (31, 32);

create table fk2 partition of fk for values in (2);

create table fk3 (
  b INT,
  a INT
);

alter table fk3
  drop column b;

alter table fk
  ATTACH partition
  fk3 for values in (3);

select
  pg_describe_object(
    cast('pg_constraint' as REGCLASS),
    oid,
    0
  ),
  cast(confrelid as REGCLASS),
  case
    when conparentid <> 0
    then pg_describe_object(
      cast('pg_constraint' as REGCLASS),
      conparentid,
      0
    )
    else 'TOP'
  end
from
  pg_catalog.pg_constraint
where
  conrelid in
  (
    select relid from pg_partition_tree('fk')
  )
order by cast(cast(conrelid as REGCLASS) as TEXT),
  conname;

create table fk4 (like fk);

insert into fk4 values (50);

alter table fk
  ATTACH partition
  fk4 for values in (50);

create schema "fkpart9";

set search_path to fkpart9;

create table pk (a INT primary key)
partition by LIST(a);

create table pk1 partition of pk for values in (1, 2) partition by LIST(a);

create table pk11 partition of pk1 for values in (1);

create table pk3 partition of pk for values in (3);

create table fk (a INT references pk deferrable initially immediate);

insert into fk values (1);

begin;

set CONSTRAINTS fk_a_fkey DEFERRED;

insert into fk values (1);

commit;

begin;

set CONSTRAINTS fk_a_fkey DEFERRED;

insert into fk values (1);

insert into pk values (1);

commit;

begin;

set CONSTRAINTS fk_a_fkey DEFERRED;

delete from pk where a = 1;

delete from fk where a = 1;

commit;

create table pt (
  f1 INT,
  f2 INT,
  f3 INT,
  primary key (f1, f2)
);

create table ref (
  f1 INT,
  f2 INT,
  f3 INT
)
partition by LIST(f1);

create table ref1 partition of ref for values in (1);

create table ref2 partition of ref for values in (2);

alter table ref
  add foreign key (f1, f2) references pt;

alter table ref
  alter constraint "ref_f1_f2_fkey" deferrable initially deferred;

insert into pt values (1, 2, 3);

insert into ref values (1, 2, 3);

begin;

delete from pt;

delete from ref;

rollback;

drop TABLE "pt", "ref";

create table pt (
  f1 INT,
  f2 INT,
  f3 INT,
  primary key (f1, f2)
);

create table ref (
  f1 INT,
  f2 INT,
  f3 INT
)
partition by LIST(f1);

create table ref1_2 partition of ref for values in (1, 2) partition by LIST(f2);

create table ref1 partition of ref1_2 for values in (1);

create table ref2 partition of ref1_2 for values in (2) partition by LIST(f2);

create table ref22 partition of ref2 for values in (2);

alter table ref
  add foreign key (f1, f2) references pt;

insert into pt values (1, 2, 3);

insert into ref values (1, 2, 3);

alter table ref22
  alter constraint "ref_f1_f2_fkey" deferrable initially immediate;

alter table ref
  alter constraint "ref_f1_f2_fkey" deferrable initially deferred;

begin;

delete from pt;

delete from ref;

rollback;

drop TABLE "pt", "ref";

create table pt (
  f1 INT,
  f2 INT,
  f3 INT,
  primary key (f1, f2)
)
partition by LIST(f1);

create table pt1 partition of pt for values in (1);

create table pt2 partition of pt for values in (2);

create table ref (
  f1 INT,
  f2 INT,
  f3 INT
);

alter table ref
  add foreign key (f1, f2) references pt;

alter table ref
  alter constraint "ref_f1_f2_fkey" deferrable initially deferred;

insert into pt values (1, 2, 3);

insert into ref values (1, 2, 3);

begin;

delete from pt;

delete from ref;

rollback;

drop TABLE "pt", "ref";

create table pt (
  f1 INT,
  f2 INT,
  f3 INT,
  primary key (f1, f2)
)
partition by LIST(f1);

create table pt1_2 partition of pt for values in (1, 2) partition by LIST(f1);

create table pt1 partition of pt1_2 for values in (1);

create table pt2 partition of pt1_2 for values in (2);

create table ref (
  f1 INT,
  f2 INT,
  f3 INT
);

alter table ref
  add foreign key (f1, f2) references pt;

alter table ref
  alter constraint "ref_f1_f2_fkey_1" deferrable initially deferred;

alter table ref
  alter constraint "ref_f1_f2_fkey" deferrable initially deferred;

insert into pt values (1, 2, 3);

insert into ref values (1, 2, 3);

begin;

delete from pt;

delete from ref;

rollback;

drop TABLE "pt", "ref";

drop SCHEMA fkpart9 cascade;

create schema "fkpart6";

set search_path to fkpart6;

create table pk (a INT primary key)
partition by range(a);

create table pk1 partition of pk for values from (1) to (100) partition by range(a);

create table pk11 partition of pk1 for values from (1) to (50);

create table pk12 partition of pk1 for values from (50) to (100);

create table fk (a INT)
partition by range(a);

create table fk1 partition of fk for values from (1) to (100) partition by range(a);

create table fk11 partition of fk1 for values from (1) to (10);

create table fk12 partition of fk1 for values from (10) to (100);

alter table fk
  add foreign key
  (a)
  references pk
  on DELETE cascade
  on UPDATE cascade;

create table fk_d partition of fk default;

insert into pk values (1);

insert into fk values (1);

update pk set a = 20;

select cast(tableoid as REGCLASS), * from fk;

delete from pk where a = 20;

select cast(tableoid as REGCLASS), * from fk;

drop TABLE "fk";

truncate pk;

insert into pk values (20), (50);

create table fk (a INT)
partition by range(a);

create table fk1 partition of fk for values from (1) to (100) partition by range(a);

create table fk11 partition of fk1 for values from (1) to (10);

create table fk12 partition of fk1 for values from (10) to (100);

alter table fk
  add foreign key
  (a)
  references pk
  on DELETE set null
  on UPDATE set null;

create table fk_d partition of fk default;

insert into fk values (20), (50);

update pk set a = 21 where a = 20;

delete from pk where a = 50;

select cast(tableoid as REGCLASS), * from fk;

drop TABLE "fk";

truncate pk;

insert into pk values (20), (30), (50);

create table fk (
  id INT,
  a INT default 50
)
partition by range(a);

create table fk1 partition of fk for values from (1) to (100) partition by range(a);

create table fk11 partition of fk1 for values from (1) to (10);

create table fk12 partition of fk1 for values from (10) to (100);

alter table fk
  add foreign key
  (a)
  references pk
  on DELETE set default
  on UPDATE set default;

create table fk_d partition of fk default;

insert into fk values (1, 20), (2, 30);

delete from pk where a = 20 returning *;

update pk set a = 90 where a = 30 returning *;

select cast(tableoid as REGCLASS), * from fk;

drop TABLE "fk";

truncate pk;

insert into pk values (20), (30);

create table fk (a INT default 50)
partition by range(a);

create table fk1 partition of fk for values from (1) to (100) partition by range(a);

create table fk11 partition of fk1 for values from (1) to (10);

create table fk12 partition of fk1 for values from (10) to (100);

alter table fk
  add foreign key
  (a)
  references pk
  on DELETE restrict
  on UPDATE restrict;

create table fk_d partition of fk default;

insert into fk values (20), (30);

delete from pk where a = 20;

update pk set a = 90 where a = 30;

select cast(tableoid as REGCLASS), * from fk;

drop TABLE "fk";

create schema "fkpart7";

create table pkpart (a INT)
partition by LIST(a);

create table pkpart1 partition of pkpart for values in (1);

alter table fkpart7.pkpart1
  add primary key (a);

alter table fkpart7.pkpart
  add primary key (a);

create table fkpart7.fk (a INT references fkpart7.pkpart);

drop SCHEMA fkpart7 cascade;

create schema "fkpart8";

create table tbl1 (f1 INT primary key);

create table tbl2 (f1 INT references tbl1 deferrable initially deferred)
partition by range(f1);

create table tbl2_p1 partition of tbl2 for values from (minvalue) to (maxvalue);

insert into fkpart8.tbl1 values (1);

begin;

insert into fkpart8.tbl2 values (1);

alter table fkpart8.tbl2
  drop constraint tbl2_f1_fkey;

commit;

drop SCHEMA fkpart8 cascade;

create schema "fkpart9";

create table pk (a INT primary key)
partition by range(a);

create table fk (fk_a INT references pk (a) on DELETE cascade);

create table pk1 partition of pk for values from (30) to (50) partition by range(a);

create table pk11 partition of pk1 for values from (30) to (40);

insert into fkpart9.pk values (35);

insert into fkpart9.fk values (35);

delete from fkpart9.pk where a = 35;

select * from fkpart9.pk;

select * from fkpart9.fk;

drop SCHEMA fkpart9 cascade;

create schema "fkpart10";

create table tbl1 (f1 INT primary key)
partition by range(f1);

create table tbl1_p1 partition of tbl1 for values from (minvalue) to (1);

create table tbl1_p2 partition of tbl1 for values from (1) to (maxvalue);

create table tbl2 (f1 INT references tbl1 deferrable initially deferred);

create table tbl3 (f1 INT primary key)
partition by range(f1);

create table tbl3_p1 partition of tbl3 for values from (minvalue) to (1);

create table tbl3_p2 partition of tbl3 for values from (1) to (maxvalue);

create table tbl4 (f1 INT references tbl3 deferrable initially deferred);

insert into fkpart10.tbl1 values (0), (1);

insert into fkpart10.tbl2 values (0), (1);

insert into fkpart10.tbl3 values (-2), (-1), (0);

insert into fkpart10.tbl4 values (-2), (-1);

begin;

delete from fkpart10.tbl1 where f1 = 0;

update fkpart10.tbl1 set f1 = 2 where f1 = 1;

insert into fkpart10.tbl1 values (0), (1);

commit;

begin;

update fkpart10.tbl1 set f1 = 3 where f1 = 0;

update fkpart10.tbl3 set f1 = f1 * -1;

insert into fkpart10.tbl1 values (4);

commit;

begin;

update fkpart10.tbl3 set f1 = f1 * -1;

update fkpart10.tbl3 set f1 = f1 + 3;

update fkpart10.tbl1 set f1 = 3 where f1 = 0;

insert into fkpart10.tbl1 values (0);

commit;

begin;

update fkpart10.tbl3 set f1 = f1 * -1;

update fkpart10.tbl1 set f1 = 3 where f1 = 0;

insert into fkpart10.tbl1 values (0);

insert into fkpart10.tbl3 values (-2), (-1);

commit;

create table fkpart10.tbl5 (f1 INT references fkpart10.tbl3);

insert into fkpart10.tbl5 values (-2), (-1);

begin;

update fkpart10.tbl3 set f1 = f1 * -3;

commit;

delete from fkpart10.tbl5;

insert into fkpart10.tbl5 values (0);

begin;

update fkpart10.tbl3 set f1 = f1 * -3;

commit;

drop SCHEMA fkpart10 cascade;

create schema "fkpart11";

create table pk (
  a INT primary key,
  b TEXT
)
partition by LIST(a);

create table fk (
  a INT,
  constraint "fkey"
  foreign key
  (a)
  references pk (a)
  on DELETE cascade
  on UPDATE cascade
);

create table fk_parted (
  a INT primary key,
  constraint "fkey"
  foreign key
  (a)
  references pk (a)
  on DELETE cascade
  on UPDATE cascade
)
partition by LIST(a);

create table fk_another (
  a INT,
  constraint "fkey"
  foreign key
  (a)
  references fk_parted (a)
  on DELETE cascade
  on UPDATE cascade
);

create table pk1 partition of pk for values in (1, 2) partition by LIST(a);

create table pk2 partition of pk for values in (3);

create table pk3 partition of pk for values in (4);

create table fk1 partition of fk_parted for values in (1, 2);

create table fk2 partition of fk_parted for values in (3);

create table fk3 partition of fk_parted for values in (4);

create table fkpart11.pk11 (
  b TEXT,
  a INT not null
);

alter table fkpart11.pk1
  ATTACH partition
  fkpart11.pk11 for values in (1);

create table fkpart11.pk12 (
  b TEXT,
  c INT,
  a INT not null
);

alter table fkpart11.pk12
  drop column c;

alter table fkpart11.pk1
  ATTACH partition
  fkpart11.pk12 for values in (2);

insert into fkpart11.pk values (1, 'xxx'), (3, 'yyy');

insert into fkpart11.fk values (1), (3);

insert into fkpart11.fk_parted values (1), (3);

insert into fkpart11.fk_another values (1), (3);

update fkpart11.pk set a = a + 1 returning cast(tableoid as REGCLASS), *;

select cast(tableoid as REGCLASS), * from fkpart11.fk;

select cast(tableoid as REGCLASS), * from fkpart11.fk_parted;

select cast(tableoid as REGCLASS), * from fkpart11.fk_another;

alter table fkpart11.fk
  drop constraint fkey;

delete from fkpart11.fk where a = 4;

alter table fkpart11.fk
  add constraint "fkey"
  foreign key
  (a)
  references fkpart11.pk1 (a)
  on DELETE cascade
  on UPDATE cascade;

update fkpart11.pk set a = a - 1;

update fkpart11.pk1 set a = a - 1;

select cast(tableoid as REGCLASS), * from fkpart11.pk;

select cast(tableoid as REGCLASS), * from fkpart11.fk;

select cast(tableoid as REGCLASS), * from fkpart11.fk_parted;

select cast(tableoid as REGCLASS), * from fkpart11.fk_another;

alter table fkpart11.fk
  drop constraint fkey;

alter table fkpart11.fk
  add constraint "fkey"
  foreign key
  (a)
  references fkpart11.pk11 (a)
  on DELETE cascade
  on UPDATE cascade;

update fkpart11.pk set a = a + 1 where a = 1;

select cast(tableoid as REGCLASS), * from fkpart11.fk;

drop TABLE "fkpart11"."fk";

create function fkpart11.print_row()
returns trigger
language "plpgsql"
as '
  BEGIN
    RAISE NOTICE ''TABLE: %, OP: %, OLD: %, NEW: %'', TG_RELNAME, TG_OP, OLD, NEW;
    RETURN NULL;
  END;
';

create TRIGGER trig_upd_pk
  after update
  on fkpart11.pk
  for EACH ROW
  EXECUTE FUNCTION fkpart11.print_row();

create TRIGGER trig_del_pk
  after delete
  on fkpart11.pk
  for EACH ROW
  EXECUTE FUNCTION fkpart11.print_row();

create TRIGGER trig_ins_pk
  after insert
  on fkpart11.pk
  for EACH ROW
  EXECUTE FUNCTION fkpart11.print_row();

create CONSTRAINT TRIGGER trig_upd_fk_parted
  after update
  on fkpart11.fk_parted
  DEFERRABLE
  INITIALLY DEFERRED
  for EACH ROW
  EXECUTE FUNCTION fkpart11.print_row();

create CONSTRAINT TRIGGER trig_del_fk_parted
  after delete
  on fkpart11.fk_parted
  DEFERRABLE
  INITIALLY DEFERRED
  for EACH ROW
  EXECUTE FUNCTION fkpart11.print_row();

create CONSTRAINT TRIGGER trig_ins_fk_parted
  after insert
  on fkpart11.fk_parted
  DEFERRABLE
  INITIALLY DEFERRED
  for EACH ROW
  EXECUTE FUNCTION fkpart11.print_row();

update fkpart11.pk set a = 3 where a = 4;

update fkpart11.pk set a = 1 where a = 2;

drop SCHEMA fkpart11 cascade;

create schema "fkpart12";

create table fk_p (
  id INT,
  jd INT,
  primary key (id, jd)
)
partition by LIST(id);

create table fk_p_1 partition of fk_p for values in (1) partition by LIST(jd);

create table fk_p_1_1 partition of fk_p_1 for values in (1);

create table fk_p_1_2 (
  x INT,
  y INT,
  jd INT not null,
  id INT not null
);

create table fk_p_2 partition of fk_p for values in (2) partition by LIST(jd);

create table fk_p_2_1 partition of fk_p_2 for values in (1);

create table fk_p_2_2 partition of fk_p_2 for values in (2);

create table fk_r_1 (
  p_jd INT not null,
  x INT,
  id INT primary key,
  p_id INT not null
);

create table fk_r_2 (
  id INT primary key,
  p_id INT not null,
  p_jd INT not null
)
partition by LIST(id);

create table fk_r_2_1 partition of fk_r_2 for values in (2, 1);

create table fk_r (
  id INT primary key,
  p_id INT not null,
  p_jd INT not null,
  foreign key (p_id, p_jd) references fk_p (id, jd)
)
partition by LIST(id);

set search_path to fkpart12;

alter table fk_p_1_2
  drop column x,
  drop column y;

alter table fk_p_1
  ATTACH partition
  fk_p_1_2 for values in (2);

alter table fk_r_1
  drop column x;

insert into fk_p values (1, 1);

alter table fk_r
  ATTACH partition
  fk_r_1 for values in (1);

alter table fk_r
  ATTACH partition
  fk_r_2 for values in (2);

insert into fk_r values (1, 1, 1);

insert into fk_r values (2, 2, 1);

alter table fk_r
  DETACH partition
  fk_r_1;

alter table fk_r
  DETACH partition
  fk_r_2;

insert into fk_r_1 (id, p_id, p_jd) values (2, 1, 2);

delete from fk_p;

alter table fk_r
  ATTACH partition
  fk_r_1 for values in (1);

alter table fk_r
  ATTACH partition
  fk_r_2 for values in (2);

delete from fk_p;

alter table fk_r_1
  drop constraint fk_r_p_id_p_jd_fkey;

alter table fk_r
  drop constraint fk_r_p_id_p_jd_fkey_1;

alter table fk_r_2
  drop constraint fk_r_p_id_p_jd_fkey;

set client_min_messages = warning;

drop SCHEMA fkpart12 cascade;

reset client_min_messages;

reset search_path;
