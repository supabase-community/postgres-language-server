use pgls_analyse::{AnalysisFilter, GroupCategory, RuleGroup, RuleKey};

use crate::linter_context::{AnalysedFileContext, LinterRuleContext};
use crate::linter_options::LinterOptions;
use crate::linter_rule::{LinterDiagnostic, LinterRule};

pub struct LinterRuleRegistryBuilder<'a> {
    filter: &'a AnalysisFilter<'a>,
    // Store rule keys discovered during traversal
    rule_keys: Vec<RuleKey>,
}

// Implement RegistryVisitor - only needs RuleMeta!
impl pgls_analyse::RegistryVisitor for LinterRuleRegistryBuilder<'_> {
    fn record_category<C: GroupCategory>(&mut self) {
        if self.filter.match_category::<C>() {
            C::record_groups(self);
        }
    }

    fn record_group<G: RuleGroup>(&mut self) {
        if self.filter.match_group::<G>() {
            G::record_rules(self);
        }
    }

    fn record_rule<R>(&mut self)
    where
        R: pgls_analyse::RuleMeta + 'static,
    {
        // Visitor just collects which rules match the filter
        // No executor creation happens here - that's AST-specific
        if self.filter.match_rule::<R>() {
            self.rule_keys.push(RuleKey::rule::<R>());
        }
    }
}

/// The rule registry holds type-erased instances of all active analysis rules
pub struct LinterRuleRegistry {
    pub rules: Vec<RegistryLinterRule>,
}

impl IntoIterator for LinterRuleRegistry {
    type Item = RegistryLinterRule;
    type IntoIter = std::vec::IntoIter<Self::Item>;

    fn into_iter(self) -> Self::IntoIter {
        self.rules.into_iter()
    }
}

/// Internal representation of a single rule in the registry
#[derive(Copy, Clone)]
pub struct RegistryLinterRule {
    pub run: LinterRuleExecutor,
}

impl LinterRuleRegistry {
    pub fn builder<'a>(filter: &'a AnalysisFilter<'a>) -> LinterRuleRegistryBuilder<'a> {
        LinterRuleRegistryBuilder {
            filter,
            rule_keys: Vec::new(),
        }
    }
}

pub struct LinterRegistryRuleParams<'a> {
    pub root: &'a pgls_query::NodeEnum,
    pub options: &'a LinterOptions,
    pub analysed_file_context: &'a AnalysedFileContext<'a>,
    pub schema_cache: Option<&'a pgls_schema_cache::SchemaCache>,
}

/// Executor for rule as a generic function pointer
type LinterRuleExecutor = fn(&LinterRegistryRuleParams) -> Vec<LinterDiagnostic>;

impl RegistryLinterRule {
    pub fn new<R>() -> Self
    where
        R: LinterRule<Options: Default> + 'static,
    {
        /// Generic implementation of LinterRuleExecutor for any rule type R
        fn run<R>(params: &LinterRegistryRuleParams) -> Vec<LinterDiagnostic>
        where
            R: LinterRule<Options: Default> + 'static,
        {
            let options = params.options.rule_options::<R>().unwrap_or_default();

            let ctx = LinterRuleContext::new(
                params.root,
                &options,
                params.schema_cache,
                params.analysed_file_context,
            );

            R::run(&ctx)
        }

        Self { run: run::<R> }
    }
}

impl LinterRuleRegistryBuilder<'_> {
    pub fn build(self) -> LinterRuleRegistry {
        // Look up executor for each collected rule key
        let rules = self
            .rule_keys
            .into_iter()
            .filter_map(|key| {
                // This function will be generated by codegen
                crate::registry::get_linter_rule_executor(&key)
            })
            .collect();

        LinterRuleRegistry { rules }
    }
}
