//! Generated file, do not edit by hand, see `xtask/codegen`

#![doc = r" Generated file, do not edit by hand, see `xtask/codegen`"]
use crate::rule::SplinterRule;
::pgls_analyse::declare_rule! { # [doc = "# Exposed Auth Users\n\nDetects if auth.users is exposed to anon or authenticated roles via a view or materialized view in schemas exposed to PostgREST, potentially compromising user data security.\n\n**Note:** This rule requires Supabase roles (`anon`, `authenticated`, `service_role`). It will be automatically skipped if these roles don't exist in your database.\n\n## SQL Query\n\n```sql\n(\nselect\n    'auth_users_exposed' as \"name!\",\n    'Exposed Auth Users' as \"title!\",\n    'ERROR' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['SECURITY'] as \"categories!\",\n    'Detects if auth.users is exposed to anon or authenticated roles via a view or materialized view in schemas exposed to PostgREST, potentially compromising user data security.' as \"description!\",\n    format(\n        'View/Materialized View \"%s\" in the public schema may expose \\`auth.users\\` data to anon or authenticated roles.',\n        c.relname\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0002_auth_users_exposed' as \"remediation!\",\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', 'view',\n        'exposed_to', array_remove(array_agg(DISTINCT case when pg_catalog.has_table_privilege('anon', c.oid, 'SELECT') then 'anon' when pg_catalog.has_table_privilege('authenticated', c.oid, 'SELECT') then 'authenticated' end), null)\n    ) as \"metadata!\",\n    format('auth_users_exposed_%s_%s', n.nspname, c.relname) as \"cache_key!\"\nfrom\n    -- Identify the oid for auth.users\n    pg_catalog.pg_class auth_users_pg_class\n    join pg_catalog.pg_namespace auth_users_pg_namespace\n        on auth_users_pg_class.relnamespace = auth_users_pg_namespace.oid\n        and auth_users_pg_class.relname = 'users'\n        and auth_users_pg_namespace.nspname = 'auth'\n    -- Depends on auth.users\n    join pg_catalog.pg_depend d\n        on d.refobjid = auth_users_pg_class.oid\n    join pg_catalog.pg_rewrite r\n        on r.oid = d.objid\n    join pg_catalog.pg_class c\n        on c.oid = r.ev_class\n    join pg_catalog.pg_namespace n\n        on n.oid = c.relnamespace\n    join pg_catalog.pg_class pg_class_auth_users\n        on d.refobjid = pg_class_auth_users.oid\nwhere\n    d.deptype = 'n'\n    and (\n      pg_catalog.has_table_privilege('anon', c.oid, 'SELECT')\n      or pg_catalog.has_table_privilege('authenticated', c.oid, 'SELECT')\n    )\n    and n.nspname = any(array(select trim(unnest(string_to_array(current_setting('pgrst.db_schemas', 't'), ',')))))\n    -- Exclude self\n    and c.relname <> '0002_auth_users_exposed'\n    -- There are 3 insecure configurations\n    and\n    (\n        -- Materialized views don't support RLS so this is insecure by default\n        (c.relkind in ('m')) -- m for materialized view\n        or\n        -- Standard View, accessible to anon or authenticated that is security_definer\n        (\n            c.relkind = 'v' -- v for view\n            -- Exclude security invoker views\n            and not (\n                lower(coalesce(c.reloptions::text,'{}'))::text[]\n                && array[\n                    'security_invoker=1',\n                    'security_invoker=true',\n                    'security_invoker=yes',\n                    'security_invoker=on'\n                ]\n            )\n        )\n        or\n        -- Standard View, security invoker, but no RLS enabled on auth.users\n        (\n            c.relkind in ('v') -- v for view\n            -- is security invoker\n            and (\n                lower(coalesce(c.reloptions::text,'{}'))::text[]\n                && array[\n                    'security_invoker=1',\n                    'security_invoker=true',\n                    'security_invoker=yes',\n                    'security_invoker=on'\n                ]\n            )\n            and not pg_class_auth_users.relrowsecurity\n        )\n    )\ngroup by\n    n.nspname,\n    c.relname,\n    c.oid)\n```\n\n## Configuration\n\nEnable or disable this rule in your configuration:\n\n```json\n{\n  \"splinter\": {\n    \"rules\": {\n      \"security\": {\n        \"authUsersExposed\": \"warn\"\n      }\n    }\n  }\n}\n```\n\n## Remediation\n\nSee: <https://supabase.com/docs/guides/database/database-linter?lint=0002_auth_users_exposed>"] pub AuthUsersExposed { version : "1.0.0" , name : "authUsersExposed" , severity : pgls_diagnostics :: Severity :: Error , recommended : true , } }
impl SplinterRule for AuthUsersExposed {
    const SQL_FILE_PATH: &'static str = "security/auth_users_exposed.sql";
    const DESCRIPTION: &'static str = "Detects if auth.users is exposed to anon or authenticated roles via a view or materialized view in schemas exposed to PostgREST, potentially compromising user data security.";
    const REMEDIATION: &'static str =
        "https://supabase.com/docs/guides/database/database-linter?lint=0002_auth_users_exposed";
    const REQUIRES_SUPABASE: bool = true;
}
