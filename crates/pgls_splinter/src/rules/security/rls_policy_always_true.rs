//! Generated file, do not edit by hand, see `xtask/codegen`

#![doc = r" Generated file, do not edit by hand, see `xtask/codegen`"]
use crate::rule::SplinterRule;
::pgls_analyse::declare_rule! { # [doc = "# RLS Policy Always True\n\nDetects RLS policies that use overly permissive expressions like USING (true) or WITH CHECK (true) for UPDATE, DELETE, or INSERT operations. SELECT policies with USING (true) are intentionally excluded as this pattern is often used deliberately for public read access.\n\n**Note:** This rule requires Supabase roles (`anon`, `authenticated`, `service_role`). It will be automatically skipped if these roles don't exist in your database.\n\n## SQL Query\n\n```sql\n(\nwith policies as (\n    select\n        nsp.nspname as schema_name,\n        pb.tablename as table_name,\n        pc.relrowsecurity as is_rls_active,\n        pa.polname as policy_name,\n        pa.polpermissive as is_permissive,\n        pa.polroles as role_oids,\n        (select array_agg(r::regrole::text) from unnest(pa.polroles) as x(r)) as roles,\n        case pa.polcmd\n            when 'r' then 'SELECT'\n            when 'a' then 'INSERT'\n            when 'w' then 'UPDATE'\n            when 'd' then 'DELETE'\n            when '*' then 'ALL'\n        end as command,\n        pb.qual,\n        pb.with_check,\n        -- Normalize expressions by removing whitespace and lowercasing\n        replace(replace(replace(lower(coalesce(pb.qual, '')), ' ', ''), E'\\n', ''), E'\\t', '') as normalized_qual,\n        replace(replace(replace(lower(coalesce(pb.with_check, '')), ' ', ''), E'\\n', ''), E'\\t', '') as normalized_with_check\n    from\n        pg_catalog.pg_policy pa\n        join pg_catalog.pg_class pc\n            on pa.polrelid = pc.oid\n        join pg_catalog.pg_namespace nsp\n            on pc.relnamespace = nsp.oid\n        join pg_catalog.pg_policies pb\n            on pc.relname = pb.tablename\n            and nsp.nspname = pb.schemaname\n            and pa.polname = pb.policyname\n    where\n        pc.relkind = 'r' -- regular tables\n        and nsp.nspname not in (\n            '_timescaledb_cache', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_internal', 'auth', 'cron', 'extensions', 'graphql', 'graphql_public', 'information_schema', 'net', 'pgmq', 'pgroonga', 'pgsodium', 'pgsodium_masks', 'pgtle', 'pgbouncer', 'pg_catalog', 'pgtle', 'realtime', 'repack', 'storage', 'supabase_functions', 'supabase_migrations', 'tiger', 'topology', 'vault'\n        )\n),\npermissive_patterns as (\n    select\n        p.*,\n        -- Check for always-true USING clause patterns\n        -- Note: SELECT with (true) is often intentional and documented, so we only flag UPDATE/DELETE\n        case when (\n            command in ('UPDATE', 'DELETE', 'ALL')\n            and (\n                normalized_qual in ('true', '(true)', '1=1', '(1=1)')\n                -- Empty or null qual on permissive policy means allow all\n                or (qual is null and is_permissive)\n            )\n        ) then true else false end as has_permissive_using,\n        -- Check for always-true WITH CHECK clause patterns\n        case when (\n            normalized_with_check in ('true', '(true)', '1=1', '(1=1)')\n            -- Empty with_check on INSERT means allow all (INSERT has no USING to fall back on)\n            or (with_check is null and is_permissive and command = 'INSERT')\n            -- Empty with_check on UPDATE/ALL with permissive USING means allow all writes\n            or (with_check is null and is_permissive and command in ('UPDATE', 'ALL')\n                and normalized_qual in ('true', '(true)', '1=1', '(1=1)'))\n        ) then true else false end as has_permissive_with_check\n    from\n        policies p\n    where\n        -- Only check tables with RLS enabled (otherwise it's a different lint)\n        is_rls_active\n        -- Only check permissive policies (restrictive policies with true are less dangerous)\n        and is_permissive\n        -- Only flag policies that apply to anon or authenticated roles (or public/all roles)\n        and (\n            role_oids = array[0::oid] -- public (all roles)\n            or exists (\n                select 1\n                from unnest(role_oids) as r\n                where r::regrole::text in ('anon', 'authenticated')\n            )\n        )\n)\nselect\n    'rls_policy_always_true' as \"name!\",\n    'RLS Policy Always True' as \"title!\",\n    'WARN' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['SECURITY'] as \"categories!\",\n    'Detects RLS policies that use overly permissive expressions like USING (true) or WITH CHECK (true) for UPDATE, DELETE, or INSERT operations. SELECT policies with USING (true) are intentionally excluded as this pattern is often used deliberately for public read access.' as \"description!\",\n    format(\n        'Table `%s.%s` has an RLS policy `%s` for `%s` that allows unrestricted access%s. This effectively bypasses row-level security for %s.',\n        schema_name,\n        table_name,\n        policy_name,\n        command,\n        case\n            when has_permissive_using and has_permissive_with_check then ' (both USING and WITH CHECK are always true)'\n            when has_permissive_using then ' (USING clause is always true)'\n            when has_permissive_with_check then ' (WITH CHECK clause is always true)'\n            else ''\n        end,\n        array_to_string(roles, ', ')\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy' as \"remediation!\",\n    jsonb_build_object(\n        'schema', schema_name,\n        'name', table_name,\n        'type', 'table',\n        'policy_name', policy_name,\n        'command', command,\n        'roles', roles,\n        'qual', qual,\n        'with_check', with_check,\n        'permissive_using', has_permissive_using,\n        'permissive_with_check', has_permissive_with_check\n    ) as \"metadata!\",\n    format(\n        'rls_policy_always_true_%s_%s_%s',\n        schema_name,\n        table_name,\n        policy_name\n    ) as \"cache_key!\"\nfrom\n    permissive_patterns\nwhere\n    has_permissive_using or has_permissive_with_check\norder by\n    schema_name,\n    table_name,\n    policy_name)\n```\n\n## Configuration\n\nEnable or disable this rule in your configuration:\n\n```json\n{\n  \"splinter\": {\n    \"rules\": {\n      \"security\": {\n        \"rlsPolicyAlwaysTrue\": \"warn\"\n      }\n    }\n  }\n}\n```\n\n## Remediation\n\nSee: <https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy>"] pub RlsPolicyAlwaysTrue { version : "1.0.0" , name : "rlsPolicyAlwaysTrue" , severity : pgls_diagnostics :: Severity :: Warning , recommended : true , } }
impl SplinterRule for RlsPolicyAlwaysTrue {
    const SQL_FILE_PATH: &'static str = "security/rls_policy_always_true.sql";
    const DESCRIPTION: &'static str = "Detects RLS policies that use overly permissive expressions like USING (true) or WITH CHECK (true) for UPDATE, DELETE, or INSERT operations. SELECT policies with USING (true) are intentionally excluded as this pattern is often used deliberately for public read access.";
    const REMEDIATION: &'static str =
        "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy";
    const REQUIRES_SUPABASE: bool = true;
}
