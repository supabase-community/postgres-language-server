//! Generated file, do not edit by hand, see `xtask/codegen`

#![doc = r" Generated file, do not edit by hand, see `xtask/codegen`"]
use crate::rule::SplinterRule;
::pgls_analyse::declare_rule! { # [doc = "/// # Table Bloat\n///\n/// Detects if a table has excess bloat and may benefit from maintenance operations like vacuum full or cluster.\n///\n/// ## SQL Query\n///\n/// ```sql\n/// (\n/// with constants as (\n///     select current_setting('block_size')::numeric as bs, 23 as hdr, 4 as ma\n/// ),\n/// \n/// bloat_info as (\n///     select\n///         ma,\n///         bs,\n///         schemaname,\n///         tablename,\n///         (datawidth + (hdr + ma - (case when hdr % ma = 0 then ma else hdr % ma end)))::numeric as datahdr,\n///         (maxfracsum * (nullhdr + ma - (case when nullhdr % ma = 0 then ma else nullhdr % ma end))) as nullhdr2\n///     from (\n///         select\n///             schemaname,\n///             tablename,\n///             hdr,\n///             ma,\n///             bs,\n///             sum((1 - null_frac) * avg_width) as datawidth,\n///             max(null_frac) as maxfracsum,\n///             hdr + (\n///                 select 1 + count(*) / 8\n///                 from pg_stats s2\n///                 where\n///                     null_frac <> 0\n///                     and s2.schemaname = s.schemaname\n///                     and s2.tablename = s.tablename\n///             ) as nullhdr\n///         from pg_stats s, constants\n///         group by 1, 2, 3, 4, 5\n///     ) as foo\n/// ),\n/// \n/// table_bloat as (\n///     select\n///         schemaname,\n///         tablename,\n///         cc.relpages,\n///         bs,\n///         ceil((cc.reltuples * ((datahdr + ma -\n///           (case when datahdr % ma = 0 then ma else datahdr % ma end)) + nullhdr2 + 4)) / (bs - 20::float)) as otta\n///     from\n///         bloat_info\n///         join pg_class cc\n///             on cc.relname = bloat_info.tablename\n///         join pg_namespace nn\n///             on cc.relnamespace = nn.oid\n///             and nn.nspname = bloat_info.schemaname\n///             and nn.nspname <> 'information_schema'\n///         where\n///             cc.relkind = 'r'\n///             and cc.relam = (select oid from pg_am where amname = 'heap')\n/// ),\n/// \n/// bloat_data as (\n///     select\n///         'table' as type,\n///         schemaname,\n///         tablename as object_name,\n///         round(case when otta = 0 then 0.0 else table_bloat.relpages / otta::numeric end, 1) as bloat,\n///         case when relpages < otta then 0 else (bs * (table_bloat.relpages - otta)::bigint)::bigint end as raw_waste\n///     from\n///         table_bloat\n/// )\n/// \n/// select\n///     'table_bloat' as \"name!\",\n///     'Table Bloat' as \"title!\",\n///     'INFO' as \"level!\",\n///     'EXTERNAL' as \"facing!\",\n///     array['PERFORMANCE'] as \"categories!\",\n///     'Detects if a table has excess bloat and may benefit from maintenance operations like vacuum full or cluster.' as \"description!\",\n///     format(\n///         'Table `%s`.`%s` has excessive bloat',\n///         bloat_data.schemaname,\n///         bloat_data.object_name\n///     ) as \"detail!\",\n///     'Consider running vacuum full (WARNING: incurs downtime) and tweaking autovacuum settings to reduce bloat.' as \"remediation!\",\n///     jsonb_build_object(\n///         'schema', bloat_data.schemaname,\n///         'name', bloat_data.object_name,\n///         'type', bloat_data.type\n///     ) as \"metadata!\",\n///     format(\n///         'table_bloat_%s_%s',\n///         bloat_data.schemaname,\n///         bloat_data.object_name\n///     ) as \"cache_key!\"\n/// from\n///     bloat_data\n/// where\n///     bloat > 70.0\n///     and raw_waste > (20 * 1024 * 1024) -- filter for waste > 200 MB\n/// order by\n///     schemaname,\n///     object_name)\n/// ```\n///\n/// ## Configuration\n///\n/// Enable or disable this rule in your configuration:\n///\n/// ```json\n/// {\n///   \"splinter\": {\n///     \"rules\": {\n///       \"performance\": {\n///         \"tableBloat\": \"warn\"\n///       }\n///     }\n///   }\n/// }\n/// ```\n///\n/// ## Remediation\n///\n/// See: <Consider running vacuum full (WARNING: incurs downtime) and tweaking autovacuum settings to reduce bloat.>"] pub TableBloat { version : "1.0.0" , name : "tableBloat" , severity : pgls_diagnostics :: Severity :: Information , } }
impl SplinterRule for TableBloat {
    fn sql_file_path() -> &'static str {
        "performance/table_bloat.sql"
    }
}
