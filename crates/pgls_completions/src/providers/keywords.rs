use pgls_treesitter::TreesitterContext;

use crate::{
    CompletionItemKind, CompletionText,
    builder::{CompletionBuilder, PossibleCompletionItem},
    providers::helper::get_range_to_replace,
    relevance::{CompletionRelevanceData, filtering::CompletionFilter, scoring::CompletionScore},
};

const ALL_KEYWORDS: &[&str] = &[
    "action",
    "add",
    "admin",
    "after",
    "all",
    "alter",
    "always",
    "analyze",
    "and",
    "any",
    "array",
    "as",
    "asc",
    "atomic",
    "attribute",
    "authorization",
    "auto_increment",
    "avro",
    "before",
    "begin",
    "between",
    "bigint",
    "bigserial",
    "bin_pack",
    "binary",
    "bit",
    "boolean",
    "box2d",
    "box3d",
    "brin",
    "btree",
    "by",
    "bytea",
    "cache",
    "cached",
    "called",
    "cascade",
    "cascaded",
    "case",
    "cast",
    "change",
    "char",
    "character",
    "characteristics",
    "check",
    "collate",
    "column",
    "columns",
    "comment",
    "commit",
    "committed",
    "compression",
    "compute",
    "concurrently",
    "conflict",
    "connection",
    "constraint",
    "constraints",
    "copy",
    "cost",
    "create",
    "cross",
    "csv",
    "current",
    "current_role",
    "current_timestamp",
    "current_user",
    "cycle",
    "data",
    "database",
    "date",
    "datetime",
    "datetime2",
    "datetimeoffset",
    "decimal",
    "declare",
    "default",
    "deferrable",
    "deferred",
    "definer",
    "delayed",
    "delete",
    "delimited",
    "delimiter",
    "desc",
    "distinct",
    "do",
    "double",
    "drop",
    "duplicate",
    "each",
    "else",
    "encoding",
    "encrypted",
    "end",
    "engine",
    "enum",
    "escape",
    "escaped",
    "except",
    "exclude",
    "execute",
    "exists",
    "explain",
    "extended",
    "extension",
    "external",
    "false",
    "fields",
    "filter",
    "first",
    "float",
    "following",
    "follows",
    "for",
    "force",
    "force_not_null",
    "force_null",
    "force_quote",
    "foreign",
    "format",
    "freeze",
    "from",
    "full",
    "function",
    "functions",
    "generated",
    "geography",
    "geometry",
    "gin",
    "gist",
    "grant",
    "granted",
    "group",
    "groups",
    "hash",
    "having",
    "header",
    "high_priority",
    "if",
    "ignore",
    "image",
    "immediate",
    "immutable",
    "in",
    "increment",
    "incremental",
    "index",
    "inet",
    "inherit",
    "initially",
    "inner",
    "inout",
    "input",
    "insert",
    "instead",
    "int",
    "intersect",
    "interval",
    "into",
    "invoker",
    "is",
    "isolation",
    "join",
    "json",
    "jsonb",
    "jsonfile",
    "key",
    "language",
    "last",
    "lateral",
    "leakproof",
    "left",
    "level",
    "like",
    "limit",
    "lines",
    "local",
    "location",
    "logged",
    "low_priority",
    "main",
    "maintain",
    "match",
    "matched",
    "materialized",
    "maxvalue",
    "mediumint",
    "merge",
    "metadata",
    "minvalue",
    "modify",
    "money",
    "name",
    "names",
    "natural",
    "nchar",
    "new",
    "no",
    "none",
    "noscan",
    "not",
    "nothing",
    "nowait",
    "null",
    "nulls",
    "numeric",
    "nvarchar",
    "object_id",
    "of",
    "off",
    "offset",
    "oid",
    "oids",
    "old",
    "on",
    "only",
    "optimize",
    "option",
    "or",
    "orc",
    "order",
    "ordinality",
    "others",
    "out",
    "outer",
    "over",
    "overriding",
    "overwrite",
    "owned",
    "owner",
    "parallel",
    "parquet",
    "partition",
    "partitioned",
    "password",
    "permissive",
    "plain",
    "policy",
    "precedes",
    "preceding",
    "precision",
    "primary",
    "privileges",
    "procedure",
    "procedures",
    "program",
    "public",
    "quote",
    "range",
    "rcfile",
    "read",
    "real",
    "recursive",
    "references",
    "referencing",
    "regclass",
    "regnamespace",
    "regproc",
    "regtype",
    "rename",
    "repeatable",
    "replace",
    "replication",
    "reset",
    "restart",
    "restrict",
    "restricted",
    "restrictive",
    "return",
    "returning",
    "returns",
    "revoke",
    "rewrite",
    "right",
    "role",
    "rollback",
    "routine",
    "routines",
    "row",
    "rows",
    "safe",
    "schema",
    "security",
    "select",
    "separator",
    "sequence",
    "sequencefile",
    "serial",
    "serializable",
    "session",
    "session_user",
    "set",
    "setof",
    "show",
    "similar",
    "smalldatetime",
    "smallint",
    "smallmoney",
    "smallserial",
    "snapshot",
    "some",
    "sort",
    "spgist",
    "stable",
    "start",
    "statement",
    "statistics",
    "stats",
    "stdin",
    "storage",
    "stored",
    "strict",
    "string",
    "support",
    "system",
    "table",
    "tables",
    "tablespace",
    "tblproperties",
    "temp",
    "temporary",
    "terminated",
    "text",
    "textfile",
    "then",
    "ties",
    "time",
    "timestamp",
    "timestamptz",
    "tinyint",
    "to",
    "transaction",
    "trigger",
    "true",
    "truncate",
    "type",
    "unbounded",
    "uncached",
    "uncommitted",
    "union",
    "unique",
    "unload",
    "unlogged",
    "unsafe",
    "unsigned",
    "until",
    "update",
    "use",
    "user",
    "using",
    "uuid",
    "vacuum",
    "valid",
    "value",
    "values",
    "varbinary",
    "varchar",
    "variadic",
    "varying",
    "verbose",
    "version",
    "view",
    "virtual",
    "volatile",
    "wait",
    "when",
    "where",
    "window",
    "with",
    "without",
    "write",
    "xml",
    "zerofill",
    "zone",
];

pub fn complete_keywords<'a>(ctx: &TreesitterContext<'a>, builder: &mut CompletionBuilder<'a>) {
    let keywords = ALL_KEYWORDS
        .iter()
        .filter(|kw| ctx.possible_keywords_at_position.contains(kw));

    for kw in keywords {
        let relevance = CompletionRelevanceData::Keyword(kw);

        let item = PossibleCompletionItem {
            label: kw.to_string(),
            score: CompletionScore::from(relevance.clone()),
            filter: CompletionFilter::from(relevance),
            description: "Keyword".into(),
            kind: CompletionItemKind::Keyword,
            completion_text: Some(CompletionText {
                text: kw.to_string(),
                range: get_range_to_replace(ctx),
                is_snippet: false,
            }),
            detail: None,
        };

        builder.add_item(item);
    }
}

#[cfg(test)]
mod tests {
    use pgls_test_utils::QueryWithCursorPosition;
    use sqlx::PgPool;

    use crate::test_helper::{
        CompletionAssertion, assert_complete_results, assert_no_complete_results,
    };

    #[sqlx::test]
    async fn completes_keywords(pool: PgPool) {
        let setup = r#"
            create table public.users (
                id serial primary key,
                email varchar(255)
            );
        "#;

        let query = format!("se{}", QueryWithCursorPosition::cursor_marker());

        assert_complete_results(
            query.as_str(),
            vec![
                CompletionAssertion::LabelAndKind(
                    "security".into(),
                    crate::CompletionItemKind::Keyword,
                ),
                CompletionAssertion::LabelAndKind(
                    "select".into(),
                    crate::CompletionItemKind::Keyword,
                ),
                CompletionAssertion::LabelAndKind(
                    "separator".into(),
                    crate::CompletionItemKind::Keyword,
                ),
                CompletionAssertion::LabelAndKind(
                    "sequence".into(),
                    crate::CompletionItemKind::Keyword,
                ),
                CompletionAssertion::LabelAndKind(
                    "sequencefile".into(),
                    crate::CompletionItemKind::Keyword,
                ),
                CompletionAssertion::LabelAndKind("set".into(), crate::CompletionItemKind::Keyword),
            ],
            Some(setup),
            &pool,
        )
        .await;
    }

    #[sqlx::test]
    async fn completes_keywords_2(pool: PgPool) {
        let setup = r#"
            create table public.users (
                id serial primary key,
                email varchar(255)
            );
        "#;

        let query = format!(
            "select email from auth.users {}",
            QueryWithCursorPosition::cursor_marker()
        );

        assert_no_complete_results(query.as_str(), Some(setup), &pool).await;
    }
}
