{
  "db_name": "PostgreSQL",
  "query": "\n(\nwith foreign_keys as (\n    select\n        cl.relnamespace::regnamespace::text as schema_name,\n        cl.relname as table_name,\n        cl.oid as table_oid,\n        ct.conname as fkey_name,\n        ct.conkey as col_attnums\n    from\n        pg_catalog.pg_constraint ct\n        join pg_catalog.pg_class cl -- fkey owning table\n            on ct.conrelid = cl.oid\n        left join pg_catalog.pg_depend d\n            on d.objid = cl.oid\n            and d.deptype = 'e'\n    where\n        ct.contype = 'f' -- foreign key constraints\n        and d.objid is null -- exclude tables that are dependencies of extensions\n        and cl.relnamespace::regnamespace::text not in (\n            'pg_catalog', 'information_schema', 'auth', 'storage', 'vault', 'extensions'\n        )\n),\nindex_ as (\n    select\n        pi.indrelid as table_oid,\n        indexrelid::regclass as index_,\n        string_to_array(indkey::text, ' ')::smallint[] as col_attnums\n    from\n        pg_catalog.pg_index pi\n    where\n        indisvalid\n)\nselect\n    'unindexed_foreign_keys' as \"name!\",\n    'Unindexed foreign keys' as \"title!\",\n    'INFO' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['PERFORMANCE'] as \"categories!\",\n    'Identifies foreign key constraints without a covering index, which can impact database performance.' as \"description!\",\n    format(\n        'Table \\`%s.%s\\` has a foreign key \\`%s\\` without a covering index. This can lead to suboptimal query performance.',\n        fk.schema_name,\n        fk.table_name,\n        fk.fkey_name\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0001_unindexed_foreign_keys' as \"remediation!\",\n    jsonb_build_object(\n        'schema', fk.schema_name,\n        'name', fk.table_name,\n        'type', 'table',\n        'fkey_name', fk.fkey_name,\n        'fkey_columns', fk.col_attnums\n    ) as \"metadata!\",\n    format('unindexed_foreign_keys_%s_%s_%s', fk.schema_name, fk.table_name, fk.fkey_name) as \"cache_key!\"\nfrom\n    foreign_keys fk\n    left join index_ idx\n        on fk.table_oid = idx.table_oid\n        and fk.col_attnums = idx.col_attnums[1:array_length(fk.col_attnums, 1)]\n    left join pg_catalog.pg_depend dep\n        on idx.table_oid = dep.objid\n        and dep.deptype = 'e'\nwhere\n    idx.index_ is null\n    and fk.schema_name not in (\n        '_timescaledb_cache', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_internal', 'auth', 'cron', 'extensions', 'graphql', 'graphql_public', 'information_schema', 'net', 'pgmq', 'pgroonga', 'pgsodium', 'pgsodium_masks', 'pgtle', 'pgbouncer', 'pg_catalog', 'pgtle', 'realtime', 'repack', 'storage', 'supabase_functions', 'supabase_migrations', 'tiger', 'topology', 'vault'\n    )\n    and dep.objid is null -- exclude tables owned by extensions\norder by\n    fk.schema_name,\n    fk.table_name,\n    fk.fkey_name)\nunion all\n\n(\nselect\n    'no_primary_key' as \"name!\",\n    'No Primary Key' as \"title!\",\n    'INFO' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['PERFORMANCE'] as \"categories!\",\n    'Detects if a table does not have a primary key. Tables without a primary key can be inefficient to interact with at scale.' as \"description!\",\n    format(\n        'Table \\`%s.%s\\` does not have a primary key',\n        pgns.nspname,\n        pgc.relname\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0004_no_primary_key' as \"remediation!\",\n     jsonb_build_object(\n        'schema', pgns.nspname,\n        'name', pgc.relname,\n        'type', 'table'\n    ) as \"metadata!\",\n    format(\n        'no_primary_key_%s_%s',\n        pgns.nspname,\n        pgc.relname\n    ) as \"cache_key!\"\nfrom\n    pg_catalog.pg_class pgc\n    join pg_catalog.pg_namespace pgns\n        on pgns.oid = pgc.relnamespace\n    left join pg_catalog.pg_index pgi\n        on pgi.indrelid = pgc.oid\n    left join pg_catalog.pg_depend dep\n        on pgc.oid = dep.objid\n        and dep.deptype = 'e'\nwhere\n    pgc.relkind = 'r' -- regular tables\n    and pgns.nspname not in (\n        '_timescaledb_cache', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_internal', 'auth', 'cron', 'extensions', 'graphql', 'graphql_public', 'information_schema', 'net', 'pgmq', 'pgroonga', 'pgsodium', 'pgsodium_masks', 'pgtle', 'pgbouncer', 'pg_catalog', 'pgtle', 'realtime', 'repack', 'storage', 'supabase_functions', 'supabase_migrations', 'tiger', 'topology', 'vault'\n    )\n    and dep.objid is null -- exclude tables owned by extensions\ngroup by\n    pgc.oid,\n    pgns.nspname,\n    pgc.relname\nhaving\n    max(coalesce(pgi.indisprimary, false)::int) = 0)\nunion all\n\n(\nselect\n    'unused_index' as \"name!\",\n    'Unused Index' as \"title!\",\n    'INFO' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['PERFORMANCE'] as \"categories!\",\n    'Detects if an index has never been used and may be a candidate for removal.' as \"description!\",\n    format(\n        'Index \\`%s\\` on table \\`%s.%s\\` has not been used',\n        psui.indexrelname,\n        psui.schemaname,\n        psui.relname\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0005_unused_index' as \"remediation!\",\n    jsonb_build_object(\n        'schema', psui.schemaname,\n        'name', psui.relname,\n        'type', 'table'\n    ) as \"metadata!\",\n    format(\n        'unused_index_%s_%s_%s',\n        psui.schemaname,\n        psui.relname,\n        psui.indexrelname\n    ) as \"cache_key!\"\n\nfrom\n    pg_catalog.pg_stat_user_indexes psui\n    join pg_catalog.pg_index pi\n        on psui.indexrelid = pi.indexrelid\n    left join pg_catalog.pg_depend dep\n        on psui.relid = dep.objid\n        and dep.deptype = 'e'\nwhere\n    psui.idx_scan = 0\n    and not pi.indisunique\n    and not pi.indisprimary\n    and dep.objid is null -- exclude tables owned by extensions\n    and psui.schemaname not in (\n        '_timescaledb_cache', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_internal', 'auth', 'cron', 'extensions', 'graphql', 'graphql_public', 'information_schema', 'net', 'pgmq', 'pgroonga', 'pgsodium', 'pgsodium_masks', 'pgtle', 'pgbouncer', 'pg_catalog', 'pgtle', 'realtime', 'repack', 'storage', 'supabase_functions', 'supabase_migrations', 'tiger', 'topology', 'vault'\n    ))\nunion all\n\n(\nselect\n    'multiple_permissive_policies' as \"name!\",\n    'Multiple Permissive Policies' as \"title!\",\n    'WARN' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['PERFORMANCE'] as \"categories!\",\n    'Detects if multiple permissive row level security policies are present on a table for the same \\`role\\` and \\`action\\` (e.g. insert). Multiple permissive policies are suboptimal for performance as each policy must be executed for every relevant query.' as \"description!\",\n    format(\n        'Table \\`%s.%s\\` has multiple permissive policies for role \\`%s\\` for action \\`%s\\`. Policies include \\`%s\\`',\n        n.nspname,\n        c.relname,\n        r.rolname,\n        act.cmd,\n        array_agg(p.polname order by p.polname)\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0006_multiple_permissive_policies' as \"remediation!\",\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', 'table'\n    ) as \"metadata!\",\n    format(\n        'multiple_permissive_policies_%s_%s_%s_%s',\n        n.nspname,\n        c.relname,\n        r.rolname,\n        act.cmd\n    ) as \"cache_key!\"\nfrom\n    pg_catalog.pg_policy p\n    join pg_catalog.pg_class c\n        on p.polrelid = c.oid\n    join pg_catalog.pg_namespace n\n        on c.relnamespace = n.oid\n    join pg_catalog.pg_roles r\n        on p.polroles @> array[r.oid]\n        or p.polroles = array[0::oid]\n    left join pg_catalog.pg_depend dep\n        on c.oid = dep.objid\n        and dep.deptype = 'e',\n    lateral (\n        select x.cmd\n        from unnest((\n            select\n                case p.polcmd\n                    when 'r' then array['SELECT']\n                    when 'a' then array['INSERT']\n                    when 'w' then array['UPDATE']\n                    when 'd' then array['DELETE']\n                    when '*' then array['SELECT', 'INSERT', 'UPDATE', 'DELETE']\n                    else array['ERROR']\n                end as actions\n        )) x(cmd)\n    ) act(cmd)\nwhere\n    c.relkind = 'r' -- regular tables\n    and p.polpermissive -- policy is permissive\n    and n.nspname not in (\n        '_timescaledb_cache', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_internal', 'auth', 'cron', 'extensions', 'graphql', 'graphql_public', 'information_schema', 'net', 'pgmq', 'pgroonga', 'pgsodium', 'pgsodium_masks', 'pgtle', 'pgbouncer', 'pg_catalog', 'pgtle', 'realtime', 'repack', 'storage', 'supabase_functions', 'supabase_migrations', 'tiger', 'topology', 'vault'\n    )\n    and r.rolname not like 'pg_%'\n    and r.rolname not like 'supabase%admin'\n    and not r.rolbypassrls\n    and dep.objid is null -- exclude tables owned by extensions\ngroup by\n    n.nspname,\n    c.relname,\n    r.rolname,\n    act.cmd\nhaving\n    count(1) > 1)\nunion all\n\n(\nselect\n    'policy_exists_rls_disabled' as \"name!\",\n    'Policy Exists RLS Disabled' as \"title!\",\n    'ERROR' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['SECURITY'] as \"categories!\",\n    'Detects cases where row level security (RLS) policies have been created, but RLS has not been enabled for the underlying table.' as \"description!\",\n    format(\n        'Table \\`%s.%s\\` has RLS policies but RLS is not enabled on the table. Policies include %s.',\n        n.nspname,\n        c.relname,\n        array_agg(p.polname order by p.polname)\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0007_policy_exists_rls_disabled' as \"remediation!\",\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', 'table'\n    ) as \"metadata!\",\n    format(\n        'policy_exists_rls_disabled_%s_%s',\n        n.nspname,\n        c.relname\n    ) as \"cache_key!\"\nfrom\n    pg_catalog.pg_policy p\n    join pg_catalog.pg_class c\n        on p.polrelid = c.oid\n    join pg_catalog.pg_namespace n\n        on c.relnamespace = n.oid\n    left join pg_catalog.pg_depend dep\n        on c.oid = dep.objid\n        and dep.deptype = 'e'\nwhere\n    c.relkind = 'r' -- regular tables\n    and n.nspname not in (\n        '_timescaledb_cache', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_internal', 'auth', 'cron', 'extensions', 'graphql', 'graphql_public', 'information_schema', 'net', 'pgmq', 'pgroonga', 'pgsodium', 'pgsodium_masks', 'pgtle', 'pgbouncer', 'pg_catalog', 'pgtle', 'realtime', 'repack', 'storage', 'supabase_functions', 'supabase_migrations', 'tiger', 'topology', 'vault'\n    )\n    -- RLS is disabled\n    and not c.relrowsecurity\n    and dep.objid is null -- exclude tables owned by extensions\ngroup by\n    n.nspname,\n    c.relname)\nunion all\n\n(\nselect\n    'rls_enabled_no_policy' as \"name!\",\n    'RLS Enabled No Policy' as \"title!\",\n    'INFO' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['SECURITY'] as \"categories!\",\n    'Detects cases where row level security (RLS) has been enabled on a table but no RLS policies have been created.' as \"description!\",\n    format(\n        'Table \\`%s.%s\\` has RLS enabled, but no policies exist',\n        n.nspname,\n        c.relname\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0008_rls_enabled_no_policy' as \"remediation!\",\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', 'table'\n    ) as \"metadata!\",\n    format(\n        'rls_enabled_no_policy_%s_%s',\n        n.nspname,\n        c.relname\n    ) as \"cache_key!\"\nfrom\n    pg_catalog.pg_class c\n    left join pg_catalog.pg_policy p\n        on p.polrelid = c.oid\n    join pg_catalog.pg_namespace n\n        on c.relnamespace = n.oid\n    left join pg_catalog.pg_depend dep\n        on c.oid = dep.objid\n        and dep.deptype = 'e'\nwhere\n    c.relkind = 'r' -- regular tables\n    and n.nspname not in (\n        '_timescaledb_cache', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_internal', 'auth', 'cron', 'extensions', 'graphql', 'graphql_public', 'information_schema', 'net', 'pgmq', 'pgroonga', 'pgsodium', 'pgsodium_masks', 'pgtle', 'pgbouncer', 'pg_catalog', 'pgtle', 'realtime', 'repack', 'storage', 'supabase_functions', 'supabase_migrations', 'tiger', 'topology', 'vault'\n    )\n    -- RLS is enabled\n    and c.relrowsecurity\n    and p.polname is null\n    and dep.objid is null -- exclude tables owned by extensions\ngroup by\n    n.nspname,\n    c.relname)\nunion all\n\n(\nselect\n    'duplicate_index' as \"name!\",\n    'Duplicate Index' as \"title!\",\n    'WARN' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['PERFORMANCE'] as \"categories!\",\n    'Detects cases where two ore more identical indexes exist.' as \"description!\",\n    format(\n        'Table \\`%s.%s\\` has identical indexes %s. Drop all except one of them',\n        n.nspname,\n        c.relname,\n        array_agg(pi.indexname order by pi.indexname)\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0009_duplicate_index' as \"remediation!\",\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', case\n            when c.relkind = 'r' then 'table'\n            when c.relkind = 'm' then 'materialized view'\n            else 'ERROR'\n        end,\n        'indexes', array_agg(pi.indexname order by pi.indexname)\n    ) as \"metadata!\",\n    format(\n        'duplicate_index_%s_%s_%s',\n        n.nspname,\n        c.relname,\n        array_agg(pi.indexname order by pi.indexname)\n    ) as \"cache_key!\"\nfrom\n    pg_catalog.pg_indexes pi\n    join pg_catalog.pg_namespace n\n        on n.nspname  = pi.schemaname\n    join pg_catalog.pg_class c\n        on pi.tablename = c.relname\n        and n.oid = c.relnamespace\n    left join pg_catalog.pg_depend dep\n        on c.oid = dep.objid\n        and dep.deptype = 'e'\nwhere\n    c.relkind in ('r', 'm') -- tables and materialized views\n    and n.nspname not in (\n        '_timescaledb_cache', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_internal', 'auth', 'cron', 'extensions', 'graphql', 'graphql_public', 'information_schema', 'net', 'pgmq', 'pgroonga', 'pgsodium', 'pgsodium_masks', 'pgtle', 'pgbouncer', 'pg_catalog', 'pgtle', 'realtime', 'repack', 'storage', 'supabase_functions', 'supabase_migrations', 'tiger', 'topology', 'vault'\n    )\n    and dep.objid is null -- exclude tables owned by extensions\ngroup by\n    n.nspname,\n    c.relkind,\n    c.relname,\n    replace(pi.indexdef, pi.indexname, '')\nhaving\n    count(*) > 1)\nunion all\n\n(\nselect\n    'function_search_path_mutable' as \"name!\",\n    'Function Search Path Mutable' as \"title!\",\n    'WARN' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['SECURITY'] as \"categories!\",\n    'Detects functions where the search_path parameter is not set.' as \"description!\",\n    format(\n        'Function \\`%s.%s\\` has a role mutable search_path',\n        n.nspname,\n        p.proname\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0011_function_search_path_mutable' as \"remediation!\",\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', p.proname,\n        'type', 'function'\n    ) as \"metadata!\",\n    format(\n        'function_search_path_mutable_%s_%s_%s',\n        n.nspname,\n        p.proname,\n        md5(p.prosrc) -- required when function is polymorphic\n    ) as \"cache_key!\"\nfrom\n    pg_catalog.pg_proc p\n    join pg_catalog.pg_namespace n\n        on p.pronamespace = n.oid\n    left join pg_catalog.pg_depend dep\n        on p.oid = dep.objid\n        and dep.deptype = 'e'\nwhere\n    n.nspname not in (\n        '_timescaledb_cache', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_internal', 'auth', 'cron', 'extensions', 'graphql', 'graphql_public', 'information_schema', 'net', 'pgmq', 'pgroonga', 'pgsodium', 'pgsodium_masks', 'pgtle', 'pgbouncer', 'pg_catalog', 'pgtle', 'realtime', 'repack', 'storage', 'supabase_functions', 'supabase_migrations', 'tiger', 'topology', 'vault'\n    )\n    and dep.objid is null -- exclude functions owned by extensions\n    -- Search path not set\n    and not exists (\n        select 1\n        from unnest(coalesce(p.proconfig, '{}')) as config\n        where config like 'search_path=%'\n    ))\nunion all\n\n(\nselect\n    'extension_in_public' as \"name!\",\n    'Extension in Public' as \"title!\",\n    'WARN' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['SECURITY'] as \"categories!\",\n    'Detects extensions installed in the \\`public\\` schema.' as \"description!\",\n    format(\n        'Extension \\`%s\\` is installed in the public schema. Move it to another schema.',\n        pe.extname\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0014_extension_in_public' as \"remediation!\",\n    jsonb_build_object(\n        'schema', pe.extnamespace::regnamespace,\n        'name', pe.extname,\n        'type', 'extension'\n    ) as \"metadata!\",\n    format(\n        'extension_in_public_%s',\n        pe.extname\n    ) as \"cache_key!\"\nfrom\n    pg_catalog.pg_extension pe\nwhere\n    -- plpgsql is installed by default in public and outside user control\n    -- confirmed safe\n    pe.extname not in ('plpgsql')\n    -- Scoping this to public is not optimal. Ideally we would use the postgres\n    -- search path. That currently isn't available via SQL. In other lints\n    -- we have used has_schema_privilege('anon', 'extensions', 'USAGE') but that\n    -- is not appropriate here as it would evaluate true for the extensions schema\n    and pe.extnamespace::regnamespace::text = 'public')\nunion all\n\n(\nselect\n    'unsupported_reg_types' as \"name!\",\n    'Unsupported reg types' as \"title!\",\n    'WARN' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['SECURITY'] as \"categories!\",\n    'Identifies columns using unsupported reg* types outside pg_catalog schema, which prevents database upgrades using pg_upgrade.' as \"description!\",\n    format(\n        'Table \\`%s.%s\\` has a column \\`%s\\` with unsupported reg* type \\`%s\\`.',\n        n.nspname,\n        c.relname,\n        a.attname,\n        t.typname\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=unsupported_reg_types' as \"remediation!\",\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'column', a.attname,\n        'type', 'table'\n    ) as \"metadata!\",\n    format(\n        'unsupported_reg_types_%s_%s_%s',\n        n.nspname,\n        c.relname,\n        a.attname\n    ) AS cache_key\nfrom\n    pg_catalog.pg_attribute a\n    join pg_catalog.pg_class c\n        on a.attrelid = c.oid\n    join pg_catalog.pg_namespace n\n        on c.relnamespace = n.oid\n    join pg_catalog.pg_type t\n        on a.atttypid = t.oid\n    join pg_catalog.pg_namespace tn\n        on t.typnamespace = tn.oid\nwhere\n    tn.nspname = 'pg_catalog'\n    and t.typname in ('regcollation', 'regconfig', 'regdictionary', 'regnamespace', 'regoper', 'regoperator', 'regproc', 'regprocedure')\n    and n.nspname not in ('pg_catalog', 'information_schema', 'pgsodium'))\nunion all\n\n(\nwith constants as (\n    select current_setting('block_size')::numeric as bs, 23 as hdr, 4 as ma\n),\n\nbloat_info as (\n    select\n        ma,\n        bs,\n        schemaname,\n        tablename,\n        (datawidth + (hdr + ma - (case when hdr % ma = 0 then ma else hdr % ma end)))::numeric as datahdr,\n        (maxfracsum * (nullhdr + ma - (case when nullhdr % ma = 0 then ma else nullhdr % ma end))) as nullhdr2\n    from (\n        select\n            schemaname,\n            tablename,\n            hdr,\n            ma,\n            bs,\n            sum((1 - null_frac) * avg_width) as datawidth,\n            max(null_frac) as maxfracsum,\n            hdr + (\n                select 1 + count(*) / 8\n                from pg_stats s2\n                where\n                    null_frac <> 0\n                    and s2.schemaname = s.schemaname\n                    and s2.tablename = s.tablename\n            ) as nullhdr\n        from pg_stats s, constants\n        group by 1, 2, 3, 4, 5\n    ) as foo\n),\n\ntable_bloat as (\n    select\n        schemaname,\n        tablename,\n        cc.relpages,\n        bs,\n        ceil((cc.reltuples * ((datahdr + ma -\n          (case when datahdr % ma = 0 then ma else datahdr % ma end)) + nullhdr2 + 4)) / (bs - 20::float)) as otta\n    from\n        bloat_info\n        join pg_class cc\n            on cc.relname = bloat_info.tablename\n        join pg_namespace nn\n            on cc.relnamespace = nn.oid\n            and nn.nspname = bloat_info.schemaname\n            and nn.nspname <> 'information_schema'\n        where\n            cc.relkind = 'r'\n            and cc.relam = (select oid from pg_am where amname = 'heap')\n),\n\nbloat_data as (\n    select\n        'table' as type,\n        schemaname,\n        tablename as object_name,\n        round(case when otta = 0 then 0.0 else table_bloat.relpages / otta::numeric end, 1) as bloat,\n        case when relpages < otta then 0 else (bs * (table_bloat.relpages - otta)::bigint)::bigint end as raw_waste\n    from\n        table_bloat\n)\n\nselect\n    'table_bloat' as \"name!\",\n    'Table Bloat' as \"title!\",\n    'INFO' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['PERFORMANCE'] as \"categories!\",\n    'Detects if a table has excess bloat and may benefit from maintenance operations like vacuum full or cluster.' as \"description!\",\n    format(\n        'Table `%s`.`%s` has excessive bloat',\n        bloat_data.schemaname,\n        bloat_data.object_name\n    ) as \"detail!\",\n    'Consider running vacuum full (WARNING: incurs downtime) and tweaking autovacuum settings to reduce bloat.' as \"remediation!\",\n    jsonb_build_object(\n        'schema', bloat_data.schemaname,\n        'name', bloat_data.object_name,\n        'type', bloat_data.type\n    ) as \"metadata!\",\n    format(\n        'table_bloat_%s_%s',\n        bloat_data.schemaname,\n        bloat_data.object_name\n    ) as \"cache_key!\"\nfrom\n    bloat_data\nwhere\n    bloat > 70.0\n    and raw_waste > (20 * 1024 * 1024) -- filter for waste > 200 MB\norder by\n    schemaname,\n    object_name)\nunion all\n\n(\nselect\n    'extension_versions_outdated' as \"name!\",\n    'Extension Versions Outdated' as \"title!\",\n    'WARN' as \"level!\",\n    'EXTERNAL' as \"facing!\",\n    array['SECURITY'] as \"categories!\",\n    'Detects extensions that are not using the default (recommended) version.' as \"description!\",\n    format(\n        'Extension `%s` is using version `%s` but version `%s` is available. Using outdated extension versions may expose the database to security vulnerabilities.',\n        ext.name,\n        ext.installed_version,\n        ext.default_version\n    ) as \"detail!\",\n    'https://supabase.com/docs/guides/database/database-linter?lint=0022_extension_versions_outdated' as \"remediation!\",\n    jsonb_build_object(\n        'extension_name', ext.name,\n        'installed_version', ext.installed_version,\n        'default_version', ext.default_version\n    ) as \"metadata!\",\n    format(\n        'extension_versions_outdated_%s_%s',\n        ext.name,\n        ext.installed_version\n    ) as \"cache_key!\"\nfrom\n    pg_catalog.pg_available_extensions ext\njoin\n    -- ignore versions not in pg_available_extension_versions\n    -- e.g. residue of pg_upgrade\n    pg_catalog.pg_available_extension_versions extv\n    on extv.name = ext.name and extv.installed\nwhere\n    ext.installed_version is not null\n    and ext.default_version is not null\n    and ext.installed_version != ext.default_version\norder by\n    ext.name)",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "name!",
        "type_info": "Text"
      },
      {
        "ordinal": 1,
        "name": "title!",
        "type_info": "Text"
      },
      {
        "ordinal": 2,
        "name": "level!",
        "type_info": "Text"
      },
      {
        "ordinal": 3,
        "name": "facing!",
        "type_info": "Text"
      },
      {
        "ordinal": 4,
        "name": "categories!",
        "type_info": "TextArray"
      },
      {
        "ordinal": 5,
        "name": "description!",
        "type_info": "Text"
      },
      {
        "ordinal": 6,
        "name": "detail!",
        "type_info": "Text"
      },
      {
        "ordinal": 7,
        "name": "remediation!",
        "type_info": "Text"
      },
      {
        "ordinal": 8,
        "name": "metadata!",
        "type_info": "Jsonb"
      },
      {
        "ordinal": 9,
        "name": "cache_key!",
        "type_info": "Text"
      }
    ],
    "parameters": {
      "Left": []
    },
    "nullable": [
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null
    ]
  },
  "hash": "02927e584e85871ba6f84c58e8b5e4454b2c36eaf034657d5d2d95633fb85bdb"
}
